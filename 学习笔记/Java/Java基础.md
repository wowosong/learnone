## 1、Java数组：针对数组（Array）的各种操作

数组是最常见的一种数据结构，它是相同类型的用一个标识符封装到一起的基本类型数据序列或者对象序列。数组使用一个统一的数组名和不同的下标来唯一确定数组中的元素。实质上，数组是一个简单的线性序列，因此访问速度很快。

本章将详细介绍 Java 中数组的创建、初始化和处理方法，如获取数组长度、查找数组元素和数组排序等。

### 1.1Java数组简介：数组是什么？

在某些情况下，虽然可以使用单个变量来存储信息，但是如果需要存储的信息较多（例如存储 50 名学生的成绩），这时再依次创建变量声明并赋值显得非常麻烦。

随着处理的信息量越来越大，工作也就越来越烦琐，这时可以使用数组或集合来存储信息。通过使用数组，可以在很大程度上缩短和简化程序代码，从而提高应用程序的效率。

数组（array）是一种最简单的复合数据类型，它是有序数据的集合，数组中的每个元素具有相同的数据类型，可以用一个统一的数组名和不同的下标来确定数组中唯一的元素。根据数组的维度，可以将其分为一维数组、二维数组和多维数组等。

在计算机语言中数组是非常重要的集合类型，大部分计算机语言中数组具有如下三个基本特性：

1.  一致性：数组只能保存相同数据类型元素，元素的数据类型可以是任何相同的数据类型。
2. 有序性：数组中的元素是有序的，通过下标访问。
3. 不可变性：数组一旦初始化，则长度（数组中元素的个数）不可变。


总的来说，数组具有以下特点：

- 数组可以是一维数组、二维数组或多维数组。
- 数值数组元素的默认值为 0，而引用元素的默认值为 null。
- 数组的索引从 0 开始，如果数组有 n 个元素，那么数组的索引是从 0 到（n-1）。
- 数组元素可以是任何类型，包括数组类型。
- 数组类型是从抽象基类 Array 派生的引用类型。


注意：如果你熟悉 C/[C++](http://c.biancheng.net/cplus/)，请注意，[Java](http://c.biancheng.net/java/) 数组的工作原理与它们不同。

在 Java 中数组的下标是从零开始的，很多计算机语言的数组下标也从零开始。Java 数组下标访问运算符是中括号，如 intArray[0]，表示访问 intArray 数组的第一个元素，0 是第一个元素的下标。Java 中的数组本身是引用数据类型，它的长度属性是 length。

### 1.2Java一维数组的定义、赋值和初始化

当数组中每个元素都只带有一个下标时，这种数组就是“一维数组”。一维数组（one-dimensional array）实质上是一组相同类型数据的线性集合，是数组中最简单的一种数组。

数组是引用数据类型，引用数据类型在使用之前一定要做两件事情：声明和初始化。所以本文将重点介绍一维数组的创建、初始化和使用。

#### 创建一维数组

为了在程序中使用一个数组，必须声明一个引用该数组的变量，并指明整个变量可以引用的数组类型。声明一维数组的语法格式为：

```java
type[] arrayName;    // 数据类型[] 数组名;
```

或者

```java
type arrayName[];    // 数据类型 数组名[];
```

可见数组的声明有两种形式：一种是中括号”[]“跟在元素数据类型之后，另一种是中括号”[]“跟在变量名之后。

对于以上两种语法格式而言，[Java](http://c.biancheng.net/java/) 更推荐采用第一种声明格式，因为第一种格式不仅具有更好的语意，而且具有更好的可读性。对于第一种格式`type[] arrayName`，很容易理解这是定义一个变量，其中变量名是 arrayName，而变量类型是 type[]。

前面已经指出：type[] 确实是一种新类型，与 type 类型完全不同（例如 int 类型是基本类型，但 int[] 是引用类型）。因此，这种方式既容易理解，也符合定义变量的语法。但第二种格式`type arrayName[]`的可读性就差了，看起来好像定义了一个类型为 type 的变量，而变量名是 arrayName[]，这与真实的含义相去甚远。

可能有些读者非常喜欢`type arrayName[]`这种定义数组的方式，这可能是因为早期某些计算机读物的误导，从现在开始最好就不要再使用这种糟糕的方式了。

提示：Java 的模仿者 [C#](http://c.biancheng.net/csharp/) 就不再支持`type arrayName[]`这种语法，它只支持第一种定义数组的语法。越来越多的语言不再支持`type arrayName[]`这种数组定义语法。

以上两种格式都可以声明一个数组，其中的数据类型既可以是基本数据类型，也可以是引用数据类型。数组名可以是任意合法的变量名。声明数组就是要告诉计算机该数组中数据的类型是什么。例如：

```java
int[] score;    // 存储学生的成绩，类型为整型
double[] price;    // 存储商品的价格，类型为浮点型
String[] name;    // 存储商品名称，类型为字符串型
```


在声明数组时不需要规定数组的长度，例如：

```java
int score[10];    // 这是错误的
```


注意：在声明数组变量时千万不要漏写[]。

#### 分配空间

声明了数组，只是得到了一个存放数组的变量，并没有为数组元素分配内存空间，不能使用。因此要为数组分配内存空间，这样数组的每一个元素才有一个空间进行存储。

简单地说，分配空间就是要告诉计算机在内存中为它分配几个连续的位置来存储数据。在 Java 中可以使用 new 关键字来给数组分配空间。分配空间的语法格式如下：

```java
arrayName = new type[size];    // 数组名 = new 数据类型[数组长度];
```

其中，数组长度就是数组中能存放的元素个数，显然应该为大于 0 的整数，例如：

```java
score = new int[10];price = new double[30];name = new String[20];
```

这里的 score 是已经声明过的 int[] 类型的变量，当然也可以在声明数组时就给它分配空间，语法格式如下：

```java
type[] arrayName = new type[size];    // 数据类型[] 数组名 = new 数据类型[数组长度];
```

例 1

例如，声明并分配一个长度为 5 的 int 类型数组 arr，代码如下：

```java
int[] arr = new int[5];
```

执行后 arr 数组在内存中的格式如图 1 所示。



![img](/Users/jiusonghuang/pic-md/20210712172212.jpeg)
图 1 一维数组的内存格式


在图 1 中 arr 为数组名称，方括号“[]”中的值为数组的下标。数组通过下标来区分数组中不同的元素，并且下标是从 0 开始的。因此这里包含 5 个元素的 arr 数组最大下标为 4。

注意：一旦声明了数组的大小，就不能再修改。这里的数组长度也是必需的，不能少。

尽管数组可以存储一组基本数据类型的元素，但是数组整体属于引用数据类型。当声明一个数组变量时，其实是创建了一个类型为“数据类型[]”（如 int[]、double[]、String[]）的数组对象，它具有表 1 所示的方法和属性。



| 方法                         | 名称     | 返回值 |
| ---------------------------- | -------- | ------ |
| clone()                      | Object   |        |
| equals(Object obj)           | boolean  |        |
| getClass()                   | Class<?> |        |
| hashCode()                   | int      |        |
| notify()                     | void     |        |
| notify All()                 | void     |        |
| toString()                   | String   |        |
| wait()                       | void     |        |
| wait(long timeout)           | void     |        |
| wait(long timeout,int nanos) | void     |        |
| 属性                         | length   | int    |



#### 初始化一维数组

Java 语言中数组必须先初始化，然后才可以使用。所谓初始化，就是为数组的数组元素分配内存空间，并为每个数组元素赋初始值。

能不能只分配内存空间，不赋初始值呢？

不行，一旦为数组的每个数组元素分配了内存空间，每个内存空间里存储的内容就是该数组元素的值，即使这个内存空间存储的内容为空，这个空也是一个值（null）。不管以哪种方式来初始化数组，只要为数组元素分配了内存空间，数组元素就具有了初始值。初始值的获得有两种形式，一种由系统自动分配，另一种由程序员指定。

数组在初始化数组的同时，可以指定数组的大小，也可以分别初始化数组中的每一个元素。在 Java 语言中，初始化数组有以下 3 种方式。

##### 1）使用 new 指定数组大小后进行初始化

使用 new 关键字创建数组，在创建时指定数组的大小。语法如下：

```java
type[] arrayName = new int[size];
```

创建数组之后，元素的值并不确定，需要为每一个数组的元素进行赋值，其下标从 0 开始。

例 2

创建包含 5 个元素的 int 类型的数组，然后分别将元素的值设置为 1、2、3、5 和 8。代码如下：

```java
int[] number = new int[5];number[0] = 1;number[1] = 2;number[2] = 3;number[3] = 5;number[4] = 8;
```


如果程序员只指定了数组的长度，那么系统将负责为这些数组元素分配初始值。指定初始值时，系统按如下规则分配初始值。

- 数组元素的类型是基本类型中的整数类型（byte、short、int 和 long），则数组元素的值是 0。
- 数组元素的类型是基本类型中的浮点类型（float、double），则数组元素的值是 0.0。
- 数组元素的类型是基本类型中的字符类型（char），则数组元素的值是‘\u0000’。
- 数组元素的类型是基本类型中的布尔类型（boolean），则数组元素的值是 false。
- 数组元素的类型是引用类型（类、接口和数组），则数组元素的值是 null。

##### 2）使用 new 指定数组元素的值

使用上述方式初始化数组时，只有在为元素赋值时才确定值。可以不使用上述方式，而是在初始化时就已经确定值。语法如下：

```java
type[] arrayName = new type[]{值 1,值 2,值 3,值 4,• • •,值 n};
```

例 3

更改例 2 中的代码，使用 new 直接指定数组元素的值。代码如下：

```java
int[] number = new int[]{1, 2, 3, 5, 8};
```

上述代码的效果等价于例 2 的效果。

注意：不要在进行数组初始化时，既指定数组的长度，也为每个数组元素分配初始值，这样会造成代码错误。例如下面代码：

```
int[] number = new int [5] {1,2,3,4,5};
```

##### 3）直接指定数组元素的值

在上述两种方式的语法中，type 可以省略，如果已经声明数组变量，那么直接使用这两种方式进行初始化。如果不想使用上述两种方式，那么可以不使用 new 直接指定数组元素的值。语法如下：

```java
type[] arrayName = {值 1,值 2,值 3,...,值 n};
```

例 4

在前面例子的基础上更改代码，直接使用上述语法实现 number 数组的初始化。代码如下：

```java
int[] number = {1,2,3,5,8};
```

使用这种方式时，数组的声明和初始化操作要同步，即不能省略数组变量的类型。如下的代码就是错误的：

```java
int[] number;
number = {1,2,3,5,8};
```

#### 获取单个元素

获取单个元素是指获取数组中的一个元素，如第一个元素或最后一个元素。获取单个元素的方法非常简单，指定元素所在数组的下标即可。语法如下：

```java
arrayName[index];
```

其中，arrayName 表示数组变量，index 表示下标，下标为 0 表示获取第一个元素，下标为 array.length-1 表示获取最后一个元素。当指定的下标值超出数组的总长度时，会拋出 ArraylndexOutOfBoundsException 异常。

例 5

获取 number 数组中的第一个元素、最后一个元素和第六个元素，并将元素的值输出。代码如下：

```java
int[] number = {1,2,3,5,8};
System.out.println("获取第一个元素："+number[0]);
System.out.println("获取最后一个元素："+number[number.length-1]);
System.out.println("获取第6个元素："+number[5]);
```

执行上述代码，输出结果如下所示：

```
获取第一个元素：1
获取最后一个元素：8
java.lang.ArrayIndexOutOfBoundsException: 5
```

我们一共存入了 5 个值，所以下标的取值为 0~4。因为 number[5] 取出的内容超过了这个下标，所以输出结果会提示数组索引超出绑定异常（ArrayIndexOutOfBoundsException）。这一点是在使用数组中是经常出现的问题，大家在编写程序时应该引起注意。

例 6

编写一个 Java 程序，使用数组存放录入的 5 件商品价格，然后使用下标访问第 3 个元素的值。

```java
import java.util.Scanner;
public class Test06 { 
public static void main(String[] args) { 
    int[] prices = new int[5]; // 声明数组并分配空间   
    Scanner input = new Scanner(System.in); // 接收用户从控制台输入的数据  
    for (int i = 0; i < prices.length; i++) { 
        System.out.println("请输入第" + (i + 1) + "件商品的价格："); 
        prices[i] = input.nextInt(); // 接收用户从控制台输入的数据   
    }       
    System.out.println("第 3 件商品的价格为：" + prices[2]);   
    }
}
```

上述代码的“int[] prices = new int[5]”语句创建了需要 5 个元素空间的 prices 数组，然后结合 for 循环向数组中的每个元素赋值。

注意：在 Java 中取得数组的长度（也就是数组元素的长度）可以利用“数组名称.length”，返回一个 int 型数据。

数组的索引从 0 开始，而 for 循环中的变量 i 也从 0 开始，因此 score 数组中的元素可以使用 scored 来表示，大大简化了代码。最后使用 prices[2] 获取 prices 数组的第 3 个元素，最终运行效果如下所示。

```
请输入第1件商品的价格：
5
请输入第2件商品的价格：
4
请输入第3件商品的价格：
6
请输入第4件商品的价格：
4
请输入第5件商品的价格：
8
第 3 件商品的价格为：6
```

#### 获取全部元素

当数组中的元素数量不多时，要获取数组中的全部元素，可以使用下标逐个获取元素。但是，如果数组中的元素过多，再使用单个下标则显得烦琐，此时使用一种简单的方法可以获取全部元素——使用循环语句。

下面利用 for 循环语句遍历 number 数组中的全部元素，并将元素的值输出。代码如下：

```java
int[] number = {1,2,3,5,8};
for (int i=0;i<number.length;i++) { 
	System.out.println("第"+(i+1)+"个元素的值是："+number[i]);
}
```

除了使用 for 语句，还可以使用 foreach 遍历数组中的元素，并将元素的值输出。代码如下:

```java
for(int val:number) {  
	System.out.print("元素的值依次是："+val+"\t");
}
```

### 1.3Java二维数组详解

为了方便组织各种信息，计算机常将信息以表的形式进行组织，然后再以行和列的形式呈现出来。二维数组的结构决定了其能非常方便地表示计算机中的表，以第一个下标表示元素所在的行，第二个下标表示元素所在的列。下面简单了解一下二维数组，包括数组的声明和初始化。

#### 创建二维数组

在 [Java](http://c.biancheng.net/java/) 中二维数组被看作数组的数组，即二维数组为一个特殊的一维数组，其每个元素又是一个一维数组。Java 并不直接支持二维数组，但是允许定义数组元素是一维数组的一维数组，以达到同样的效果。声明二维数组的语法如下：

```java
type arrayName[][];    // 数据类型 数组名[][];
```

或

```java
type[][] arrayName;    // 数据类型[][] 数组名;
```

其中，type 表示二维数组的类型，arrayName 表示数组名称，第一个中括号表示行，第二个中括号表示列。

下面分别声明 int 类型和 char 类型的数组，代码如下：

```java
int[][] age;
char[][] sex;
```

#### 初始化二维数组

二维数组可以初始化，和一维数组一样，可以通过 3 种方式来指定元素的初始值。这 3 种方式的语法如下：

```java
type[][] arrayName = new type[][]{值 1,值 2,值 3,…,值 n};    // 在定义时初始化
type[][] arrayName = new type[size1][size2];    // 给定空间，在赋值
type[][] arrayName = new type[size][];    // 数组第二维长度为空，可变化
```

例 1

使用第一种方式声明 int 类型的二维数组，然后初始化该二维数组。代码如下：

```java
int[][] temp = new int[][]{{1,2},{3,4}};
```

上述代码创建了一个二行二列的二维数组 temp，并对数组中的元素进行了初始化。图 1 所示为该数组的内存结构。



![img](/Users/jiusonghuang/pic-md/20210713093957.jpeg)
图1 二维数组内存结构


使用第二种方式声明 int 类型的二维数组，然后初始化该二维数组。代码如下：

```java
int[][] temp = new int[2][2];
```

使用第三种方式声明 int 类型的二维数组，并且初始化数组。代码如下：

```java
int[][] temp = new int[2][];
```

#### 获取单个元素

在上部分使用的前 2 种方式创建并初始化了一个二行二列的 int 类型数组 temp。当需要获取二维数组中元素的值时，也可以使用下标来表示。语法如下：

```java
arrayName[i-1][j-1];
```

其中，arrayName 表示数组名称，i 表示数组的行数，j 表示数组的列数。例如，要获取第二行第二列元素的值，应该使用 temp[1][1]来表示。这是由于数组的下标起始值为 0，因此行和列的下标需要减 1。

例 2

通过下标获取 class_score 数组中第二行第二列元素的值与第四行第一列元素的值。代码如下：

```java
public static void main(String[] args) { 
    double[][] class_score = {{10.0,99,99},{100,98,97},{100,100,99.5},{99.5,99,98.5}};    	  System.out.println("第二行第二列元素的值："+class_score[1][1]);   
    System.out.println("第四行第一列元素的值："+class_score[3][0]);
}
```

执行上述代码，输出结果如下：

```
第二行第二列元素的值：98.0
第四行第一列元素的值：99.5
```

#### 获取全部元素

在一维数组中直接使用数组的 length 属性获取数组元素的个数。而在二维数组中，直接使用 length 属性获取的是数组的行数，在指定的索引后加上 length（如 array[0].length）表示的是该行拥有多少个元素，即列数。

如果要获取二维数组中的全部元素，最简单、最常用的办法就是使用 for 语句。在一维数组全部输出时，我们使用一层 for 循环，而二维数组要想全部输出，则使用嵌套 for 循环（2 层 for 循环）。

例 3

使用 for 循环语句遍历 double 类型的 class_score 数组的元素，并输出每一行每一列元素的值。代码如下：

```java
public static void main(String[] args) { 
double[][] class_score = { { 100, 99, 99 }, { 100, 98, 97 }, { 100, 100, 99.5 }, { 99.5, 99, 98.5 } };    
for (int i = 0; i < class_score.length; i++) {
    // 遍历行       
    for (int j = 0; j < class_score[i].length; j++) {  
        	System.out.println("class_score[" + i + "][" + j + "]=" + class_score[i][j]); 
        }   
    }
}
```

上述代码使用嵌套 for 循环语句输出二维数组。在输出二维数组时，第一个 for 循环语句表示以行进行循环，第二个 for 循环语句表示以列进行循环，这样就实现了获取二维数组中每个元素的值的功能。

执行上述代码，输出结果如下所示。

```
class_score[0][0]=100.0
class_score[0][1]=99.0
class_score[0][2]=99.0
class_score[1][0]=100.0
class_score[1][1]=98.0
class_score[1][2]=97.0
class_score[2][0]=100.0
class_score[2][1]=100.0
class_score[2][2]=99.5
class_score[3][0]=99.5
class_score[3][1]=99.0
class_score[3][2]=98.5
```

例 4

假设有一个矩阵为 5 行 5 列，该矩阵是由程序随机产生的 10 以内数字排列而成。下面使用二维数组来创建该矩阵，代码如下：

```java
public class Test11 {   
	public static void main(String[] args) {        
     // 创建一个二维矩阵        
     int[][] matrix = new int[5][5];       
    // 随机分配值        
    for (int i = 0; i < matrix.length; i++) { 
        for (int j = 0; j < matrix[i].length; j++) {   
       		matrix[i][j] = (int) (Math.random() * 10);           
        }       
    }       
    System.out.println("下面是程序生成的矩阵\n");     
    // 遍历二维矩阵并输出     
    for (int k = 0; k < matrix.length; k++) {     
        for (int g = 0; g < matrix[k].length; g++) { 
        	System.out.print(matrix[k][g] + "");        
        }        
        	System.out.println();      
        }   
    }
}
```

在该程序中，首先定义了一个二维数组，然后使用两个嵌套的 for 循环向二维数组中的每个元素赋值。其中，Math.random() 方法返回的是一个 double 类型的数值，数值为 0.6、0.9 等，因此乘以 10 之后为 10 以内的整数。最后又使用了两个嵌套的 for 循环遍历二维数组，输出二维数组中的值，从而产生矩阵。

运行该程序的结果如下所示。

```
下面是程序生成的矩阵
78148
69230
43823
75663
05688
```

for each 循环语句不能自动处理二维数组的每一个元素。它是按照行，也就是一维数组处理的。要想访问二维教组 a 的所有元素， 需要使用两个嵌套的循环， 如下所示：

```java
for (double[] row : a) {
    for (double value : row)
    {        ......    }
}
```

把【例2】修改为使用 for each 循环语句输出，代码如下所示：

```java
public static void main(String[] args) { 
double[][] class_score = { { 100, 99, 99 }, { 100, 98, 97 }, { 100, 100, 99.5 }, { 99.5, 99, 98.5 } }; 
    for (double[] row : class_score) {  
        for (double value : row) {    
        	System.out.println(value);    
        }
	}
}
```

输出结果为：

100.0
99.0
99.0
100.0
98.0
97.0
100.0
100.0
99.5
99.5
99.0
98.5

提示：要想快速地打印一个二维数组的数据元素列表，可以调用：

```java
System.out.println(Arrays.deepToString(arrayName));
```

代码如下：

```java
System.out.println(Arrays.deepToString(class_score));
```

输出格式为：

[[100.0, 99.0, 99.0], [100.0, 98.0, 97.0], [100.0, 100.0, 99.5], [99.5, 99.0, 98.5]]

#### 获取整行元素

除了获取单个元素和全部元素之外，还可以单独获取二维数组的某一行中所有元素的值，或者二维数组中某一列元素的值。获取指定行的元素时，需要将行数固定，然后只遍历该行中的全部列即可。

例 5

编写一个案例，接收用户在控制台输入的行数，然后获取该行中所有元素的值。代码如下：

```java
public static void main(String[] args) { 
    double[][] class_score = { { 100, 99, 99 }, { 100, 98, 97 }, { 100, 100, 99.5 }, { 99.5, 99, 98.5 } };   
    Scanner scan = new Scanner(System.in);  
    System.out.println("当前数组只有" + class_score.length + "行，您想查看第几行的元素？请输入：");    
    int number = scan.nextInt();    
    for (int j = 0; j < class_score[number - 1].length; j++) { 
        System.out.println("第" + number + "行的第[" + j + "]个元素的值是：" + class_score[number - 1][j]);    
    }
}
```

执行上述代码进行测试，输出结果如下所示。

```
当前数组只有4行，您想查看第几行的元素？请输入：
3
第3行的第[0]个元素的值是：100.0
第3行的第[1]个元素的值是：100.0
第3行的第[2]个元素的值是：99.5
```

#### 获取整列元素

获取指定列的元素与获取指定行的元素相似，保持列不变，遍历每一行的该列即可。

例 6

编写一个案例，接收用户在控制台中输入的列数，然后获取二维数组中所有行中该列的值。代码如下：

```java
public static void main(String[] args) {    
    double[][] class_score = { { 100, 99, 99 }, { 100, 98, 97 }, { 100, 100, 99.5 }, { 99.5, 99, 98.5 } };  
    Scanner scan = new Scanner(System.in);   
    System.out.println("您要获取哪一列的值？请输入：");   
    int number = scan.nextInt();   
    for (int i = 0; i < class_score.length; i++) {   
   		System.out.println("第 " + (i + 1) + " 行的第[" + number + "]个元素的值是" + class_score[i][number]);    
    }
}
```

执行上述代码进行测试，如下所示。

```
您要获取哪一列的值？请输入：
2
第 1 行的第[2]个元素的值是99.0
第 2 行的第[2]个元素的值是97.0
第 3 行的第[2]个元素的值是99.5
第 4 行的第[2]个元素的值是98.5
```

### 1.4Java sort()数组排序（升序和降序）

我们在学习 [Java](http://c.biancheng.net/java/) 的过程中肯定会遇到对数组进行升序或降序等排序问题，本节主要介绍如何实现 Java 数组的升序和降序。Java 语言使用 Arrays 类提供的 sort() 方法来对数组进行排序。

#### 升序

使用 java.util.Arrays 类中的 sort() 方法对数组进行升序分为以下两步：

1. 导入 java.util.Arrays 包。
2. 使用 Arrays.sort(数组名) 语法对数组进行排序，排序规则是从小到大，即升序。


假设在数组 scores 中存放了 5 名学生的成绩，现在要实现从低到高排列的功能。在这里使用 Arrays.sort() 方法来实现，具体代码如下：

```java
public static void main(String[] args) { 
    // 定义含有5个元素的数组  
    double[] scores = new double[] { 78, 45, 85, 97, 87 };  
    System.out.println("排序前数组内容如下：");  
    // 对scores数组进行循环遍历    
    for (int i = 0; i < scores.length; i++) {  
        System.out.print(scores[i] + "\t");    
    }   
    System.out.println("\n排序后的数组内容如下：");    
    // 对数组进行排序    
    Arrays.sort(scores);  
    // 遍历排序后的数组   
    for (int j = 0; j < scores.length; j++) { 
    	System.out.print(scores[j] + "\t");  
    }
}
```

如上述代码所示，要对一个数组进行升序排列，只需要调用 Arrays.sort() 方法即可。运行后的输出结果如下所示。

```
排序前数组内容如下：
78.0    45.0    85.0    97.0    87.0   
排序后的数组内容如下：
45.0    78.0    85.0    87.0    97.0
```

#### 降序

在 Java 语言中使用 sort 实现降序有两种方法，简单了解即可。

1）利用 Collections.reverseOrder() 方法（Collections 是一个包装类。大家可以学习《[Java Collections类](http://c.biancheng.net/view/6884.html)》一节详细了解）：

```java
public static void main(String[] args) {  
    Integer[] a = { 9, 8, 7, 2, 3, 4, 1, 0, 6, 5 };    
    // 数组类型为Integer    
    Arrays.sort(a, Collections.reverseOrder());  
    for (int arr : a) {    
   		System.out.print(arr + " ");  
    }
}
```

输出结果如下：

9 8 7 6 5 4 3 2 1 0 

2）实现 Comparator 接口的复写 compare() 方法，代码如下:

```java
public class Test {    
public static void main(String[] args) { 
        /*         
        * 注意，要想改变默认的排列顺序，不能使用基本类型（int,double,char）而要使用它们对应的包装类     
        */      
        Integer[] a = { 9, 8, 7, 2, 3, 4, 1, 0, 6, 5 };  
        // 定义一个自定义类MyComparator的对象  
        Comparator cmp = new MyComparator();    
        Arrays.sort(a, cmp);  
        for (int arr : a) {       
         	System.out.print(arr + " ");   
        }   
    }
}
// 实现Comparator接口
class MyComparator implements Comparator<Integer> {  
  @Override   
  public int compare(Integer o1, Integer o2) { 
  /*       
  * 如果o1小于o2，我们就返回正值，如果o1大于o2我们就返回负值， 这样颠倒一下，就可以实现降序排序了,反之即可自定义升序排序了         
  */    
	return o2 - o1; 
  }
}
```

输出结果如下所示。

9 8 7 6 5 4 3 2 1 0 

注意：使用以上两种方法时，数组必须是包装类型，否则会编译不通过。

在 Java 中实现数组排序的方式很多，除了利用以上的几种方法外，还可以编写自定义方法来实现自己的排序算法，有兴趣的读者可以尝试编写。

### 1.5Java冒泡排序法（非常重要）

冒泡排序（Bubble Sort）是常用的数组排序算法之一，它以简洁的思想与实现方法而备受青睐，也是广大学习者最先接触的一种排序算法。

冒泡排序的基本思想是：对比相邻的元素值，如果满足条件就交换元素值，把较小的元素值移动到数组前面，把大的元素值移动到数组后面（也就是交换两个元素的位置），这样数组元素就像气泡一样从底部上升到顶部。

冒泡排序的算法比较简单，排序的结果稳定，但时间效率不太高。[Java](http://c.biancheng.net/java/) 中的冒泡排序在双层循环中实现，其中外层循环控制排序轮数，总循环次数为要排序数组的长度减 1。而内层循环主要用于对比相邻元素的大小，以确定是否交换位置，对比和交换次数依排序轮数而减少。

获取用户在控制台输入的 5 个成绩信息，将这些成绩保存到数组中，然后对数组应用冒泡排序，并输出排序后的结果，实现步骤如下。

(1) 创建一个 Test24 类文件，在 main() 方法中开始编码。首先创建 Scanner 类的实例后声明 double 类型的 score 数组，然后接收用户在控制台输入的成绩，并保存到元素中。代码如下：

```java
public static void main(String[] args) {
    Scanner scan = new Scanner(System.in);  
    double[] score = new double[5];  
    for (int i = 0; i < score.length; i++) {    
        System.out.print("请输入第 " + (i + 1) + " 个成绩：");   
        score[i] = scan.nextDouble();   
    }
}
```

(2) 在对 score 数组排序之前，首先输出数组中各个元素的值。代码如下：

```java
System.out.println("排序前的元素值：");
for(double val:score) { 
	System.out.print(val+"\t");
}
System.out.println();
```

(3) 通过冒泡排序方法实现对 score 数组的排序，在实现时需要借助一个临时变量。代码如下：

```java
public static void main(String[] args) {  
    System.out.println("通过冒泡排序方法对数组进行排序：");  
    for (int i = 0; i < score.length - 1; i++) { 
        // 比较相邻两个元素，较大的数往后冒泡    
        for (int j = 0; j < score.length - 1 - i; j++) {  
            if (score[j] > score[j + 1]) { 
                double temp = score[j + 1];  // 把第一个元素值保存到临时变量中        
                score[j + 1] = score[j]; // 把第二个元素值转移到第一个元素变量中   
                score[j] = temp; // 把临时变量（第一个元素的原值）保存到第二个元素中  
        	}            
        System.out.print(score[j] + " ");
        // 对排序后的数组元素进行输出      
    	}        
    System.out.print("【");   
    for (int j = score.length - 1 - i; j < score.length; j++) {
   		 System.out.print(score[j] + " ");      
    }   
    System.out.println("】");  
  }
}
```

(4) 运行前面的代码进行测试，如下所示。

```
请输入第 1 个成绩：77
请输入第 2 个成绩：90
请输入第 3 个成绩：68
请输入第 4 个成绩：59
请输入第 5 个成绩：80
排序前的元素值：
77.0    90.0    68.0    59.0    80.0   
通过冒泡排序方法对数组进行排序：
77.0 68.0 59.0 80.0 【90.0 】
68.0 59.0 77.0 【80.0 90.0 】
59.0 68.0 【77.0 80.0 90.0 】
59.0 【68.0 77.0 80.0 90.0 】
```

### 1.6Java快速排序法（Quicksort）

快速排序（Quicksort）是对冒泡排序的一种改进，是一种排序执行效率很高的排序算法。

快速排序的基本思想是：通过一趟排序，将要排序的数据分隔成独立的两部分，其中一部分的所有数据比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此使整个数据变成有序序列。

具体做法是：假设要对某个数组进行排序，首先需要任意选取一个数据（通常选用第一个数据）作为关键数据，然后将所有比它小的数都放到它的前面，所有比它大的数都放到它的后面。这个过程称为一趟快速排序；递归调用此过程，即可实现数据的快速排序。

利用快速排序法对一数组进行排序，实现步骤如下。

(1) 声明静态的 getMiddle() 方法，该方法需要返回一个 int 类型的参数值，在该方法中传入 3 个参数。代码如下：

```java
public static int getMiddle(int[] list, int low, int high) { 
    int tmp = list[low]; // 数组的第一个值作为中轴（分界点或关键数据）  
    while (low < high) { 
        while (low < high && list[high] > tmp) {   
        	high--;        
        }     
        list[low] = list[high]; // 比中轴小的记录移到低端    
        while (low < high && list[low] < tmp) {  
            low++;     
        }      
        list[high] = list[low]; // 比中轴大的记录移到高端   
    }   
    list[low] = tmp; // 中轴记录到尾   
    return low; // 返回中轴的位置
}
```

(2) 创建静态的 unckSort() 方法，在该方法中判断 low 参数是否小于 high 参数，如果是则调用 getMiddle() 方法，将数组一分为二，并且调用自身的方法进行递归排序。代码如下：

```java
public static void unckSort(int[] list,int low,int high) { 
	if(low < high) {        
        int middle = getMiddle(list,low,high);   // 将list数组一分为二       
        unckSort(list,low,middle-1);    // 对低字表进行递归排序    
        unckSort(list,middle+1,high);    // 对高字表进行递归排序 
    }
}
```

(3) 声明静态的 quick() 方法，在该方法中判断传入的数组是否为空，如果不为空，则调用 unckSort() 方法进行排序。代码如下：

```java
public static void quick(int[] str) { 
    if(str.length > 0) {  
        // 查看数组是否为空       
        unckSort(str,0,str.length-1);  
    }
}
```

(4) 在 main() 方法中声明 int 类型的 number 数组，接着输出该数组中的元素。然后调用自定义的 quick() 方法进行排序，排序后重新输出数组中的元素。代码如下：

```java
int[] number={13,15,24,99,14,11,1,2,3};
System.out.println("排序前：");
for(int val:number) {   
	System.out.print(val+" ");
}
quick(number);
System.out.println("\n排序后：");
for(int val:number) {  
	System.out.print(val +" ");
}
```

运行前面的代码进行测试，输出结果如下：

```
排序前：
13 15 24 99 14 11 1 2 3
排序后：
1 2 3 11 13 14 15 24 99 
```

### 1.7Java选择排序法

假设当前存在一个 int 类型的数组 number，该数组中的元素依次是 13、15、 24、99、4 和 1。如果使用冒泡排序进行两两相邻比较，第一趟排序后的结果如下：

```java
13、15、24、4、1、99
```


第二趟排序后的结果如下：

```java
13、15、4、1、24、99
```


第三趟排序后的结果如下：

```java
13、4、1、15、24、99
```


第四趟排序后的结果如下：

```
4、1、13、15、24、99
```


第五趟排序后的结果如下：

```
1、4、13、15、24、99
```


使用选择排序法也可以对上述数组中的元素进行排序，但是它与冒泡排序不同。选择排序是指每一趟从待排序的数据元素中选出最大（或最小）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。例如，使用选择排序法重新对 number 数组中的元素进行排序，那么第一趟排序后的结果如下：

```
13、15、24、1、4、99
```


第二趟排序后的结果如下：

```
13、15、4、1、24、99
```


第三趟排序后的结果如下：

```
13、1、4、15、24、99
```


第四趟排序后的结果如下：

```
4、1、13、15、24、99
```


第五趟排序后的结果如下：

```
1、4、13、15、24、99
```



利用选择排序方法通过编程的方式实现对 number 数组的排序，并输出已排序的数组元素。代码如下：

```java
int[] number = {13,15,24,99,4,1};
String end = "\n";
int index;
for (int i = 1;i < number.length;i++) {
    index = 0;   
    for(int j = 1;j <= number.length-i;j++) { 
        if (number[j] > number[index]) {    
        	index = j;    // 查找最大值的下标      
        }  
    }   
    end = number[index] + " " + end;    // 定位已排好的数组元素   
    int temp = number[number.length-i];    
    number[number.length-1] = number[index];    
    number[index] = temp;   
}
```


执行上述代码，查看每一趟排序后的结果，运行结果如下所示。

```
【13 15 24 1 4 】99
【13 15 4 1 】24 99
【13 1 4 】15 24 99
【4 1 】13 15 24 99
【1 】4 13 15 24 99
```

### 1.8Java直接插入排序法

直接插入排序的基本思想是：将 n 个有序数存放在数组 a 中，要插入的数为 x，首先确定 x 插在数组中的位置 p，然后将 p 之后的元素都向后移一个位置，空出 a(p)，将 x 放入 a(p)，这样可实现插入 x 后仍然有序。

本例子通过直接插入的方法对上述例子中的 number 数组进行排序。创建一个 Test27 类文件，在 main() 方法中开始编码，具体实现代码如下：

```java
public static void main(String[] args) { 
    int[] number = { 13, 15, 24, 99, 4, 1 };  
    System.out.println("排序前：");    
    for (int val : number) { // 遍历数组元素    
   		 System.out.print(val + " "); // 输出数组元素  
    }    
    int temp, j;   
    for (int i = 1; i < number.length; i++) {
        temp = number[i];     
        for (j = i - 1; j >= 0 && number[j] > temp; j--) {  
       		number[j + 1] = number[j];     
        }        
        number[j + 1] = temp; 
    }   
    System.out.println("\n排序后：");  
    for (int val : number) { // 遍历数组元素   
    	System.out.print(val + " "); // 输出数组元素 
    }
}
```

在上述代码中，首先在控制台输出 number 数组中的元素，然后通过 for 循环对数组中的元素进行排序，最后再次输出排序后的元素。

执行上述代码，最终的输出结果如下：

```
排序前：
13 15 24 99 4 1
排序后：
1 4 13 15 24 99 
```

## 2、Java类和对象

### 2.1Java面向对象：对象的概念及面向对象的三个基本特征

面向对象简称 OO（Object Oriented），20 世纪 80 年代以后，有了面向对象分析（OOA）、 面向对象设计（OOD）、面向对象程序设计（OOP）等新的系统开发方式模型的研究。

对 [Java](http://c.biancheng.net/java/) 语言来说，一切皆是对象。把现实世界中的对象抽象地体现在编程世界中，一个对象代表了某个具体的操作。一个个对象最终组成了完整的程序设计，这些对象可以是独立存在的，也可以是从别的对象继承过来的。对象之间通过相互作用传递信息，实现程序开发。

### 2.2对象的概念

Java 是面向对象的编程语言，对象就是面向对象程序设计的核心。所谓对象就是真实世界中的实体，对象与实体是一一对应的，也就是说现实世界中每一个实体都是一个对象，它是一种具体的概念。对象有以下特点：

- 对象具有属性和行为。
- 对象具有变化的状态。
- 对象具有唯一性。
- 对象都是某个类别的实例。
-  一切皆为对象，真实世界中的所有事物都可以视为对象。


例如，在真实世界的学校里，会有学生和老师等实体，学生有学号、姓名、所在班级等属性（数据），学生还有学习、提问、吃饭和走路等操作。学生只是抽象的描述，这个抽象的描述称为“类”。在学校里活动的是学生个体，即张同学、李同学等，这些具体的个体称为“对象”，“对象”也称为“实例”。

### 2.3面向对象的三大核心特性

面向对象开发模式更有利于人们开拓思维，在具体的开发过程中便于程序的划分，方便程序员分工合作，提高开发效率。面向对象程序设计有以下优点。

1. 可重用性：代码重复使用，减少代码量，提高开发效率。下面介绍的面向对象的三大核心特性（继承、封装和多态）都围绕这个核心。
2. 可扩展性：指新的功能可以很容易地加入到系统中来，便于软件的修改。
3. 可管理性：能够将功能与数据结合，方便管理。


该开发模式之所以使程序设计更加完善和强大，主要是因为面向对象具有继承、封装和多态 3 个核心特性。

#### 继承性

如同生活中的子女继承父母拥有的所有财产，程序中的继承性是指子类拥有父类的全部特征和行为，这是类之间的一种关系。Java 只支持单继承。

例如定义一个语文老师类和数学老师类，如果不采用继承方式，那么两个类中需要定义的属性和方法如图 1 所示。



![img](/Users/jiusonghuang/pic-md/20210713171904.jpeg)
图 1 语文老师类和数学老师类中的属性和方法


从图 1 能够看出，语文老师类和数学老师类中的许多属性和方法相同，这些相同的属性和方法可以提取出来放在一个父类中，这个父类用于被语文老师类和数学老师类继承。当然父类还可以继承别的类，如图 2 所示。



![img](/Users/jiusonghuang/pic-md/20210713171909.jpeg)
图 2 父类继承示例图


总结图 2 的继承关系，可以用概括的树形关系来表示，如图 3 所示。



![img](/Users/jiusonghuang/pic-md/20210713171914.jpeg)
图 3 类继承示例图


从图 3 中可以看出，学校主要人员是一个大的类别，老师和学生是学校主要人员的两个子类，而老师又可以分为语文老师和数学老师两个子类，学生也可以分为班长和组长两个子类。

使用这种层次形的分类方式，是为了将多个类的通用属性和方法提取出来，放在它们的父类中，然后只需要在子类中各自定义自己独有的属性和方法，并以继承的形式在父类中获取它们的通用属性和方法即可。

提示：[C++](http://c.biancheng.net/cplus/) 支持多继承，多继承就是一个子类可有多个父类。例如，客轮是轮船也是交通工具，客轮的父类是轮船和交通工具。多继承会引起很多冲突问题，因此现在很多面向对象的语言都不支持多继承。Java 语言是单继承的，即只能有一个父类，但 Java 可以实现多个接口（接口类似于类，但接口的成员没有执行体。详细了解可参考《[Java接口](http://c.biancheng.net/view/6540.html)》一节），可以防止多继承所引起的冲突问题。

#### 封装性

封装是将代码及其处理的数据绑定在一起的一种编程机制，该机制保证了程序和数据都不受外部干扰且不被误用。封装的目的在于保护信息，使用它的主要优点如下。

- 保护类中的信息，它可以阻止在外部定义的代码随意访问内部代码和数据。
- 隐藏细节信息，一些不需要程序员修改和使用的信息，比如取款机中的键盘，用户只需要知道按哪个键实现什么操作就可以，至于它内部是如何运行的，用户不需要知道。
- 有助于建立各个系统之间的松耦合关系，提高系统的独立性。当一个系统的实现方式发生变化时，只要它的接口不变，就不会影响其他系统的使用。例如 U 盘，不管里面的存储方式怎么改变，只要 U 盘上的 USB 接口不变，就不会影响用户的正常操作。
- 提高软件的复用率，降低成本。每个系统都是一个相对独立的整体，可以在不同的环境中得到使用。例如，一个 U 盘可以在多台电脑上使用。


Java 语言的基本封装单位是类。由于类的用途是封装复杂性，所以类的内部有隐藏实现复杂性的机制。Java 提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西，私有的方法数据只能通过该类的成员代码来访问，这就可以确保不会发生不希望的事情。

#### 多态性

面向对象的多态性，即“一个接口，多个方法”。多态性体现在父类中定义的属性和方法被子类继承后，可以具有不同的属性或表现方式。多态性允许一个接口被多个同类使用，弥补了单继承的不足。多态概念可以用树形关系来表示，如图 4 所示。



![img](/Users/jiusonghuang/pic-md/20210713171919.jpeg)
图 4 多态示例图


从图 4 中可以看出，老师类中的许多属性和方法可以被语文老师类和数学老师类同时使用，这样也不易出错。

### 2.4Java类的定义及定义类时可用的关键字

类是 [Java](http://c.biancheng.net/java/) 中的一种重要的引用数据类型，也是组成 Java 程序的基本要素，因为所有的 Java 程序都是基于类的。本节介绍如何定义类。

在 Java 中定义一个类，需要使用 class 关键字、一个自定义的类名和一对表示程序体的大括号。完整语法如下：

```java
[public][abstract|final]  class   <class_name>  [extends   <class_name>  ][implements   <interface_name> ] {
    // 定义属性部分
    <property_type><property1>;
    <property_type><property2>;
    <property_type><property3>;
    …
    // 定义方法部分
    function1();
    function2();
    function3();
    …
}
```

提示：上述语法中，中括号“[]”中的部分表示可以省略，竖线“|”表示“或关系”，**例如 abstract|final，说明可以使用 abstract 或 final 关键字，但是两个关键字不能同时出现。**

上述语法中各关键字的描述如下。

- `public`：表示“共有”的意思。如果使用 public 修饰，则可以被其他类和程序访问。每个 Java 程序的主类都必须是 public 类，作为公共工具供其他类和程序使用的类应定义为 public 类。
- `abstract`：如果类被 abstract 修饰，则该类为抽象类，抽象类不能被实例化，**但抽象类中可以有抽象方法（使用 abstract 修饰的方法）和具体方法（没有使用 abstract 修饰的方法）**。继承该抽象类的所有子类都必须实现该抽象类中的所有抽象方法（除非子类也是抽象类）。
- `final`：如果类被 final 修饰，则不允许被继承。
- `class`：声明类的关键字。
- `class_name`：类的名称。
- `extends`：表示继承其他类。
- `implements`：表示实现某些接口。
- `property_type`：表示成员变量的类型。
- `property`：表示成员变量名称。
- `function()`：表示成员方法名称。


Java 类名的命名规则：

1. 类名应该以下划线（_）或字母开头，最好以字母开头。
2. 第一个字母最好大写，如果类名由多个单词组成，则每个单词的首字母最好都大写。
3. 类名不能为 Java 中的关键字，例如 boolean、this、int 等。
4. 类名不能包含任何嵌入的空格或点号以及除了下划线（_）和美元符号（$）字符之外的特殊字符。

创建一个新的类，就是创建一个新的数据类型。实例化一个类，就是得到类的一个对象。因此，对象就是一组变量和相关方法的集合，其中变量表明对象的状态和属性，方法表明对象所具有的行为。定义一个类的步骤如下所述。

(1) 声明类。编写类的最外层框架，声明一个名称为 Person 的类。

```java
public class Person {    
	// 类的主体
}
```

(2) 编写类的属性。类中的数据和方法统称为类成员。其中，类的属性就是类的数据成员。通过在类的主体中定义变量来描述类所具有的特征（属性），这里声明的变量称为类的成员变量。

(3) 编写类的方法。类的方法描述了类所具有的行为，是类的方法成员。可以简单地把方法理解为独立完成某个功能的单元模块。

下面来定义一个简单的 Person 类。

```java
public class Person {   
    private String name;    // 姓名   
    private int age;    // 年龄    
    public void tell() {          
    // 定义说话的方法        
    	System.out.println(name+"今年"+age+"岁！");   
    }
}
```

如上述代码，在 Person 类中首先定义了两个属性，分别为 name 和 age，然后定义了一个名称为 tell() 的方法。

### 2.5Java类的属性：成员变量的定义和声明

在 [Java](http://c.biancheng.net/java/) 中类的成员变量定义了类的属性。例如，一个学生类中一般需要有姓名、性别和年龄等属性，这时就需要定义姓名、性别和年龄 3 个属性。声明成员变量的语法如下：

```java
[public|protected|private][static][final]  <type>  <variable_name>
```

各参数的含义如下。

- public、protected、private：用于表示成员变量的访问权限。
- static：表示该成员变量为类变量，也称为静态变量。
- final：表示将该成员变量声明为常量，其值无法更改。
- type：表示变量的类型。
- variable_name：表示变量名称。


可以在声明成员变量的同时对其进行初始化，如果声明成员变量时没有对其初始化，则系统会使用默认值初始化成员变量。

初始化的默认值如下：

- 整数型（byte、short、int 和 long）的基本类型变量的默认值为 0。
- 单精度浮点型（float）的基本类型变量的默认值为 0.0f。
- 双精度浮点型（double）的基本类型变量的默认值为 0.0d。
- 字符型（char）的基本类型变量的默认值为 “\u0000”。
- 布尔型的基本类型变量的默认值为 false。
- 数组引用类型的变量的默认值为 null。如果创建了数组变量的实例，但没有显式地为每个元素赋值，则数组中的元素初始化值采用数组数据类型对应的默认值。


定义类的成员变量的示例如下：

```java
public class Student { 
    public String name;    // 姓名 
    final int sex = 0;    // 性别：0表示女孩，1表示男孩  
    private int age;    // 年龄
}
```

上述示例的 Student 类中定义了 3 个成员变量：String 类型的 name、int 类型的 sex 和 int 类型的 age。其中，name 的访问修饰符为 public，初始化值为 null；sex 的访问修饰符为 friendly（默认），初始化值为 0，表示性别为女，且其值无法更改；age 的访问修饰符为 private，初始化值为 0。

下面以一个简单的例子来介绍成员变量的初始值，代码如下所示。

```java
public class Counter {   
    static int sum;    
    public static void main(String[] args) {
    	System.out.println(sum);   
    }
}
```

在这里用静态的方法来修饰变量 sum，输出结果是 int 类型的初始值，即：0。

### 2.6Java成员方法的声明和调用

声明成员方法可以定义类的行为，行为表示一个对象能够做的事情或者能够从一个对象取得的信息。类的各种功能操作都是用方法来实现的，属性只不过提供了相应的数据。一个完整的方法通常包括方法名称、方法主体、方法参数和方法返回值类型，其结构如图 1 所示。



![img](/Users/jiusonghuang/pic-md/20210714092102.jpeg)
图 1 方法组成元素


成员方法一旦被定义，便可以在程序中多次调用，提高了编程效率。声明成员方法的语法格式如下：

```java
public class Test {    
 [public|private|protected][static] <void|return_type>  <method_name> ([paramList]) {       
   // 方法体    
	}
}
```

注意：上述语法中，中括号“[]”中的部分表示可以省略，竖线“|”表示“或”，例如 public|private，说明可以使用 public 或 private 关键字，但是两个关键字不能同时出现。

上述代码中一个方法包含 4 部分：方法的返回值、方法名称、方法的参数和方法体。其中 retum_type 是方法返回值的数据类型，数据类型可以是原始的数据类型，即常用的 8 种数据类型，也可以是一个引用数据类型，如一个类、接口和数组等。

除了这些，一个方法还可以没有返回值，即返回类型为 void，像 main() 方法。method_name 表示自定义的方法名称，方法的名称首先要遵循标识符的命名约定，除此之外，方法的名称第一个单词的第一个字母是小写，第二单词的第一个字母是大写，依此类推。

paramList 表示参数列表，这些变量都要有自己的数据类型，可以是原始数据类型，也可以是复杂数据类型，一个方法主要依靠参数来传递消息。方法主体是方法中执行功能操作的语句。其他各修饰符的含义如下。

- public、private、protected：表示成员方法的访问权限。
- static：表示限定该成员方法为静态方法。
- final：表示限定该成员方法不能被重写或重载。
- abstract：表示限定该成员方法为抽象方法。抽象方法不提供具体的实现，并且所属类型必须为抽象类。

注意：上面所提到的重写、重载和抽象类，由于篇幅有限，我们会在教程《[Java方法重载](http://c.biancheng.net/view/998.html)》《[Java方法重写](http://c.biancheng.net/view/1000.html)》和《[Java抽象类](http://c.biancheng.net/view/1004.html)》中讲解，这里大致了解就可以。

为上一节创建的学生类 Student 添加一个可以返回学生信息字符串的方法。代码如下：

```java
public class Student {    
public StringBuffer printInfo(Student st) {  
    StringBuffer sb = new StringBuffer();   
    sb.append("学生姓名："+st.Name+"\n 学生年龄："+st.Age+"\n 学生性别："+st.isSex());
    return sb;   
    }
}
```

上述代码创建了一个名称为 printInfo 的方法，其返回值类型为 StringBuffer（引用数据类型）。该方法需要传递一个 Student 类型的参数，最后需要将一个 StringBuffer 类型的数据返回。

#### 1. 成员方法的返回值

若方法有返回值，则在方法体中用 return 语句指明要返回的值，其格式如下所示。

```java
return 表达式
```

或者

```java
return (表达式)
```

其中，表达式可以是常量、变量、对象等。表达式的数据类型必须与声明成员方法时给出的返回值类型一致。

#### 2. 形参、实参及成员方法的调用

一般来说，可以通过以下方式来调用成员方法：

```java
methodName({paramList})
```

关于方法的参数，经常会提到形参与实参，形参是定义方法时参数列表中出现的参数，实参是调用方法时为方法传递的参数。

下面 retumMin() 方法中的 m 和 n 是形参，调用 retumMin() 方法时的 x 和 y 是实参。

```java
public int returnMin(int m,int n) {   
return Math.min(m,n);    // m和n是形参
}
public static void main(String[] args) {
    int x = 50;   
    int y = 100;   
    Test t = new Test();
    int i = t.returnMin(x,y); // x和y是实参  
    System.out.println(i);
}
```

方法的形参和实参具有以下特点：

- 形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在方法内部有效，方法调用结束返回主调方法后则不能再使用该形参变量。
- 实参可以是常量、变量、表达式、方法等，无论实参是何种类型的量，在进行方法调用时，它们都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值、输入等办法使实参获得确定值。
- 实参和形参在数量、类型和顺序上应严格一致，否则会发生“类型不匹配” 的错误。
- 方法调用中发生的数据传送是单向的，即只能把实参的值传送绐形参，而不能把形参的值反向地传送给实参。因此在方法调用过程中，形参的值发生改变，而实参中的值不会变化。

下面的示例演示了调用 add() 方法前后形参 x 的变化。

```java
public int add(int x) {    
    x += 30;    
    System.out.println("形参 x 的值："+x);   
    return x;
}
public static void main(String[] args) {   
    int x = 150;   
    System.out.println("调用 add() 方法之前 x 的值："+x);  
    Test t = new Test();  
    int i = t.add(x);  
    System.out.println("实参 x 的值："+x); 
    System.out.println("调用 add() 方法的返回值："+i);
}
```

运行上述程序，输出结果如下：

```
调用 add() 方法之前 x 的值：150
形参 x 的值：180
实参 x 的值：150
调用 add() 方法的返回值：180
```

从输出结果可以看出，形参 x 值的改变，并没有影响实参 x。

在调用成员方法时应注意以下 4 点：

1. 对无参成员方法来说，是没有实际参数列表的（即没有 paramList），但方法名后的括号不能省略。
2. 对带参数的成员方法来说，实参的个数、顺序以及它们的数据类型必须与形式参数的个数、顺序以及它们的数据类型保持一致，各个实参间用逗号分隔。实参名与形参名可以相同，也可以不同。
3. 实参也可以是表达式，此时一定要注意使表达式的数据类型与形参的数据类型相同，或者使表达式的类型按 [Java](http://c.biancheng.net/java/) 类型转换规则达到形参指明的数据类型。
4. 实参变量对形参变量的数据传递是“值传递”，即只能由实参传递给形参，而不能由形参传递给实参。程序中执行到调用成员方法时，Java 把实参值复制到一个临时的存储区（栈）中，形参的任何修改都在栈中进行，当退出该成员方法时，Java 自动清除栈中的内容。

#### 3. 方法体中的局部变量

在方法体内可以定义本方法所使用的变量，这种变量是局部变量。它的生存期与作用域是在本方法内，也就是说，局部变量只能在本方法内有效或可见，离开本方法则这些变量将被自动释放。

在方法体内定义变量时，变量前不能加修饰符。局部变量在使用前必须明确赋值，否则编译时会出错。另外，在一个方法内部，可以在复合语句（把多个语句用括号`{}`括起来组成的一个语句称复合语句）中定义变量，这些变量只在复合语句中有效。

### 2.7Java this关键字详解（3种用法）

**this 关键字是 [Java](http://c.biancheng.net/java/) 常用的关键字，可用于任何实例方法内指向当前对象，也可指向对其调用当前方法的对象，或者在需要当前类型对象引用时使用。**

下面我们根据示例分别讲解 this 关键字的作用。

#### this.属性名

大部分时候，普通方法访问其他方法、成员变量时无须使用 this 前缀，但如果方法里有个局部变量和成员变量同名，但程序又需要在该方法里访问这个被覆盖的成员变量，则必须使用 this 前缀。

假设有一个教师类 Teacher 的定义如下：

```java
public class Teacher {    
    private String name;   // 教师名称  
    private double salary;   // 工资 
    private int age;    // 年龄
}
```

在上述代码中 name、salary 和 age 的作用域是 private，因此在类外部无法对它们的值进行设置。为了解决这个问题，可以为 Teacher 类添加一个构造方法，然后在构造方法中传递参数进行修改。代码如下：

```java
// 创建构造方法，为上面的3个属性赋初始值
public Teacher(String name,double salary,int age) { 
    this.name = name;    // 设置教师名称   
    this.salary = salary;    // 设置教师工资  
    this.age = age;    // 设置教师年龄
}
```

在 Teacher 类的构造方法中使用了 this 关键字对属性 name、salary 和 age 赋值，this 表示当前对象。`this.name=name`语句表示一个赋值语句，等号左边的 this.name 是指当前对象具有的变量 name，等号右边的 name 表示参数传递过来的数值。

创建一个 main() 方法对 Teacher 类进行测试，代码如下：

```java
public static void main(String[] args) {    
    Teacher teacher = new Teacher("王刚",5000.0,45); 
    System.out.println("教师信息如下：");  
    System.out.println("教师名称："+teacher.name+"\n教师工资："+teacher.salary+"\n教师年龄："+teacher.age);
}
```

运行该程序，输出的结果如下所示。

```
教师信息如下：
教师名称：王刚
教师工资：5000.0
教师年龄：45
```

提示：当一个类的属性（成员变量）名与访问该属性的方法参数名相同时，则需要使用 this 关键字来访问类中的属性，以区分类的属性和方法中的参数。

#### this.方法名

**this 关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或实例变量。**

假设定义了一个 Dog 类，这个 Dog 对象的 run( ) 方法需要调用它的 jump( ) 方法，Dog 类的代码如下所示：

```java
/**
* 第一种定义Dog类方法 
**/
public class Dog {    
    // 定义一个jump()方法   
    public void jump() {  
        System.out.println("正在执行jump方法"); 
    }   
    // 定义一个run()方法，run()方法需要借助jump()方法    
    public void run() {       
        Dog d = new Dog();      
        d.jump();     
        System.out.println("正在执行 run 方法");  
    }
}
```

使用这种方式来定义这个 Dog 类，确实可以实现在 run( ) 方法中调用 jump( ) 方法。下面再提供一个程序来创建 Dog 对象，并调用该对象的 run( ) 方法。

```java
public class DogTest {   
    public static void main(String[] args) { 
        // 创建Dog对象       
        Dog dog = new Dog();     
        // 调用Dog对象的run()方法     
        dog.run(); 
    }
}
```

在上面的程序中，一共产生了两个 Dog 对象，在 Dog 类的 run( ) 方法中，程序创建了一个 Dog 对象，并使用名为 d 的引用变量来指向该 Dog 对象。在 DogTest 的 main() 方法中，程序再次创建了一个 Dog 对象，并使用名为 dog 的引用变量来指向该 Dog 对象。

下面我们思考两个问题。

1）在 run( ) 方法中调用 jump( ) 方法时是否一定需要一个 Dog 对象？

答案是肯定的，因为没有使用 static 修饰的成员变量和方法都必须使用对象来调用。

2）是否一定需要重新创建一个 Dog 对象？

不一定，因为当程序调用 run( ) 方法时，一定会提供一个 Dog 对象，这样就可以直接使用这个已经存在的 Dog 对象，而无须重新创建新的 Dog 对象了。因此需要在 run() 方法中获得调用该方法的对象，通过 this 关键字就可以满足这个要求。

**this 可以代表任何对象，当 this 出现在某个方法体中时，它所代表的对象是不确定的，但它的类型是确定的，它所代表的只能是当前类的实例。只有当这个方法被调用时，它所代表的对象才被确定下来，谁在调用这个方法，this 就代表谁。**

将前面的 Dog 类的 run( ) 方法改为如下形式会更加合适，run( ) 方法代码修改如下，其它代码不变。

```java
/** 
* 第二种定义Dog类方法 
**/
// 定义一个run()方法，run()方法需要借助jump()方法
public void run() { 
    // 使用this引用调用run()方法的对象  
    this.jump();   
    System.out.println("正在执行run方法");
}
```

从第一种 Dog 类定义来看，在 Dog 对象的 run( ) 方法内重新创建了一个新的 Dog 对象，并调用它的 jump( ) 方法，这意味着一个 Dog 对象的 run( ) 方法需要依赖于另一个 Dog 对象的 jump( ) 方法，这不符合逻辑。

第二种 Dog 类定义是当一个 Dog 对象调用 run( ) 方法时，run( ) 方法需要依赖它自己的 jump( ) 方法，与第一种定义类的方法相比，更符合实际情形。

在现实世界里，对象的一个方法依赖于另一个方法的情形很常见，例如，吃饭方法依赖于拿筷子方法，写程序方法依赖于敲键盘方法。这种依赖都是同一个对象两个方法之间的依赖。因此，Java 允许对象的一个成员直接调用另一个成员，可以省略 this 前缀。也就是说，将上面的 run( ) 方法改为如下形式也完全正确。

```java
public void run() {    
    jump();    
    System.out.println("正在执行run方法");
}
```

大部分时候，一个方法访问该类中定义的其他方法、成员变量时加不加 this 前缀的效果是完全一样的。

注意：对于 static 修饰的方法而言，可以使用类来直接调用该方法，如果在 static 修饰的方法中使用 this 关键字，则这个关键字就无法指向合适的对象。所以，static 修饰的方法中不能使用 this 引用。并且 Java 语法规定，静态成员不能直接访问非静态成员。

省略 this 前缀只是一种假象，虽然程序员省略了调用 jump() 方法之前的 this，但实际上这个 this 依然是存在的。

#### this( )访问构造方法

this( ) 用来访问本类的构造方法（构造方法是类的一种特殊方法，方法名称和类名相同，没有返回值。详细了解可参考《[Java构造方法](http://c.biancheng.net/view/976.html)》一节），括号中可以有参数，如果有参数就是调用指定的有参构造方法。

下面定义一个 Student 类，使用 this( ) 调用构造方法给 name 赋值，Student 类的代码如下所示：

```java
public class Student {   
    String name;    
    // 无参构造方法（没有参数的构造方法）   
    public Student() {        
   		 this("张三");    
    }   
    // 有参构造方法   
    public Student(String name) { 
  	 	 this.name = name;    
    }   
    // 输出name和age    
    public void print() {  
   	 	System.out.println("姓名：" + name);    
    }    
    public static void main(String[] args) { 
        Student stu = new Student();     
        stu.print();  
    }
}
```

输出结果为：

姓名：张三

注意：

- **this( ) 不能在普通方法中使用，只能写在构造方法中。**
- **在构造方法中使用时，必须是第一条语句。**

### 2.8Java访问控制修饰符详解（public、 private、protected 和 friendly）

在 [Java](http://c.biancheng.net/java/) 语言中提供了多个作用域修饰符，其中常用的有 public、private、protected、final、abstract、static、transient 和 volatile，这些修饰符有类修饰符、变量修饰符和方法修饰符。本文将详细介绍访问控制修饰符。

在实际生活中，如果要获取某件物品，与其直接穿过堡垒的墙壁，从而导致墙壁毁灭和破坏，不如通过门口的警卫请求进入堡垒的许可。一般而言，这对对象同样适用：没有对象的许可（即对象的属性是私有的），不能直接访问该对象的私有属性。

信息隐藏是 OOP 最重要的功能之一，也是使用访问修饰符的原因。在编写程序时，有些核心数据往往不希望被用户调用，需要控制这些数据的访问。

对类成员访问的限制是面向对象程序设计的一个基础，这有利于防止对象的误用。只允许通过一系列定义完善的方法来访问私有数据，就可以（通过执行范围检查）防止数据赋予不正当的值。例如，类以外的代码不可能直接向一个私有成员赋值。同时，还可以精确地控制如何以及何时使用对象中的数据。

当正确实现对类成员的方法控制后，类就可以创建一个可用的“黑箱”，其内部动作不会被打开而任意篡改。

通过使用访问控制修饰符来限制对对象私有属性的访问，可以获得 3 个重要的好处。

- 防止对封装数据的未授权访问。
- 有助于保证数据完整性。
- 当类的私有实现细节必须改变时，可以限制发生在整个应用程序中的“连锁反应”。


访问控制符是一组限定类、属性或方法是否可以被程序里的其他部分访问和调用的修饰符。类的访问控制符只能是空或者 public，方法和属性的访问控制符有 4 个，分别是 public、 private、protected 和 friendly，其中 friendly 是一种没有定义专门的访问控制符的默认情况。访问控制修饰符的权限如表 1 所示。

| 访问范围         | private  | friendly(默认) | protected | public |
| ---------------- | -------- | -------------- | --------- | ------ |
| 同一个类         | 可访问   | 可访问         | 可访问    | 可访问 |
| 同一包中的其他类 | 不可访问 | 可访问         | 可访问    | 可访问 |
| 不同包中的子类   | 不可访问 | 不可访问       | 可访问    | 可访问 |
| 不同包中的非子类 | 不可访问 | 不可访问       | 不可访问  | 可访问 |


访问控制在面向对象技术中处于很重要的地位，合理地使用访问控制符，可以通过降低类和类之间的耦合性（关联性）来降低整个项目的复杂度，也便于整个项目的开发和维护。在 Java 语言中，访问控制修饰符有 4 种。

#### 1. private

用 private 修饰的类成员，只能被该类自身的方法访问和修改，而不能被任何其他类（包括该类的子类）访问和引用。因此，private 修饰符具有最高的保护级别。例如，设 PhoneCard 是电话卡类，电话卡都有密码，因此该类有一个密码域，可以把该类的密码域声明为私有成员。

#### 2. friendly（默认）

如果一个类没有访问控制符，说明它具有默认的访问控制特性。这种默认的访问控制权规定，该类只能被同一个包中的类访问和引用，而不能被其他包中的类使用，即使其他包中有该类的子类。这种访问特性又称为包访问性（package private）。

同样，类内的成员如果没有访问控制符，也说明它们具有包访问性，或称为友元（friend）。定义在同一个文件夹中的所有类属于一个包，所以前面的程序要把用户自定义的类放在同一个文件夹中（Java 项目默认的包），以便不加修饰符也能运行。

#### 3. protected

用保护访问控制符 protected 修饰的类成员可以被三种类所访问：该类自身、与它在同一个包中的其他类以及在其他包中的该类的子类。使用 protected 修饰符的主要作用，是允许其他包中它的子类来访问父类的特定属性和方法，否则可以使用默认访问控制符。

#### 4. public

当一个类被声明为 public 时，它就具有了被其他包中的类访问的可能性，只要包中的其他类在程序中使用 import 语句引入 public 类，就可以访问和引用这个类。

类中被设定为 public 的方法是这个类对外的接口部分，避免了程序的其他部分直接去操作类内的数据，实际就是数据封装思想的体现。每个 Java 程序的主类都必须是 public 类，也是基于相同的原因。

下面来创建一个示例，演示 Java 中访问控制修饰符的使用。

(1) 新建 Student.java 文件，在该文件中定义不同修饰符的属性和方法，代码如下：

```java
class Student {    
    // 姓名，其访问权限为默认(friendly)  
    String name;    
    // 定义私有变量，身份证号码    
    private String idNumber;   
    // 定义受保护变量，学号 
    protected String no;    
    // 定义共有变量，邮箱    
    public String email;    
    // 定义共有方法，显示学生信息   
    public String info() {    
    	return"姓名："+name+"，身份证号码："+idNumber+"，学号："+no+"，邮箱："+email; 
    }
}
```

(2) 新建 StudentTest.java 文件，在该文件中定义 main() 方法，访问 Student 类中的属性并赋值，打印出用户的信息。代码如下：

```java
public class StudentTest { 
    public static void main(String[] args) {    
        // 创建Student类对象        
        Student stu = new Student();    
        // 向Student类对象中的属性赋值        
        stu.name = "zhht";        
        // stu.idNumber="043765290763137806";  
        // 这是不允许的。提示stu.idNumber是不可见的，必须注释掉才可运行 
        stu.no = "20lil01637";     
        stu.email = "zhht@qq.com";     
        System.out.println(stu.info());  
    }
}
```

在 StudentTest 类中，“stu.idNumber="043765290763137806";”代码行将提示 “The field User.password is not visible”错误信息。将该代码行注释掉再运行 StudentTest.java 文件，输出的内容如下：

```
姓名：zhht，身份证号码：null，学号：20lil01637，邮箱：zhht@qq.com
在源文件中创建了两个类，分别为主类 StudentTest 和辅助类 Student，二者在同一个包中。
```

在辅助类 Student 中，创建了 4 个属性，其访问控制分别为默认的、私有的、受保护的和共有的，除了私有控制符修饰的变量之外，其他的都可以被主类访问，同时创建了一个共有的方法——info()，用于打印用户信息。

在主类 StudentTest 中，创建类 Student 的实例化对象 stu，通过对象 stu 来访问该对象中的属性并赋值，因为 idNumber 属性的修饰符为 private（私有的），因此，在 StudentTest 类中的 main() 方法中无法访问该属性。

从上面的例子中可以看出，范围控制修饰符成功地限制了访问者访问不同修饰符的属性（成员变量），从而实现了数据的隐藏。

### 2.9Java static关键字（静态变量和静态方法）

在类中，使用 static 修饰符修饰的属性（成员变量）称为静态变量，也可以称为类变量，常量称为静态常量，方法称为静态方法或类方法，它们统称为静态成员，归整个类所有。

静态成员不依赖于类的特定实例，被类的所有实例共享，就是说 static 修饰的方法或者变量不需要依赖于对象来进行访问，只要这个类被加载，[Java](http://c.biancheng.net/java/) 虚拟机就可以根据类名找到它们。

调用静态成员的语法形式如下：

```
类名.静态成员
```

注意：

- static 修饰的成员变量和方法，从属于类。
- 普通变量和方法从属于对象。
- 静态方法不能调用非静态成员，编译会报错。

#### 静态变量

类的成员变量可以分为以下两种：

1. 静态变量（或称为类变量），指被 static 修饰的成员变量。
2. 实例变量，指没有被 static 修饰的成员变量。


静态变量与实例变量的区别如下：

1）静态变量

- 运行时，Java 虚拟机只为静态变量分配一次内存，在加载类的过程中完成静态变量的内存分配。
- 在类的内部，可以在任何方法内直接访问静态变量。
- 在其他类中，可以通过类名访问该类中的静态变量。


2）实例变量

- 每创建一个实例，Java 虚拟机就会为实例变量分配一次内存。
- 在类的内部，可以在非静态方法中直接访问实例变量。
- 在本类的静态方法或其他类中则需要通过类的实例对象进行访问。


静态变量在类中的作用如下：

- 静态变量可以被类的所有实例共享，因此静态变量可以作为实例之间的共享数据，增加实例之间的交互性。
- 如果类的所有实例都包含一个相同的常量属性，则可以把这个属性定义为静态常量类型，从而节省内存空间。例如，在类中定义一个静态常量 PI。

```java
public static double PI = 3.14159256;
```

创建一个带静态变量的类，然后在 main() 方法中访问该变量并输出结果。

```java
public class StaticVar {    
    public static String str1 = "Hello";   
    public static void main(String[] args) {  
        String str2 = "World!";        
        // 直接访问str1        
        String accessVar1 = str1+str2;   
        System.out.println("第 1 次访问静态变量，结果为："+accessVar1);   
        // 通过类名访问str1      
        String accessVar2 = StaticVar.str1+str2;     
        System.out.println("第 2 次访问静态变量，结果为："+accessVar2);   
        // 通过对象svt1访问str1        
        StaticVar svt1 = new StaticVar();    
        svt1.str1 = svt1.str1+str2;    
        String accessVar3 = svt1.str1;    
        System.out.println("第3次访向静态变量，结果为："+accessVar3);   
        // 通过对象svt2访问str1       
        StaticVar svt2 = new StaticVar();        
        String accessVar4 = svt2.str1+str2;  
        System.out.println("第 4 次访问静态变量，结果为："+accessVar4);   
    }
}
```

运行该程序后的结果如下所示。

```
第 1 次访问静态变量，结果为：HelloWorld!
第 2 次访问静态变量，结果为：HelloWorld!
第 3 次访向静态变量，结果为：HelloWorld!
第 4 次访问静态变量，结果为：HelloWorld!World!
```

从运行结果可以看出，在类中定义静态的属性（成员变量），在 main() 方法中可以直接访问，也可以通过类名访问，还可以通过类的实例对象来访问。

注意：静态变量是被多个实例所共享的。

#### 静态方法

与成员变量类似，成员方法也可以分为以下两种：

1. 静态方法（或称为类方法），指被 static 修饰的成员方法。
2. 实例方法，指没有被 static 修饰的成员方法。


静态方法与实例方法的区别如下：

- **静态方法不需要通过它所属的类的任何实例就可以被调用，因此在静态方法中不能使用 this 关键字，也不能直接访问所属类的实例变量和实例方法，但是可以直接访问所属类的静态变量和静态方法。另外，和 this 关键字一样，super 关键字也与类的特定实例相关，所以在静态方法中也不能使用 super 关键字。**
- **在实例方法中可以直接访问所属类的静态变量、静态方法、实例变量和实例方法。**

创建一个带静态变量的类，添加几个静态方法对静态变量的值进行修改，然后在 main( ) 方法中调用静态方法并输出结果。

```java
public class StaticMethod {   
    public static int count = 1;   
    // 定义静态变量count    
    public int method1() {    
        // 实例方法method1      
        count++;    
        // 访问静态变量count并赋值  
        System.out.println("在静态方法 method1()中的 count="+count);  
        // 打印count    
        return count;  
    }    
    public static int method2() {   
        // 静态方法method2    
        count += count; 
        // 访问静态变量count并赋值 
        System.out.println("在静态方法 method2()中的 count="+count); 
        // 打印count       
        return count;   
    }   
    public static void PrintCount() {  
        // 静态方法PrintCount     
        count += 2;        
        System.out.println("在静态方法 PrintCount()中的 count="+count); 
        // 打印count  
    }    
    public static void main(String[] args) {    
        StaticMethod sft = new StaticMethod();  
        // 通过实例对象调用实例方法      
        System.out.println("method1() 方法返回值 intro1="+sft.method1());    
        // 直接调用静态方法       
        System.out.println("method2() 方法返回值 intro1="+method2());  
        // 通过类名调用静态方法，打印 count  
        StaticMethod.PrintCount();  
    }
}
```

运行该程序后的结果如下所示。

```
在静态方法 method1()中的 count=2
method1() 方法返回值 intro1=2
在静态方法 method2()中的 count=4
method2() 方法返回值 intro1=4
在静态方法 PrintCount()中的 count=6
```

在该程序中，静态变量 count 作为实例之间的共享数据，因此在不同的方法中调用 count，值是不一样的。从该程序中可以看出，在静态方法 method2() 和 PrintCount() 中是不可以调用非静态方法 method1() 的，而在 method1() 方法中可以调用静态方法 method2() 和 PrintCount()。

在访问非静态方法时，需要通过实例对象来访问，而在访问静态方法时，可以直接访问，也可以通过类名来访问，还可以通过实例化对象来访问。

#### 静态代码块

静态代码块指 Java 类中的 static{ } 代码块，主要用于初始化类，为类的静态变量赋初始值，提升程序性能。

静态代码块的特点如下：

- 静态代码块类似于一个方法，但它不可以存在于任何方法体中。
- 静态代码块可以置于类中的任何地方，类中可以有多个静态初始化块。 
- Java 虚拟机在加载类时执行静态代码块，所以很多时候会将一些只需要进行一次的初始化操作都放在 static 代码块中进行。
- 如果类中包含多个静态代码块，则 Java 虚拟机将按它们在类中出现的顺序依次执行它们，每个静态代码块只会被执行一次。
- 静态代码块与静态方法一样，不能直接访问类的实例变量和实例方法，而需要通过类的实例对象来访问。

编写一个 Java 类，在类中定义一个静态变量，然后使用静态代码块修改静态变量的值。最后在 main() 方法中进行测试和输出。

```java
public class StaticCode {    
    public static int count = 0;  
    {      
        count++;  
        System.out.println("非静态代码块 count=" + count); 
    }   
    static {   
        count++;     
        System.out.println("静态代码块1 count=" + count); 
    }  
    static {  
        count++;     
        System.out.println("静态代码块2 count=" + count);  
    }  
public static void main(String[] args) {   
        System.out.println("*************** StaticCode1 执行 ***************");     
        StaticCode sct1 = new StaticCode();      
        System.out.println("*************** StaticCode2 执行 ***************");   
        StaticCode sct2 = new StaticCode();   
    }
}
```

如上述示例，为了说明静态代码块只被执行一次，特地添加了非静态代码块作为对比，并在主方法中创建了两个类的实例对象。上述示例的执行结果为：

```
静态代码块1 count=1
静态代码块2 count=2
*************** StaticCode1 执行 ***************
非静态代码块 count=3
*************** StaticCode2 执行 ***************
非静态代码块 count=4
```

上述代码中 { } 代码块为非静态代码块，非静态代码块是在创建对象时自动执行的代码，不创建对象不执行该类的非静态代码块。代码域中定义的变量都是局部的，只有域中的代码可以调用。 

### 2.10Java final修饰符详解

final 在 [Java](http://c.biancheng.net/java/) 中的意思是最终，也可以称为完结器，表示对象是最终形态的，不可改变的意思。final 应用于类、方法和变量时意义是不同的，但本质是一样的，都表示不可改变，类似 [C#](http://c.biancheng.net/csharp/) 里的 sealed 关键字。

使用 final 关键字声明类、变量和方法需要注意以下几点：

- final 用在变量的前面表示变量的值不可以改变，此时该变量可以被称为常量。
- final 用在方法的前面表示方法不可以被重写（子类中如果创建了一个与父类中相同名称、相同返回值类型、相同参数列表的方法，只是方法体中的实现不同，以实现不同于父类的功能，这种方式被称为方法重写，又称为方法覆盖。这里了解即可，教程后面我们会详细讲解）。
- final 用在类的前面表示该类不能有子类，即该类不可以被继承。

#### final 修饰变量

final 修饰的变量即成为常量，只能赋值一次，但是 final 所修饰局部变量和成员变量有所不同。

1. final 修饰的局部变量必须使用之前被赋值一次才能使用。
2. final 修饰的成员变量在声明时没有赋值的叫“空白 final 变量”。空白 final 变量必须在构造方法或静态代码块中初始化。

注意：final 修饰的变量不能被赋值这种说法是错误的，严格的说法是，final 修饰的变量不可被改变，一旦获得了初始值，该 final 变量的值就不能被重新赋值。

```java
public class FinalDemo {
    void doSomething() {
        // 没有在声明的同时赋值
        final int e;
        // 只能赋值一次
        e = 100;
        System.out.print(e);
        // 声明的同时赋值
        final int f = 200;
    }
    // 实例常量
    final int a = 5; // 直接赋值
    final int b; // 空白final变量
    // 静态常量
    final static int c = 12;// 直接赋值
    final static int d; // 空白final变量
    // 静态代码块
    static {
        // 初始化静态变量
        d = 32;
    }
    // 构造方法
    FinalDemo() {
        // 初始化实例变量
        b = 3;
        // 第二次赋值，会发生编译错误
        // b = 4;
    }
}
```

上述代码第 4 行和第 6 行是声明局部常量，其中第 4 行只是声明没有赋值，但必须在使用之前赋值（见代码第 6 行），其实局部常量最好在声明的同时初始化。代码第 13、14、16 和 17 行都声明成员常量。代码第 13 和 14 行是实例常量，如果是空白 final 变量（见代码第 14 行），则需要在构造方法中初始化（见代码第 27 行）。代码第 16 和 17 行是静态常量，如果是空白 final 变量（见代码第 17 行），则需要在静态代码块中初始化（见代码第 21 行）。

另外，无论是那种常量只能赋值一次，见代码第 29 行为 b 常量赋值，因为之前 b 已经赋值过一次，因此这里会发生编译错误。

##### final 修饰基本类型变量和引用类型变量的区别

**当使用 final 修饰基本类型变量时，不能对基本类型变量重新赋值，因此基本类型变量不能被改变。 但对于引用类型变量而言，它保存的仅仅是一个引用，final 只保证这个引用类型变量所引用的地址不会改变，即一直引用同一个对象，但这个对象完全可以发生改变。**

下面程序示范了 final 修饰数组和 Person 对象的情形。

```java
import java.util.Arrays;
class Person {
    private int age;
    public Person() {
    }
    // 有参数的构造器
    public Person(int age) {
        this.age = age;
    }
    // 省略age的setter和getter方法
    // age 的 setter 和 getter 方法
}
public class FinalReferenceTest {
    public static void main(String[] args) {
        // final修饰数组变量，iArr是一个引用变量
        final int[] iArr = { 5, 6, 12, 9 };
        System.out.println(Arrays.toString(iArr));
        // 对数组元素进行排序，合法
        Arrays.sort(iArr);
        System.out.println(Arrays.toString(iArr));
        // 对数组元素赋值，合法
        iArr[2] = -8;
        System.out.println(Arrays.toString(iArr));
        // 下面语句对iArr重新赋值,非法
        // iArr = null;
        // final修饰Person变量，p是一个引用变量
        final Person p = new Person(45);
        // 改变Person对象的age实例变量，合法
        p.setAge(23);
        System.out.println(p.getAge());
        // 下面语句对P重新赋值，非法
        // p = null;
    }
}
```

从上面程序中可以看出，使用 final 修饰的引用类型变量不能被重新赋值，但可以改变引用类型变量所引用对象的内容。例如上面 iArr 变量所引用的数组对象，final 修饰后的 iArr 变量不能被重新赋值，但 iArr 所引用数组的数组元素可以被改变。与此类似的是，p 变量也使用了 final 修饰，表明 p 变量不能被重新赋值，但 p 变量所引用 Person 对象的成员变量的值可以被改变。

注意**：在使用 final 声明变量时，要求全部的字母大写，如 SEX，这点在开发中是非常重要的。**

如果一个程序中的变量使用 public static final 声明，则此变量将称为全局变量，如下面的代码：

```java
public static final String SEX= "女";
```

#### final修饰方法

final 修饰的方法不可被重写，如果出于某些原因，不希望子类重写父类的某个方法，则可以使用 final 修饰该方法。

Java 提供的 Object 类里就有一个 final 方法 getClass()，因为 Java 不希望任何类重写这个方法，所以使用 final 把这个方法密封起来。但对于该类提供的 toString() 和 equals() 方法，都允许子类重写，因此没有使用 final 修饰它们。

下面程序试图重写 final 方法，将会引发编译错误。

```java
public class FinalMethodTest {
    public final void test() {
    
    }
}
class Sub extends FinalMethodTest {
    // 下面方法定义将出现编译错误，不能重写final方法
    public void test() {
    
    }
}
```

上面程序中父类是 FinalMethodTest，该类里定义的 test() 方法是一个 final 方法，如果其子类试图重写该方法，将会引发编译错误。

对于一个 private 方法，因为它仅在当前类中可见，其子类无法访问该方法，所以子类无法重写该方法——如果子类中定义一个与父类 private 方法有相同方法名、相同形参列表、相同返回值类型的方法，也不是方法重写，只是重新定义了一个新方法。因此，即使使用 final 修饰一个 private 访问权限的方法，依然可以在其子类中定义与该方法具有相同方法名、相同形参列表、相同返回值类型的方法。

下面程序示范了如何在子类中“重写”父类的 private final 方法。

```java
public class PrivateFinalMethodTest {
    private final void test() {
    
    }
}
class Sub extends PrivateFinalMethodTest {
    // 下面的方法定义不会出现问题
    public void test() {
    }
}
```

上面程序没有任何问题，虽然子类和父类同样包含了同名的 void test() 方法，但子类并不是重写父类的方法，**因此即使父类的 void test() 方法使用了 final 修饰，子类中依然可以定义 void test() 方法。**

**final 修饰的方法仅仅是不能被重写，并不是不能被重载，因此下面程序完全没有问题。**

```java
public class FinalOverload {
    // final 修饰的方法只是不能被重写，完全可以被重载
    public final void test(){}
    public final void test(String arg){}
}
```

#### final修饰类

final 修饰的类不能被继承。当子类继承父类时，将可以访问到父类内部数据，并可通过重写父类方法来改变父类方法的实现细节，这可能导致一些不安全的因素。为了保证某个类不可被继承，则可以使用 final 修饰这个类。

下面代码示范了 final 修饰的类不可被继承。

```java
final class SuperClass {

}
class SubClass extends SuperClass {    //编译错误

}
```

因为 SuperClass 类是一个 final 类，而 SubClass 试图继承 SuperClass 类，这将会引起编译错误。

#### final 修饰符使用总结

##### 1. final 修饰类中的变量

表示该变量一旦被初始化便不可改变，这里不可改变的意思对基本类型变量来说是其值不可变，而对对象引用类型变量来说其引用不可再变。其初始化可以在两个地方：一是其定义处，也就是说在 final 变量定义时直接给其赋值；二是在构造方法中。这两个地方只能选其一，要么在定义时给值，要么在构造方法中给值，不能同时既在定义时赋值，又在构造方法中赋予另外的值。

##### 2. final 修饰类中的方法

说明这种方法提供的功能已经满足当前要求，不需要进行扩展，并且也不允许任何从此类继承的类来重写这种方法，但是继承仍然可以继承这个方法，也就是说可以直接使用。在声明类中，一个 final 方法只被实现一次。

##### 3. final 修饰类

表示该类是无法被任何其他类继承的，意味着此类在一个继承树中是一个叶子类，并且此类的设计已被认为很完美而不需要进行修改或扩展。

对于 final 类中的成员，可以定义其为 final，也可以不是 final。而对于方法，由于所属类为 final 的关系，自然也就成了 final 型。也可以明确地给 final 类中的方法加上一个 final，这显然没有意义。

### 2.11Java构造方法

构造方法是类的一种特殊方法，用来初始化类的一个新的对象，在创建对象（new 运算符）之后自动调用。[Java](http://c.biancheng.net/java/) 中的每个类都有一个默认的构造方法，并且可以有一个以上的构造方法。

Java 构造方法有以下特点：

- 方法名必须与类名相同
- 可以有 0 个、1 个或多个参数
- 没有任何返回值，包括 void
- 默认返回类型就是对象类型本身
- 只能与 new 运算符结合使用


**值得注意的是，如果为构造方法定义了返回值类型或使用 void 声明构造方法没有返回值，编译时不会出错，但 Java 会把这个所谓的构造方法当成普通方法来处理。**

这时候大家可能会产生疑问，构造方法不是没有返回值吗？为什么不能用 void 声明呢？

简单的说，这是 Java 的语法规定。实际上，类的构造方法是有返回值的，当使用 new 关键字来调用构造方法时，构造方法返回该类的实例，可以把这个类的实例当成构造器的返回值，因此构造器的返回值类型总是当前类，无须定义返回值类型。但必须注意不要在构造方法里使用 return 来返回当前类的对象，因为构造方法的返回值是隐式的。

注意：**构造方法不能被 static、final、synchronized、abstract 和 native（类似于 abstract）修饰。**构造方法用于初始化一个新对象，所以用 static 修饰没有意义。构造方法不能被子类继承，所以用 final 和 abstract 修饰没有意义。多个线程不会同时创建内存地址相同的同一个对象，所以用 synchronized 修饰没有必要。如果不了解除 static、final 之外其他的关键字，教程后面会详细讲解。

构造方法的语法格式如下：

```java
class class_name {
    public class_name(){}    // 默认无参构造方法
    public ciass_name([paramList]){}    // 定义构造方法
    …
    // 类主体
}
```

在一个类中，与类名相同的方法就是构造方法。每个类可以具有多个构造方法，但要求它们各自包含不同的方法参数。

构造方法主要有无参构造方法和有参构造方法两种，示例如下：

```java
public class MyClass {
    private int m;    // 定义私有变量
    MyClass() {
        // 定义无参的构造方法
        m = 0;
    }
    MyClass(int m) {
        // 定义有参的构造方法
        this.m = m;
    }
}
```

该示例定义了两个构造方法，分别是无参构造方法和有参构造方法。在一个类中定义多个具有不同参数的同名方法，这就是方法的重载。这两个构造方法的名称都与类名相同，均为 MyClass。在实例化该类时可以调用不同的构造方法进行初始化。

注意：类的构造方法不是要求必须定义的。如果在类中没有定义任何一个构造方法，则 Java 会自动为该类生成一个默认的构造方法。默认的构造方法不包含任何参数，并且方法体为空。如果类中显式地定义了一个或多个构造方法，则 Java 不再提供默认构造方法。

提示：无参数的构造方法也被称为 Nullary 构造方法。只有编译程序自动加入的构造方法，才称为默认构造函数。如果自行编写无参数、没有内容的构造函数，就不称为默认构造函数了（只是 Nullary 构造函数）。虽然只是名词定义，不过认证考试时要区别一下两者的不同。

要在不同的条件下使用不同的初始化行为创建类的对象，这时候就需要在一个类中创建多个构造方法。下面通过一个示例来演示构造方法的使用。

1）首先在员工类 Worker 中定义两个构造方法，代码如下：

```java
public class Worker {
    public String name;    // 姓名
    private int age;    // 年龄
    // 定义带有一个参数的构造方法
    public Worker(String name) {
        this.name = name;
    }
    // 定义带有两个参数的构造方法
    public Worker(String name,int age) {
        this.name = name;
        this.age = age;
    }
    public String toString() {
        return "大家好！我是新来的员工，我叫"+name+"，今年"+age+"岁。";
    }
}
```

在 Worker 类中定义了两个属性，其中 name 属性不可改变。分别定义了带有一个参数和带有两个参数的构造方法，并对其属性进行初始化。最后定义了该类的 toString() 方法，返回一条新进员工的介绍语句。

提示：Object 类具有一个 toString() 方法，该方法是个特殊的方法，创建的每个类都会继承该方法，它返回一个 String 类型的字符串。如果一个类中定义了该方法，则在调用该类对象时，将会自动调用该类对象的 toString() 方法返回一个字符串，然后使用“System.out.println(对象名)”就可以将返回的字符串内容打印出来。

2）在 TestWorker 类中创建 main() 方法作为程序的入口处，在 main() 方法中调用不同的构造方法实例化 Worker 对象，并对该对象中的属性进行初始化，代码如下：

```java
public class TestWorker {
    public static void main(String[] args) {
        System.out.println("-----------带有一个参数的构造方法-----------");
        // 调用带有一个参数的构造方法
        Worker worker1 = new Worker("张强");
        System.out.println(worker1);
        System.out.println("-----------带有两个参数的构造方法------------");
        // 调用带有两个参数的构造方法
        Worker worker2 = new Worker("李丽",25);
        System.out.println(worker2);
    }
}
```

在上述代码中，创建了两个不同的 Worker 对象：一个是姓名为张强的员工对象，一个是姓名为李丽、年龄为 25 的员工对象。对于第一个 Worker 对象 Worker1，并未指定 age 属性值，因此程序会将其值采用默认值 0。对于第二个 Worker 对象 Worker2，分别对其指定了 name 属性值和 age 属性值，因此程序会将传递的参数值重新赋值给 Worker 类中的属性值。

注意：Java 构造器的工作方式与 [C++](http://c.biancheng.net/cplus/) 一样。但是，要记住所有的 Java 对象都是在堆中构造的，构造器总是伴随着 new 操作符一起使用。C++ 程序员最易犯的错误就是忘记 new 操作符，例如以下语句：

```java
Worker worker("张三",12);
```

这条语句在 C++ 中能够正常运行，但在 Java 中却不行。

运行 TestWorker 类，输出的结果如下：

```
-----------带有一个参数的构造方法-----------
大家好！我是新来的员工，我叫张强，今年0岁。
-----------带有两个参数的构造方法------------
大家好！我是新来的员工，我叫李丽，今年25岁。
```

## 3、Java继承和多态

### 3.1Java类的封装

封装将类的某些信息隐藏在类内部，不允许外部程序直接访问，只能通过该类提供的方法来实现对隐藏信息的操作和访问。例如：一台计算机内部极其复杂，有主板、CPU、硬盘和内存， 而一般用户不需要了解它的内部细节，不需要知道主板的型号、CPU 主频、硬盘和内存的大小，于是计算机制造商将用机箱把计算机封装起来，对外提供了一些接口，如鼠标、键盘和显示器等，这样当用户使用计算机就非常方便。

封装的特点：

- 只能通过规定的方法访问数据。
- 隐藏类的实例细节，方便修改和实现。


实现封装的具体步骤如下：

1. 修改属性的可见性来限制对属性的访问，一般设为 private。
2. 为每个属性创建一对赋值（setter）方法和取值（getter）方法，一般设为 public，用于属性的读写。
3. 在赋值和取值方法中，加入属性控制语句（对属性值的合法性进行判断）。

下面以一个员工类的封装为例介绍封装过程。一个员工的主要属性有姓名、年龄、联系电话和家庭住址。假设员工类为 Employee，示例如下：

```java
public class Employee {
    private String name; // 姓名
    private int age; // 年龄
    private String phone; // 联系电话
    private String address; // 家庭住址
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        // 对年龄进行限制
        if (age < 18 || age > 40) {
            System.out.println("年龄必须在18到40之间！");
            this.age = 20; // 默认年龄
        } else {
            this.age = age;
        }
    }
    public String getPhone() {
        return phone;
    }
    public void setPhone(String phone) {
        this.phone = phone;
    }
    public String getAddress() {
        return address;
    }
    public void setAddress(String address) {
        this.address = address;
    }
}
```

如上述代码所示，使用 private 关键字修饰属性，这就意味着除了 Employee 类本身外，其他任何类都不可以访问这些属性。但是，可以通过这些属性的 setXxx() 方法来对其进行赋值，通过 getXxx() 方法来访问这些属性。

在 age 属性的 setAge() 方法中，首先对用户传递过来的参数 age 进行判断，如果 age 的值不在 18 到 40 之间，则将 Employee 类的 age 属性值设置为 20，否则为传递过来的参数值。

编写测试类 EmployeeTest，在该类的 main() 方法中调用 Employee 属性的 setXxx() 方法对其相应的属性进行赋值，并调用 getXxx() 方法访问属性，代码如下：

```java
public class EmployeeTest {
    public static void main(String[] args) {
        Employee people = new Employee();
        people.setName("王丽丽");
        people.setAge(35);
        people.setPhone("13653835964");
        people.setAddress("河北省石家庄市");
        System.out.println("姓名：" + people.getName());
        System.out.println("年龄：" + people.getAge());
        System.out.println("电话：" + people.getPhone());
        System.out.println("家庭住址：" + people.getAddress());
    }
}
```

运行该示例，输出结果如下：

```
姓名：王丽丽
年龄：35
电话：13653835964
家庭住址：河北省石家庄市
```


通过封装，实现了对属性的数据访问限制，满足了年龄的条件。在属性的赋值方法中可以对属性进行限制操作，从而给类中的属性赋予合理的值， 并通过取值方法获取类中属性的值（也可以直接调用类中的属性名称来获取属性值）。

### Java继承（extends）简明教程

继承是面向对象的三大特征之一。继承和现实生活中的“继承”的相似之处是保留一些父辈的特性，从而减少代码冗余，提高程序运行效率。

[Java](http://c.biancheng.net/java/) 中的继承就是在已经存在类的基础上进行扩展，从而产生新的类。已经存在的类称为父类、基类或超类，而新产生的类称为子类或派生类**。在子类中，不仅包含父类的属性和方法，还可以增加新的属性和方法。**

Java 中子类继承父类的语法格式如下：

```java
修饰符 class class_name extends extend_class {   
// 类的主体
}
```

其中，class_name 表示子类（派生类）的名称；extend_class 表示父类（基类）的名称；extends 关键字直接跟在子类名之后，其后面是该类要继承的父类名称。例如：

```java
public class Student extends Person{}
```

Java 的继承通过 extends 关键字来实现，extends 的英文意思是扩展，而不是继承。extends 很好的体现了子类和父类的关系，即子类是对父类的扩展，子类是一种特殊的父类。从这个角度看，使用继承来描述子类和父类的关系是错误的，用扩展更恰当。

那么为什么国内把 extends 翻译为“继承”呢？子类扩展父类之后就可以获得父类的属性和方法，这与汉语中的继承（子类从父类获得一笔财富称为继承）具有相似性。

> Java 与 [C++](http://c.biancheng.net/cplus/) 定义继承类的方式十分相似。Java 用关键字 extends 代替了 C++ 中的冒号（：）。在 Java 中，所有的继承都是公有继承， 而没有 C++ 中的私有继承和保护继承。

**类的继承不改变类成员的访问权限，也就是说，如果父类的成员是公有的、被保护的或默认的，它的子类仍具有相应的这些特性，并且子类不能获得父类的构造方法。**



教师和学生都属于人，他们具有共同的属性：姓名、年龄、性别和身份证号，而学生还具有学号和所学专业两个属性，教师还具有教龄和所教专业两个属性。下面编写 Java 程序代码，使教师（Teacher）类和学生（Student）类都继承于人（People）类，具体的实现步骤如下。

1）创建人类 People，并定义 name、age、sex、sn 属性，代码如下：

```java
public class People {
    public String name; // 姓名
    public int age; // 年龄
    public String sex; // 性别
    public String sn; // 身份证号
    public People(String name, int age, String sex, String sn) {
        this.name = name;
        this.age = age;
        this.sex = sex;
        this.sn = sn;
    }
    public String toString() {
        return "姓名：" + name + "\n年龄：" + age + "\n性别：" + sex + "\n身份证号：" + sn;
    }
}
```

如上述代码，在 People 类中包含 4 个公有属性、一个构造方法和一个 toString() 方法。

2）创建 People 类的子类 Student 类，并定义 stuNo 和 department 属性，代码如下：

```java
public class Student extends People {
    private String stuNo; // 学号
    private String department; // 所学专业
    public Student(String name, int age, String sex, String sn, String stuno, String department) {
        super(name, age, sex, sn); // 调用父类中的构造方法
        this.stuNo = stuno;
        this.department = department;
    }
    public String toString() {
        return "姓名：" + name + "\n年龄：" + age + "\n性别：" + sex + "\n身份证号：" + sn + "\n学号：" + stuNo + "\n所学专业：" + department;
    }
}
```

由于 Student 类继承自 People 类，因此，在 Student 类中同样具有 People 类的属性和方法，这里重写了父类中的 toString() 方法。

**注意：如果在父类中存在有参的构造方法而并没有重载无参的构造方法，那么在子类中必须含有有参的构造方法，因为如果在子类中不含有构造方法，默认会调用父类中无参的构造方法，而在父类中并没有无参的构造方法，因此会出错。**

3）创建 People 类的另一个子类 Teacher，并定义 tYear 和 tDept 属性，代码如下：

```java
public class Teacher extends People {
    private int tYear; // 教龄
    private String tDept; // 所教专业
    public Teacher(String name, int age, String sex, String sn, int tYear, String tDept) {
        super(name, age, sex, sn); // 调用父类中的构造方法
        this.tYear = tYear;
        this.tDept = tDept;
    }
    public String toString() {
        return "姓名：" + name + "\n年龄：" + age + "\n性别:" + sex + "\n身份证号：" + sn + "\n教龄：" + tYear + "\n所教专业：" + tDept;
    }
}
```

Teacher 类与 Student 类相似，同样重写了父类中的 toString() 方法。

4）编写测试类 PeopleTest，在该类中创建 People 类的不同对象，分别调用它们的 toString() 方法，输出不同的信息。具体的代码如下：

```java
public class PeopleTest {
    public static void main(String[] args) {
        // 创建Student类对象
        People stuPeople = new Student("王丽丽", 23, "女", "410521198902145589", "00001", "计算机应用与技术");
        System.out.println("----------------学生信息---------------------");
        System.out.println(stuPeople);
        // 创建Teacher类对象
        People teaPeople = new Teacher("张文", 30, "男", "410521198203128847", 5, "计算机应用与技术");
        System.out.println("----------------教师信息----------------------");
        System.out.println(teaPeople);
    }
} 
```

运行程序，输出的结果如下：

```
----------------学生信息---------------------
姓名：王丽丽
年龄：23
性别：女
身份证号：410521198902145589
学号：00001
所学专业：计算机应用与技术
----------------教师信息----------------------
姓名：张文
年龄：30
性别:男
身份证号：410521198203128847
教龄：5
所教专业：计算机应用与技术
```

#### 单继承

Java 语言摒弃了 C++ 中难以理解的多继承特征，即 **Java 不支持多继承，只允许一个类直接继承另一个类，即子类只能有一个直接父类，extends 关键字后面只能有一个类名**。例如，如下代码会导致编译错误：

```java
class Student extends Person,Person1,Person2{…}
class Student extends Person,extends Person1,extends Person2{…}
```


很多地方在介绍 Java 的单继承时，可能会说 Java 类只能有一个父类，严格来讲，这种说法是错误的，应该是一个类只能有一个直接父类，但是它可以有多个间接的父类。例如，Student 类继承 Person 类，Person 类继承 Person1 类，Person1 类继承 Person2 类，那么 Person1 和 Person2 类是 Student 类的间接父类。图 1 展示了单继承的关系。



![img](/Users/jiusonghuang/pic-md/20210715112739.jpeg)
图 1 图形类之间的关系


从图 1 中可以看出，三角形、四边形和五边形的直接父类是多边形类，它们的间接父类是图形类。图形类、多边形类和三角形、四边形、五边形类形成了一个继承的分支。在这个分支上，位于下层的子类会继承上层所有直接或间接父类的属性和方法。如果两个类不在同一个继承树分支上，就不会存在继承关系，例如多边形类和直线。

如果定义一个 Java 类时并未显式指定这个类的直接父类，则这个类默认继承 java.lang.Object 类。因此，java.lang.Object 类是所有类的父类，要么是其直接父类，要么是其间接父类。因此所有的 Java 对象都可调用 java.lang.Object 类所定义的实例方法。

使用继承的注意点：

1. 子类一般比父类包含更多的属性和方法。
2. 父类中的 private 成员在子类中是不可见的，因此在子类中不能直接使用它们。
3. 父类和其子类间必须存在“是一个”即“is-a”的关系，否则不能用继承。但也并不是所有符合“is-a”关系的都应该用继承。例如，正方形是一个矩形，但不能让正方形类来继承矩形类，因为正方形不能从矩形扩展得到任何东西。正确的继承关系是正方形类继承图形类。
4. Java 只允许单一继承（**即一个子类只能有一个直接父类**），C++ 可以多重继承（即一个子类有多个直接父类）。

#### 继承的优缺点

在面向对象语言中，继承是必不可少的、非常优秀的语言机制，它有如下优点：

1. 实现代码共享，减少创建类的工作量，使子类可以拥有父类的方法和属性。
2. 提高代码维护性和可重用性。
3. 提高代码的可扩展性，更好的实现父类的方法。


自然界的所有事物都是优点和缺点并存的，继承的缺点如下：

1. 继承是侵入性的。只要继承，就必须拥有父类的属性和方法。
2. 降低代码灵活性。子类拥有父类的属性和方法后多了些约束。
3. 增强代码耦合性（开发项目的原则为高内聚低耦合）。当父类的常量、变量和方法被修改时，需要考虑子类的修改，有可能会导致大段的代码需要重构。

### Java super关键字详解

由于子类不能继承父类的构造方法，因此，如果要调用父类的构造方法，可以使用 super 关键字。super 可以用来访问父类的构造方法、普通方法和属性。

**super 关键字的功能：**

- **在子类的构造方法中显式的调用父类构造方法**
- **访问父类的成员方法和变量。**

#### super调用父类构造方法

super 关键字可以在子类的构造方法中显式地调用父类的构造方法，基本格式如下：

```java
super(parameter-list);
```

其中，parameter-list 指定了父类构造方法中的所有参数。**super( ) 必须是在子类构造方法的方法体的第一行。**

声明父类 Person 和子类 Student，在 Person 类中定义一个带有参数的构造方法，代码如下：

```java
public class Person {
    public Person(String name) {
    
    }
}
public class Student extends Person {

}
```

会发现 Student 类出现编译错误，提示必须显式定义构造方法，错误信息如下：

```
Implicit super constructor Person() is undefined for default constructor. Must define an explicit constructor
```

**在本例中 JVM 默认给 Student 类加了一个无参构造方法，而在这个方法中默认调用了 super()，但是 Person 类中并不存在该构造方法，所以会编译错误。**

如果一个类中没有写任何的构造方法，JVM 会生成一个默认的无参构造方法。在继承关系中，由于在子类的构造方法中，第一条语句默认为调用父类的无参构造方法（即默认为 super()，一般这行代码省略了）。所以当在父类中定义了有参构造方法，但是没有定义无参构造方法时，编译器会强制要求我们定义一个相同参数类型的构造方法。

声明父类 Person，类中定义两个构造方法。示例代码如下：

```java
public class Person {
    public Person(String name, int age) {
    
    }
    public Person(String name, int age, String sex) {
    
    }
}
```

子类 Student 继承了 Person 类，使用 super 语句来定义 Student 类的构造方法。示例代码如下：

```java
public class Student extends Person {
    public Student(String name, int age, String birth) {
        super(name, age); // 调用父类中含有2个参数的构造方法
    }
    public Student(String name, int age, String sex, String birth) {
        super(name, age, sex); // 调用父类中含有3个参数的构造方法
    }
}
```

从上述 Student 类构造方法代码可以看出，super 可以用来直接调用父类中的构造方法，使编写代码也更加简洁方便。

**编译器会自动在子类构造方法的第一句加上`super();`来调用父类的无参构造方法，必须写在子类构造方法的第一句，也可以省略不写。通过 super 来调用父类其它构造方法时，只需要把相应的参数传过去。**

#### super访问父类成员

当子类的成员变量或方法与父类同名时，可以使用 super 关键字来访问。如果子类重写了父类的某一个方法，即子类和父类有相同的方法定义，但是有不同的方法体，此时，我们可以通过 super 来调用父类里面的这个方法。

使用 super 访问父类中的成员与 this 关键字的使用相似，只不过它引用的是子类的父类，语法格式如下：

```java
super.member
```

其中，member 是父类中的属性或方法。使用 super 访问父类的属性和方法时不用位于第一行。

##### super调用成员属性

当父类和子类具有相同的数据成员时，JVM 可能会模糊不清。我们可以使用以下代码片段更清楚地理解它。

```java
class Person {
    int age = 12;
}
class Student extends Person {
    int age = 18;
    void display() {
        System.out.println("学生年龄：" + super.age);
    }
}
class Test {
    public static void main(String[] args) {
        Student stu = new Student();
        stu.display();
    }
}
```

输出结果为：

学生年龄：12

在上面的例子中，父类和子类都有一个成员变量 age。我们可以使用 super 关键字访问 Person 类中的 age 变量。

##### super调用成员方法

当父类和子类都具有相同的方法名时，可以使用 super 关键字访问父类的方法。具体如下代码所示。

```java
class Person {
    void message() {
        System.out.println("This is person class");
    }
}
class Student extends Person {
    void message() {
        System.out.println("This is student class");
    }
    void display() {
        message();
        super.message();
    }
}
class Test {
    public static void main(String args[]) {
        Student s = new Student();
        s.display();
    }
}
```

输出结果为：

This is student class
        This is person class

在上面的例子中，可以看到如果只调用方法 message( )，是当前的类 message( ) 被调用，使用 super 关键字时，是父类的 message( ) 被调用。

#### super和this的区别

this 指的是当前对象的引用，super 是当前对象的父对象的引用。下面先简单介绍一下 super 和 this 关键字的用法。

super 关键字的用法：

- super.父类属性名：调用父类中的属性
- super.父类方法名：调用父类中的方法
- super()：调用父类的无参构造方法
- super(参数)：调用父类的有参构造方法


如果构造方法的第一行代码不是 this() 和 super()，则系统会默认添加 super()。
this 关键字的用法：

- this.属性名：表示当前对象的属性
- this.方法名(参数)：表示调用当前对象的方法


当局部变量和成员变量发生冲突时，使用`this.`进行区分。

关于 [Java](http://c.biancheng.net/java/) super 和 this 关键字的异同，可简单总结为以下几条。

1. 子类和父类中变量或方法名称相同时，用 super 关键字来访问。可以理解为 super 是指向自己父类对象的一个指针。在子类中调用父类的构造方法。
2. this 是自身的一个对象，代表对象本身，可以理解为 this 是指向对象本身的一个指针。在同一个类中调用其它方法。
3. this 和 super 不能同时出现在一个构造方法里面，因为 this 必然会调用其它的构造方法，其它的构造方法中肯定会有 super 语句的存在，所以在同一个构造方法里面有相同的语句，就失去了语句的意义，编译器也不会通过。
4. this( ) 和 super( ) 都指的是对象，所以，均不可以在 static 环境中使用，包括 static 变量、static 方法和 static 语句块。
5. 从本质上讲，this 是一个指向对象本身的指针, 然而 super 是一个 Java 关键字。

在 Animal 类和 Cat 类中分别定义了 public 类型的 name 属性和 private 类型的 name 属性，并且 Cat 类继承 Animal 类。那么，我们可以在 Cat 类中通过 super 关键字来访问父类 Animal 中的 name 属性，通过 this 关键字来访问本类中的 name 属性，如下面的代码：

```java
// 父类Animal的定义
public class Animal {
    public String name; // 动物名字
}
//子类Cat的定义
public class Cat extends Animal {
    private String name; // 名字
    public Cat(String aname, String dname) {
        super.name = aname; // 通过super关键字来访问父类中的name属性
        this.name = dname; // 通过this关键字来访问本类中的name属性
    }
    public String toString() {
        return "我是" + super.name + "，我的名字叫" + this.name;
    }
    public static void main(String[] args) {
        Animal cat = new Cat("动物", "喵星人");
        System.out.println(cat);
    }
}
```

上述代码演示了使用 super 关键字访问父类中与子类同名的成员变量 name，this 关键字访问本类的 name 变量。运行程序，输出结果如下：

```
我是动物，我的名字叫喵星人
```

### Java对象类型转换：向上转型和向下转型

将一个类型强制转换成另一个类型的过程被称为类型转换。本节所说的对象类型转换，是指存在继承关系的对象，不是任意类型的对象。**当对不存在继承关系的对象进行强制类型转换时，会抛出 [Java](http://c.biancheng.net/java/) 强制类型转换（java.lang.ClassCastException）异常。**

Java 语言允许某个类型的引用变量引用子类的实例，而且可以对这个引用变量进行类型转换。Java 中引用类型之间的类型转换（前提是两个类是父子关系）主要有两种，分别是向上转型（upcasting）和向下转型（downcasting）。

#### 1）向上转型

父类引用指向子类对象为向上转型，语法格式如下：

```java
fatherClass obj = new sonClass();
```

其中，fatherClass 是父类名称或接口名称，obj 是创建的对象，sonClass 是子类名称。

向上转型就是把子类对象直接赋给父类引用，不用强制转换。使用向上转型可以调用父类类型中的所有成员，不能调用子类类型中特有成员，最终运行效果看子类的具体实现。

#### 2）向下转型

与向上转型相反，子类对象指向父类引用为向下转型，语法格式如下：

```java
sonClass obj = (sonClass) fatherClass;
```

其中，fatherClass 是父类名称，obj 是创建的对象，sonClass 是子类名称。

向下转型可以调用子类类型中所有的成员，不过需要注意的是如果父类引用对象指向的是子类对象，那么在向下转型的过程中是安全的，也就是编译是不会出错误。但是如果父类引用对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错**，但是运行时会出现我们开始提到的 Java 强制类型转换异常，一般使用 instanceof 运算符来避免出此类错误。**

例如，Animal 类表示动物类，该类对应的子类有 Dog 类，使用对象类型表示如下：

```java
Animal animal = new Dog();    // 向上转型，把Dog类型转换为Animal类型
Dog dog = (Dog) animal; // 向下转型，把Animal类型转换为Dog类型
```



下面通过具体的示例演示对象类型的转换。例如，父类 Animal 和子类 Cat 中都定义了实例变量 name、静态变量 staticName、实例方法 eat() 和静态方法 staticEat()。此外，子类 Cat 中还定义了实例变量 str 和实例方法 eatMethod()。

父类 Animal 的代码如下：

```java
public class Animal {
    public String name = "Animal：动物";
    public static String staticName = "Animal：可爱的动物";
    public void eat() {
        System.out.println("Animal：吃饭");
    }
    public static void staticEat() {
        System.out.println("Animal：动物在吃饭");
    }
}
```

子类 Cat 的代码如下： 

```java
public class Cat extends Animal {
    public String name = "Cat：猫";
    public String str = "Cat：可爱的小猫";
    public static String staticName = "Dog：我是喵星人";
    public void eat() {
        System.out.println("Cat：吃饭");
    }
    public static void staticEat() {
        System.out.println("Cat：猫在吃饭");
    }
    public void eatMethod() {
        System.out.println("Cat：猫喜欢吃鱼");
    }
    public static void main(String[] args) {
        Animal animal = new Cat();
        Cat cat = (Cat) animal; // 向下转型
        System.out.println(animal.name); // 输出Animal类的name变量
        System.out.println(animal.staticName); // 输出Animal类的staticName变量
        animal.eat(); // 输出Cat类的eat()方法
        animal.staticEat(); // 输出Animal类的staticEat()方法
        System.out.println(cat.str); // 调用Cat类的str变量
        cat.eatMethod(); // 调用Cat类的eatMethod()方法
    }
}
```

通过引用类型变量来访问所引用对象的属性和方法时，Java 虚拟机将采用以下绑定规则：

- 实例方法与引用变量实际引用的对象的方法进行绑定，这种绑定属于动态绑定，因为是在运行时由 Java 虚拟机动态决定的。例如，animal.eat() 是将 eat() 方法与 Cat 类绑定。
- 静态方法与引用变量所声明的类型的方法绑定，这种绑定属于静态绑定，因为是在编译阶段已经做了绑定。例如，animal.staticEat() 是将 staticEat() 方法与 Animal 类进行绑定。
- 成员变量（包括静态变量和实例变量）与引用变量所声明的类型的成员变量绑定，这种绑定属于静态绑定，因为在编译阶段已经做了绑定。例如，animal.name 和 animal.staticName 都是与 Animal 类进行绑定。


对于 Cat 类，运行时将会输出如下结果：

```
Animal：动物
Animal：可爱的动物
Cat：吃饭
Animal：动物在吃饭
Cat：可爱的小猫
Cat：猫喜欢吃鱼
```

#### 强制对象类型转换

Java 编译器允许在具有直接或间接继承关系的类之间进行类型转换。对于向下转型，必须进行强制类型转换；对于向上转型，不必使用强制类型转换。

例如，对于一个引用类型的变量，Java 编译器按照它声明的类型来处理。如果使用 animal 调用 str 和 eatMethod() 方法将会出错，如下：

```java
animal.str = "";    // 编译出错，提示Animal类中没有str属性
animal.eatMethod();    // 编译出错，提示Animal类中没有eatMethod()方法
```


如果要访问 Cat 类的成员，必须通过强制类型转换，如下：

```java
((Cat)animal).str = "";    // 编译成功((Cat)animal).eatMethod();    // 编译成功
```


把 Animal 对象类型强制转换为 Cat 对象类型，这时上面两句编译成功。对于如下语句，由于使用了强制类型转换，所以也会编译成功，例如：

```java
Cat cat = (Cat)animal;    // 编译成功，将Animal对象类型强制转换为Cat对象类型
```


类型强制转换时想运行成功就必须保证父类引用指向的对象一定是该子类对象，最好使用 instanceof 运算符判断后，再强转，例如：

```java
Animal animal = new Cat();
if (animal instanceof Cat) {  
    Cat cat = (Cat) animal; // 向下转型 
    ...
}
```


子类的对象可以转换成父类类型，而父类的对象实际上无法转换为子类类型。因为通俗地讲，**父类拥有的成员子类肯定也有，而子类拥有的成员，父类不一定有**。因此，对于向上转型，不必使用强制类型转换。例如：

```java
Cat cat = new Cat();
Animal animal = cat;    // 向上转型，不必使用强制类型转换
```


如果两种类型之间没有继承关系，那么将不允许进行类型转换。例如：

```java
Dog dog = new Dog();
Cat cat = (Cat)dog;    // 编译出错，不允许把Dog对象类型转换为Cat对象类型
```

###  为什么使用向上转型而不直接创建子类对象？

初学者在学习向上转型可能会很难理解，向上转型并不能调用子类特有属性和方法，我们必须先生成子类实例再赋值给父类引用（向上转型），然后将父类引用向下强制转换给子类引用（向下转型），这样才能调用子类中的所有成员。这看起来像是多次一举，还不如直接创建子类实例。

随着技术的提升，我们在学习其它开源项目时会发现很多地方都用了向上转型和向下转型的技术。本节将带大家了解向上转型和向下转型的意义及使用场景。

#### 例 1

定义父类 Animal，代码如下：

```java
public class Animal {
    public void sleep() {
        System.out.println("小动物在睡觉");
    }
    public static void doSleep(Animal animal) {
        // 此时的参数是父类对象，但是实际调用时传递的是子类对象，就是向上转型。
        animal.sleep();
    }
    public static void main(String[] args) {
        animal.doSleep(new Cat());
        animal.doSleep(new Dog());
    }
}
```

子类 Cat 代码如下：

```java
public class Cat extends Animal {
    @Override
    public void sleep() {
        System.out.println("猫正在睡觉");
    }
}
```

子类 Dog 代码如下：

```java
public class Cat extends Animal {
    @Override
    public void sleep() {
        System.out.println("猫正在睡觉");
    }
}
```

输出结果为：

猫正在睡觉
狗正在睡觉

如果不用向上转型则必须写两个 doSleep 方法，一个传递 Cat 类对象，一个传递 Dog 类对象。这还是两个子类，如果有多个子类就要写很多相同的方法，造成重复。可以看出向上转型更好的体现了类的多态性，增强了程序的间接性以及提高了代码的可扩展性。当需要用到子类特有的方法时可以向下转型，这也就是为什么要向下转型。

比如设计一个父类 FileRead 用来读取文件，ExcelRead 类和 WordRead 类继承 FileRead 类。在使用程序的时候，往往事先不知道我们要读入的是 Excel 还是 Word。所以我们向上转型用父类去接收，然后在父类中实现自动绑定，这样无论你传进来的是 Excel 还是 Word 就都能够完成文件读取。

总结如下：

1. 把子类对象直接赋给父类引用是向上转型，向上转型自动转换。如 Father father = new Son();
2. 指向子类对象的父类引用赋给子类引用是向下转型，要强制转换。使用向下转型，必须先向上转型，为了安全可以用 instanceof 运算符判断。 如 father 是一个指向子类对象的父类引用，把 father 赋给子类引用 son，即`Son son =（Son）father;`。其中 father 前面的`(Son)`必须添加，进行强制转换。
3. 向上转型不能使用子类特有的属性和方法，只能引用父类的属性和方法，但是子类重写父类的方法是有效的。
4. 向上转型时会优先使用子类中重写父类的方法，如例 1 中调用的 sleep 方法。
5. 向上转型的作用是减少重复代码，可以将父类作为参数，这样使代码变得简洁，也更好的体现了多态。

### Java方法重载

[Java](http://c.biancheng.net/java/) 允许同一个类中定义多个同名方法，只要它们的形参列表不同即可。如果同一个类中包含了两个或两个以上方法名相同的方法，但形参列表不同，这种情况被称为方法重载（overload）。

例如，在 JDK 的 java.io.PrintStream 中定义了十多个同名的 println() 方法。

```java
public void println(int i){…}
public void println(double d){…}
public void println(String s){…}
```

这些方法完成的功能类似，都是格式化输出。根据参数的不同来区分它们，以进行不同的格式化处理和输出。它们之间就构成了方法的重载。实际调用时，根据实参的类型来决定调用哪一个方法。例如：

```java
System.out.println(102);    // 调用println(int i)方法
System.out.println(102.25);    // 调用println(double d)方法
System.out.println("价格为 102.25");    // 调用println(String s)方法
```


方法重载的要求是两同一不同：同一个类中方法名相同，参数列表不同。至于方法的其他部分，如方法返回值类型、修饰符等，与方法重载没有任何关系。

使用方法重载其实就是避免出现繁多的方法名，有些方法的功能是相似的，如果重新建立一个方法，重新取个方法名称，会降低程序可读性。

在比较数值时，数值的个数和类型是不固定的，可能是两个 int 类型的数值，也可能是两个 double 类型的数值，或者是两个 double、一个 int 类型的数值；在这种情况下就可以使用方法的重载来实现数值之间的比较功能。具体实现代码如下：

```java
public class OverLoading {
    public void max(int a, int b) {
        // 含有两个int类型参数的方法
        System.out.println(a > b ? a : b);
    }
    public void max(double a, double b) {
        // 含有两个double类型参数的方法
        System.out.println(a > b ? a : b);
    }
    public void max(double a, double b, int c) {
        // 含有两个double类型参数和一个int类型参数的方法
        double max = (double) (a > b ? a : b);
        System.out.println(c > max ? c : max);
    }
    public static void main(String[] args) {
        OverLoading ol = new OverLoading();
        System.out.println("1 与 5 比较，较大的是：");
        ol.max(1, 5);
        System.out.println("5.205 与 5.8 比较，较大的是：");
        ol.max(5.205, 5.8);
        System.out.println("2.15、0.05、58 中，较大的是：");
        ol.max(2.15, 0.05, 58);
    }
}
```

编译、运行上面程序完全正常，虽然 3 个 max() 方法的方法名相同，但因为它们的形参列表不同，所以系统可以正常区分出这 3 个方法。当运行时，Java 虚拟机会根据传递过来的不同参数来调用不同的方法。运行结果如下：

```
1 与 5 比较，较大的是：
5
5.205 与 5.8 比较，较大的是：
5.8
2.15、0.05、58 中，较大的是：
58.0
```

为什么方法重载不能用方法的返回值类型区分呢？

对于`int f( ) { }`和`void f( ) { }`两个方法，如果这样调用`int result = f();`，系统可以识别是调用返回值类型为 int 的方法，但 Java 调用方法时可以忽略方法返回值，如果采用如下方法来调用`f();`，你能判断是调用哪个方法吗？如果你尚且不能判断，那么 Java 系统也会糊涂。在编程过程中有一条重要规则就是不要让系统糊涂，系统一糊涂，肯定就是你错了。**因此，Java 里不能用方法返回值类型作为区分方法重载的依据。**

### Java方法重写

在子类中如果创建了一个与父类中相同名称、相同返回值类型、相同参数列表的方法，只是方法体中的实现不同，以实现不同于父类的功能，这种方式被称为**方法重写（override）**，又称为方法覆盖。**当父类中的方法无法满足子类需求或子类具有特有功能的时候，需要方法重写。**

子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强。

在重写方法时，需要遵循下面的规则：

- 参数列表必须完全与被重写的方法参数列表相同。
- 返回的类型必须与被重写的方法的返回类型相同（[Java](http://c.biancheng.net/java/)1.5 版本之前返回值类型必须一样，之后的 Java 版本放宽了限制，返回值类型必须小于或者等于父类方法的返回值类型）。
- 访问权限不能比父类中被重写方法的访问权限更低（public>protected>default>private）。
- 重写方法一定不能抛出新的检査异常或者比被重写方法声明更加宽泛的检査型异常。例如，父类的一个方法声明了一个检査异常 IOException，在重写这个方法时就不能抛出 Exception，只能拋出 IOException 的子类异常，可以抛出非检査异常。


另外还要注意以下几条：

- 重写的方法可以使用 @Override 注解来标识。
- 父类的成员方法只能被它的子类重写。
- 声明为 final 的方法不能被重写。
- 声明为 static 的方法不能被重写，但是能够再次声明。
- 构造方法不能被重写。
- 子类和父类在同一个包中时，子类可以重写父类的所有方法，除了声明为 private 和 final 的方法。
- 子类和父类不在同一个包中时，子类只能重写父类的声明为 public 和 protected 的非 final 方法。
- 如果不能继承一个方法，则不能重写这个方法。

每种动物都有名字和年龄属性，但是喜欢吃的食物是不同的，比如狗喜欢吃骨头、猫喜欢吃鱼等，因此每种动物的介绍方式是不一样的。

下面编写 Java 程序，在父类 Animal 中定义 getInfo() 方法，并在子类 Cat 中重写该方法， 实现猫的介绍方式。父类 Animal 的代码如下：

```java
public class Animal {
    public String name; // 名字
    public int age; // 年龄
    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public String getInfo() {
        return "我叫" + name + "，今年" + age + "岁了。";
    }
}
```

子类 Cat 的代码如下：

```java
public class Cat extends Animal {
    private String hobby;
    public Cat(String name, int age, String hobby) {
        super(name, age);
        this.hobby = hobby;
    }
    public String getInfo() {
        return "喵！大家好！我叫" + this.name + "，我今年" + this.age + "岁了，我爱吃" + hobby + "。";
    }
    public static void main(String[] args) {
        Animal animal = new Cat("小白", 2, "鱼");
        System.out.println(animal.getInfo());
    }
}
```

如上述代码，在 Animal 类中定义了一个返回值类型为 String、名称为 getInfo() 的方法，而 Cat 类继承自该类，因此 Cat 类同样含有与 Animal 类中相同的 getInfo() 方法。但是我们在 Cat 类中又重新定义了一个 getInfo() 方法，即重写了父类中的 getInfo() 方法。

在 main() 方法中，创建了 Cat 类的对象 animal，并调用了 getInfo() 方法。输出的结果如下：

```
喵！大家好！我叫小白，我今年2岁了，我爱吃鱼。
```

**如果子类中创建了一个成员变量，而该变量的类型和名称都与父类中的同名成员变量相同，我们则称作变量隐藏。**

### Java多态性：Java什么是多态？

多态性是面向对象编程的又一个重要特征，它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。

对面向对象来说，多态分为**编译时多态和运行时多态**。其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的方法。通过编译之后会变成两个不同的方法，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是大家通常所说的多态性。

Java 实现多态有 3 个必要条件：继承、重写和向上转型。只有满足这 3 个条件，开发人员才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而执行不同的行为。

- 继承：在多态中必须存在有继承关系的子类和父类。
- 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
- 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。

下面通过一个例子来演示重写如何实现多态性。例子使用了类的继承和运行时多态机制，具体步骤如下。

```java
public class Figure {
    double dim1;
    double dim2;
    Figure(double d1, double d2) {
        // 有参的构造方法
        this.dim1 = d1;
        this.dim2 = d2;
    }
    double area() {
        // 用于计算对象的面积
        System.out.println("父类中计算对象面积的方法，没有实际意义，需要在子类中重写。");
        return 0;
    }
}
```

2）创建继承自 Figure 类的 Rectangle 子类，该类调用父类的构造方法，并且重写父类中的 area() 方法。代码如下：

```java
public class Rectangle extends Figure {
    Rectangle(double d1, double d2) {
        super(d1, d2);
    }
    double area() {
        System.out.println("长方形的面积：");
        return super.dim1 * super.dim2;
    }
}
```

3）创建继承自 Figure 类的 Triangle 子类，该类与 Rectangle 相似。代码如下：

```java
public class Triangle extends Figure {
    Triangle(double d1, double d2) {
        super(d1, d2);
    }
    double area() {
        System.out.println("三角形的面积：");
        return super.dim1 * super.dim2 / 2;
    }
}
```

4）创建 Test 测试类，在该类的 main() 方法中首先声明 Figure 类的变量 figure，然后分别为 figure 变量指定不同的对象，并调用这些对象的 area() 方法。代码如下：

```java
public class Test {
    public static void main(String[] args) {
        Figure figure; // 声明Figure类的变量
        figure = new Rectangle(9, 9);
        System.out.println(figure.area());
        System.out.println("===============================");
        figure = new Triangle(6, 8);
        System.out.println(figure.area());
        System.out.println("===============================");
        figure = new Figure(10, 10);
        System.out.println(figure.area());
    }
}
```

从上述代码可以发现，无论 figure 变量的对象是 Rectangle 还是 Triangle，它们都是 Figure 类的子类，因此可以向上转型为该类，从而实现多态。

5）执行上述代码，输出结果如下：

```
长方形的面积：
81.0
===============================
三角形的面积：
24.0
===============================
父类中计算对象面积的方法，没有实际意义，需要在子类中重写。
0.0
```

### Java instanceof关键字详解

严格来说 instanceof 是 Java 中的一个双目运算符，由于它是由字母组成的，所以也是 Java 的保留关键字。在 Java 中可以使用 instanceof 关键字判断一个对象是否为一个类（或接口、抽象类、父类）的实例，语法格式如下所示。

```java
boolean result = obj instanceof Class
```

其中，obj 是一个对象，Class 表示一个类或接口。obj 是 class 类（或接口）的实例或者子类实例时，结果 result 返回 true，否则返回 false。

下面介绍 Java instanceof 关键字的几种用法。

1）声明一个 class 类的对象，判断 obj 是否为 class 类的实例对象（很普遍的一种用法），如以下代码：

```java
Integer integer = new Integer(1);
System.out.println(integer instanceof Integer);  // true
```

2）声明一个 class 接口实现类的对象 obj，判断 obj 是否为 class 接口实现类的实例对象，如以下代码：

Java 集合中的 List 接口有个典型实现类 ArrayList。

```java
public class ArrayList<E> extends AbstractList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

所以我们可以用 instanceof 运算符判断 ArrayList 类的对象是否属于 List 接口的实例，如果是返回 true，否则返回 false。

```java
ArrayList arrayList = new ArrayList();
System.out.println(arrayList instanceof List);  // true

或者反过来也是返回 true
```

```java
List list = new ArrayList();
System.out.println(list instanceof ArrayList);  // true
```

3）obj 是 class 类的直接或间接子类

我们新建一个父类 Person.class，代码如下：

```java
public class Person {

}
```

创建 Person 的子类 Man，代码如下：

```java
public class Man extends Person {

}
```

测试代码如下：

```java
Person p1 = new Person();
Person p2 = new Man();
Man m1 = new Man();
System.out.println(p1 instanceof Man);    // false
System.out.println(p2 instanceof Man);    // true
System.out.println(m1 instanceof Man);    // true
```

第 4 行代码中，Man 是 Person 的子类，Person 不是 Man 的子类，所以返回结果为 false。

值得注意的是 obj 必须为引用类型，不能是基本类型。例如以下代码：

```java
int i = 0;
System.out.println(i instanceof Integer);  // 编译不通过
System.out.println(i instanceof Object);  // 编译不通过
```

所以，instanceof 运算符只能用作对象的判断。

当 obj 为 null 时，直接返回 false，因为 null 没有引用任何对象。

```java
Integer i = 1;
System.out.println(i instanceof null);  // false
```

所以，obj 的类型必须是引用类型或空类型，否则会编译错误。

当 class 为 null 时，会发生编译错误，错误信息如下：

Syntax error on token "null", invalid ReferenceType

所以 class 只能是类或者接口。

编译器会检查 obj 能否转换成右边的 class 类型，如果不能转换则直接报错，如果不能确定类型，则通过编译。这句话有些难理解，下面我们举例说明。

```java
Person p1 = new Person();
System.out.println(p1 instanceof String);    // 编译报错
System.out.println(p1 instanceof List);    // false
System.out.println(p1 instanceof List<?>);    // false
System.out.println(p1 instanceof List<Person>);    // 编译报错
```

上述代码中，Person 的对象 p1 很明显不能转换为 String 对象，那么`p1 instanceof String`不能通过编译，但`p1 instanceof List`却能通过编译，而`instanceof List<Person>`又不能通过编译了。关于这些问题，可以查看[Java语言规范Java SE8版](https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.20.2)寻找答案，如图所示。



![img](/Users/jiusonghuang/pic-md/20210716105939.png)


可以理解成以下代码：

```java
boolean result;
if (obj == null) {
    result = false;    // 当obj为null时，直接返回false
} else {
    try {
        // 判断obj是否可以强制转换为T
        T temp = (T) obj; 
        result = true;
    } catch (ClassCastException e) {
        result = false;
    }
}
```

在 T 不为 null 和 obj 不为 null 时，如果 obj 可以转换为 T 而不引发异常（ClassCastException），则该表达式值为 true ，否则值为 false 。所以对于上面提出的问题就很好理解了，`p1 instanceof String`会编译报错，是因为`(String)p1`是不能通过编译的，而`(List)p1`可以通过编译。

instanceof 也经常和三目（条件）运算符一起使用，代码如下：

```
A instanceof B ? A : C
```

判断 A 是否可以转换为 B ，如果可以转换返回 A ，不可以转换则返回 C。下面通过一个例子来讲解，代码如下：

```java
public class Test {
    public Object animalCall(Animal a) {
        String tip = "这个动物不是牛！";
        // 判断参数a是不是Cow的对象
        return a instanceof Cow ? (Cow) a : tip;
    }
    public static void main(String[] args) {
        Sheep sh = new Sheep();
        Test test = new Test();
        System.out.println(test.animalCall(sh));
    }
}
class Animal {

}
class Cow extends Animal {

}
class Sheep extends Animal {

}
```

以上代码中，我们声明了一个 Animal 类作为父类，Cow 类和 Sheep 类为 Animal 的子类，在 Test 类的 main 函数中创建类 Sheep 的对象作为形参传递到 animalCall 方法中，因为 Sheep 类的对象不能转换为 Cow 类型，所以输出结果为“这个动物不是牛！”。

### Java抽象（abstract）类

[Java](http://c.biancheng.net/java/) 语言提供了两种类，分别为具体类和抽象类。前面学习接触的类都是具体类。这一节介绍一下抽象类。

在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，那么这样的类称为抽象类。

在 Java 中抽象类的语法格式如下：

```
<abstract> class <class_name> {
    <abstract> <type> <method_name> (parameter-iist);
}
```

其中，abstract 表示该类或该方法是抽象的；class_name 表示抽象类的名称；method_name 表示抽象方法名称，parameter-list 表示方法参数列表。

如果一个方法使用 abstract 来修饰，则说明该方法是抽象方法，抽象方法只有声明没有实现。**需要注意的是 abstract 关键字只能用于普通方法，不能用于 static 方法或者构造方法中。**

抽象方法的 3 个特征如下：

1. **抽象方法没有方法体**
2. **抽象方法必须存在于抽象类中**
3. **子类重写父类时，必须重写父类所有的抽象方法**


注意：**在使用 abstract 关键字修饰抽象方法时不能使用 private 修饰，因为抽象方法必须被子类重写，而如果使用了 private 声明，则子类是无法重写的**。

**抽象类的定义和使用规则如下：**

1. **抽象类和抽象方法都要使用 abstract 关键字声明。**
2. **如果一个方法被声明为抽象的，那么这个类也必须声明为抽象的。而一个抽象类中，可以有 0~n 个抽象方法，以及 0~n 个具体方法。**
3. **抽象类不能实例化，也就是不能使用 new 关键字创建对象。**

不同几何图形的面积计算公式是不同的，但是它们具有的特性是相同的，都具有长和宽这两个属性，也都具有面积计算的方法。那么可以定义一个抽象类，在该抽象类中含有两个属性（width 和 height）和一个抽象方法 area( )，具体步骤如下。

1）首先创建一个表示图形的抽象类 Shape，代码如下所示。

```java
public abstract class Shape {
    public int width; // 几何图形的长
    public int height; // 几何图形的宽
    public Shape(int width, int height) {
        this.width = width;
        this.height = height;
    }
    public abstract double area(); // 定义抽象方法，计算面积
}
```

2）定义一个正方形类，该类继承自形状类 Shape，并重写了 area( ) 抽象方法。正方形类的代码如下：

```java
public class Square extends Shape {
    public Square(int width, int height) {
        super(width, height);
    }
    // 重写父类中的抽象方法，实现计算正方形面积的功能
    @Override
    public double area() {
        return width * height;
    }
}
```

3）定义一个三角形类，该类与正方形类一样，需要继承形状类 Shape，并重写父类中的抽象方法 area()。三角形类的代码实现如下：

```java
public class Triangle extends Shape {
    public Triangle(int width, int height) {
        super(width, height);
    }
    // 重写父类中的抽象方法，实现计算三角形面积的功能
    @Override
    public double area() {
        return 0.5 * width * height;
    }
}
```

4）最后创建一个测试类，分别创建正方形类和三角形类的对象，并调用各类中的 area() 方法，打印出不同形状的几何图形的面积。测试类的代码如下：

```java
public class ShapeTest {
    public static void main(String[] args) {
        Square square = new Square(5, 4); // 创建正方形类对象
        System.out.println("正方形的面积为：" + square.area());
        Triangle triangle = new Triangle(2, 5); // 创建三角形类对象
        System.out.println("三角形的面积为：" + triangle.area());
    }
}
```

在该程序中，创建了 4 个类，分别为图形类 Shape、正方形类 Square、三角形类 Triangle 和测试类 ShapeTest。其中图形类 Shape 是一个抽象类，创建了两个属性，分别为图形的长度和宽度，并通过构造方法 Shape( ) 给这两个属性赋值。

在 Shape 类的最后定义了一个抽象方法 area( )，用来计算图形的面积。在这里，Shape 类只是定义了计算图形面积的方法，而对于如何计算并没有任何限制。也可以这样理解，抽象类 Shape 仅定义了子类的一般形式。

正方形类 Square 继承抽象类 Shape，并实现了抽象方法 area( )。三角形类 Triangle 的实现和正方形类相同，这里不再介绍。

在测试类 ShapeTest 的 main( ) 方法中，首先创建了正方形类和三角形类的实例化对象 square 和 triangle，然后分别调用 area( ) 方法实现了面积的计算功能。

5）运行该程序，输出的结果如下：

```
正方形的面积为：20.0
三角形的面积为：5.0
```

### Java接口（Interface）的定义和实现

抽象类是从多个类中抽象出来的模板，如果将这种抽象进行的更彻底，则可以提炼出一种更加特殊的“抽象类”——接口（Interface）。接口是 [Java](http://c.biancheng.net/java/) 中最重要的概念之一，它可以被理解为一种特殊的类，不同的是接口的成员没有执行体，是由全局常量和公共的抽象方法所组成。

#### 定义接口

Java 接口的定义方式与类基本相同，不过接口定义使用的关键字是 interface，接口定义的语法格式如下：

```java
[public] interface interface_name [extends interface1_name[, interface2_name,…]] {
    // 接口体，其中可以包含定义常量和声明方法
    [public] [static] [final] type constant_name = value;    // 定义常量
    [public] [abstract] returnType method_name(parameter_list);    // 声明方法
}
```

对以上语法的说明如下：

- public 表示接口的修饰符，当没有修饰符时，则使用默认的修饰符，此时该接口的访问权限仅局限于所属的包；
- interface_name 表示接口的名称。接口名应与类名采用相同的命名规则，即如果仅从语法角度来看，接口名只要是合法的标识符即可。如果要遵守 Java 可读性规范，则接口名应由多个有意义的单词连缀而成，每个单词首字母大写，单词与单词之间无需任何分隔符。
- extends 表示接口的继承关系；
- interface1_name 表示要继承的接口名称；
- constant_name 表示变量名称，一般是 static 和 final 型的；
- returnType 表示方法的返回值类型；
- parameter_list 表示参数列表，在接口中的方法是没有方法体的。

```
注意：一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类。
```

接口对于其声明、变量和方法都做了许多限制，这些限制作为接口的特征归纳如下：

- 具有 public 访问控制符的接口，允许任何类使用；没有指定 public 的接口，其访问将局限于所属的包。
- 方法的声明不需要其他修饰符，在接口中声明的方法，**将隐式地声明为公有的（public）和抽象的（abstract）。**
- 在 Java 接口中声明的变量其实都是常量，**接口中的变量声明，将隐式地声明为 public、static 和 final，即常量，所以接口中定义的变量必须初始化**。
- 接口没有构造方法，不能被实例化。例如：

```java
public interface A {
    publicA(){…}    // 编译出错，接口不允许定义构造方法
}
```

**一个接口不能够实现另一个接口，但它可以继承多个其他接口。子接口可以对父接口的方法和常量进行重写。例如：**

```java
public interface StudentInterface extends PeopleInterface {
    // 接口 StudentInterface 继承 PeopleInterface
    int age = 25;    // 常量age重写父接口中的age常量
    void getInfo();    // 方法getInfo()重写父接口中的getInfo()方法
}
```

例如，定义一个接口 MyInterface，并在该接口中声明常量和方法，如下：

```java
public interface MyInterface {    // 接口myInterface
    String name;    // 不合法，变量name必须初始化
    int age = 20;    // 合法，等同于 public static final int age = 20;
    void getInfo();    // 方法声明，等同于 public abstract void getInfo();
}
```

#### 实现接口

接口的主要用途就是被实现类实现，一个类可以实现一个或多个接口，继承使用 extends 关键字，实现则使用 implements 关键字。因为一个类可以实现多个接口，这也是 Java 为单继承灵活性不足所作的补充。类实现接口的语法格式如下：

```java
<public> class <class_name> [extends superclass_name] [implements interface1_name [,interface2_name…]] {
    // 主体
}
```

对以上语法的说明如下：

- public：类的修饰符；
- superclass_name：需要继承的父类名称；
- interface1_name：要实现的接口名称。


实现接口需要注意以下几点：

- **实现接口与继承父类相似，一样可以获得所实现接口里定义的常量和方法**。如果一个类需要实现多个接口，则多个接口之间以逗号分隔。
- 一个类可以继承一个父类，并同时实现多个接口，**implements 部分必须放在 extends 部分之后**。
- 一个类实现了一个或多个接口之后，**这个类必须完全实现这些接口里所定义的全部抽象方法（也就是重写这些抽象方法）；否则，该类将保留从父接口那里继承到的抽象方法，该类也必须定义成抽象类。**

在程序的开发中，需要完成两个数的求和运算和比较运算功能的类非常多。那么可以定义一个接口来将类似的功能组织在一起。下面创建一个示例，具体介绍接口的实现方式。

1）创建一个名称为 IMath 的接口，代码如下：

```java
public interface IMath {
    public int sum();    // 完成两个数的相加
    public int maxNum(int a,int b);    // 获取较大的数
}
```

2）定义一个 MathClass 类并实现 IMath 接口，MathClass 类实现代码如下：

```java
public class MathClass implements IMath {
    private int num1;    // 第 1 个操作数
    private int num2;    // 第 2 个操作数
    public MathClass(int num1,int num2) {
        // 构造方法
        this.num1 = num1;
        this.num2 = num2;
    }
    // 实现接口中的求和方法
    public int sum() {
        return num1 + num2;
    }
    // 实现接口中的获取较大数的方法
    public int maxNum(int a,int b) {
        if(a >= b) {
            return a;
        } else {
            return b;
        }
    }
}
```

在实现类中，所有的方法都使用了 public 访问修饰符声明。无论何时实现一个由接口定义的方法，它都必须实现为 public，因为接口中的所有成员都显式声明为 public。

3）最后创建测试类 NumTest，实例化接口的实现类 MathClass，调用该类中的方法并输出结果。该类内容如下：

```java
public class NumTest {
    public static void main(String[] args) {
        // 创建实现类的对象
        MathClass calc = new MathClass(100, 300);
        System.out.println("100 和 300 相加结果是：" + calc.sum());
        System.out.println("100 比较 300，哪个大：" + calc.maxNum(100, 300));
    }
}
```

程序运行结果如下所示。

```
100 和 300 相加结果是：400
100 比较 300，哪个大：300
```

在该程序中，首先定义了一个 IMath 的接口，在该接口中只声明了两个未实现的方法，这两个方法需要在接口的实现类中实现。在实现类 MathClass 中定义了两个私有的属性，并赋予两个属性初始值，同时创建了该类的构造方法。因为该类实现了 MathClass 接口，因此必须实现接口中的方法。在最后的测试类中，需要创建实现类对象，然后通过实现类对象调用实现类中的方法。

###  Java抽象类和接口的联系和区别

前面《[Java接口](http://c.biancheng.net/view/6540.html)》一节中提到接口是一种特殊的抽象类，接口和抽象类的渊源颇深，有很大的相似之处，所以在选择使用谁的问题上很容易迷糊。本节我们先整理一下 [Java](http://c.biancheng.net/java/) 中抽象类和接口的特点，再分析它们具有的相同点、不同点和使用场景。

#### 1）抽象类

在 Java 中，被关键字 abstract 修饰的类称为抽象类；被 abstract 修饰的方法称为抽象方法，抽象方法只有方法声明没有方法体。

抽象类有以下几个特点：

1. 抽象类不能被实例化，只能被继承。
2. 包含抽象方法的类一定是抽象类，但抽象类不一定包含抽象方法（抽象类可以包含普通方法）。
3. 抽象方法的权限修饰符只能为 public、protected 或 default，默认情况下为 public。
4. 一个类继承于一个抽象类，则子类必须实现抽象类的抽象方法，如果子类没有实现父类的抽象方法，那子类必须定义为抽象类。
5. 抽象类可以包含属性、方法、构造方法，但构造方法不能用来实例化对象，只能被子类调用。

#### 2）接口

接口可以看成是一种特殊的类，只能用 interface 关键字修饰。

Java 中的接口具有以下几个特点：

1. 接口中可以包含变量和方法，变量被隐式指定为 public static final，方法被隐式指定为 public abstract（JDK 1.8 之前）。
2. 接口支持多继承，即一个接口可以继承（extends）多个接口，间接解决了 Java 中类不能多继承的问题。
3. 一个类可以同时实现多个接口，一个类实现某个接口则必须实现该接口中的抽象方法，否则该类必须被定义为抽象类。

#### 3）抽象类和接口的区别

接口和抽象类很像，它们都具有如下特征。

- 接口和抽象类都不能被实例化，主要用于被其他类实现和继承。
- 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。


但接口和抽象类之间的差别非常大，这种差别主要体现在二者设计目的上。下面具体分析二者的差别。

接口作为系统与外界交互的窗口，接口体现的是一种规范。对于接口的实现者而言，接口规定了实现者必须向外提供哪些服务（以方法的形式来提供）；对于接口的调用者而言，接口规定了调用者可以调用哪些服务，以及如何调用这些服务（就是如何来调用方法）。当在一个程序中使用接口时，接口是多个模块间的耦合标准；当在多个应用程序之间使用接口时，接口是多个程序之间的通信标准。

从某种程度上来看，接口类似于整个系统的“总纲”，它制定了系统各模块应该遵循的标准，因此一个系统中的接口不应该经常改变。一旦接口被改变，对整个系统甚至其他系统的影响将是辐射式的，会导致系统中大部分类都需要改写。

抽象类则不一样，抽象类作为系统中多个子类的共同父类，它所体现的是一种模板式设计。抽象类作为多个子类的抽象父类，可以被当成系统实现过程中的中间产品，这个中间产品已经实现了系统的部分功能（那些已经提供实现的方法），但这个产品依然不能当成最终产品，必须有更进一步的完善，这种完善可能有几种不同方式。

除此之外，接口和抽象类在用法上也存在差别，如下表所示：



| 参数               | 抽象类                                                       | 接口                                                         |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 实现               | 子类使用 extends 关键字来继承抽象类，如果子类不是抽象类，则需要提供抽象类中所有声明的方法的实现。 | 子类使用 implements 关键字来实现接口，需要提供接口中所有声明的方法的实现。 |
| 访问修饰符         | 可以用 public、protected 和 default 修饰                     | 默认修饰符是 public，不能使用其它修饰符                      |
| 方法               | 完全可以包含普通方法                                         | 只能包含抽象方法、静态方法、默认方法和私有方法，不能为普通方法提供方法实现 |
| 变量               | 既可以定义普通成员变量，也可以定义静态常量                   | 只能定义静态常量，不能定义普通成员变量                       |
| 构造方法           | 抽象类里的构造方法并不是用于创建对象，而是让其子类调用这些构造方法来完成属于抽象类的初始化操作 | 没有构造方法                                                 |
| 初始化块           | 可以包含初始化块                                             | 不能包含初始化块                                             |
| main 方法          | 可以有 main 方法，并且能运行                                 | 没有 main 方法                                               |
| 与普通Java类的区别 | 抽象类不能实例化，除此之外和普通 Java 类没有任何区别         | 是完全不同的类型                                             |
| 运行速度           | 比接口运行速度要快                                           | 需要时间去寻找在类种实现的方法，所以运行速度稍微有点慢       |


一个类最多只能有一个直接父类，包括抽象类，但一个类可以直接实现多个接口，通过实现多个接口可以弥补 Java 单继承的不足。

#### 4）抽象类和接口的应用场景

抽象类的应用场景：

1. 父类只知道其子类应该包含怎样的方法，不能准确知道这些子类如何实现这些方法的情况下，使用抽象类。
2. 从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。


接口的应用场景：

1. 一般情况下，实现类和它的抽象类之前具有 "is-a" 的关系，但是如果我们想达到同样的目的，但是又不存在这种关系时，使用接口。
2. 由于 Java 中单继承的特性，导致一个类只能继承一个类，但是可以实现一个或多个接口，此时可以使用接口。


什么时候使用抽象类和接口：

- 如果拥有一些方法并且想让它们有默认实现，则使用抽象类。
- 如果想实现多重继承，那么必须使用接口。因为 Java 不支持多继承，子类不能继承多个类，但可以实现多个接口，因此可以使用接口。
- 如果基本功能在不断改变，那么就需要使用抽象类。如果使用接口并不断需要改变基本功能，那么就需要改变所有实现了该接口的类。

### Java内部类是什么？

在类内部可定义成员变量和方法，且在类内部也可以定义另一个类。如果在类 Outer 的内部再定义一个类 Inner，此时类 Inner 就称为内部类（或称为嵌套类），而类 Outer 则称为外部类（或称为宿主类）。

内部类可以很好地实现隐藏，一般的非内部类是不允许有 private 与 protected 权限的，但内部类可以。内部类拥有外部类的所有元素的访问权限。

内部类可以分为：实例内部类、静态内部类和成员内部类，每种内部类都有它特定的一些特点，本节先详细介绍一些和内部类相关的知识。

在类 A 中定义类 B，那么类 B 就是内部类，也称为嵌套类，相对而言，类 A 就是外部类。如果有多层嵌套，例如类 A 中有内部类 B，而类 B 中还有内部类 C，那么通常将最外层的类称为顶层类（或者顶级类）。

内部类也可以分为多种形式，与变量非常类似，如图 1 所示。



![img](/Users/jiusonghuang/pic-md/20210716151011.jpeg)
图 1 内部类的分类


内部类的特点如下：

1. 内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的`.class`文件，但是前面冠以外部类的类名和`$`符号。
2. 内部类不能用普通的方式访问。内部类是外部类的一个成员，因此内部类可以自由地访问外部类的成员变量，无论是否为 private 的。
3. 内部类声明成静态的，就不能随便访问外部类的成员变量，仍然是只能访问外部类的静态成员变量。


**【例1】**内部类的使用方法非常简单，例如下面的代码演示了内部类最简单的应用。

```java
public class Test {
    public class InnerClass {
        public int getSum(int x,int y) {
            return x + y;
        }
    }
    public static void main(String[] args) {
        Test.InnerClass ti = new Test().new InnerClass();
        int i = ti.getSum(2,3);
        System.out.println(i);    // 输出5
    }
}
```

###  Java实例内部类

实例内部类是指没有用 static 修饰的内部类，有的地方也称为非静态内部类。示例代码如下：

```java
public class Outer {
    class Inner {
        // 实例内部类
    }
}
```

上述示例中的 Inner 类就是实例内部类。实例内部类有如下特点。

1）在外部类的静态方法和外部类以外的其他类中，必须通过外部类的实例创建内部类的实例。

```java
public class Outer {
    class Inner1 {
    }
    Inner1 i = new Inner1(); // 不需要创建外部类实例
    public void method1() {
        Inner1 i = new Inner1(); // 不需要创建外部类实例
    }
    public static void method2() {
        Inner1 i = new Outer().new inner1(); // 需要创建外部类实例
    }
    class Inner2 {
        Inner1 i = new Inner1(); // 不需要创建外部类实例
    }
}
class OtherClass {
    Outer.Inner i = new Outer().new Inner(); // 需要创建外部类实例
}
```

2）在实例内部类中，可以访问外部类的所有成员。

```java
public class Outer {
    public int a = 100;
    static int b = 100;
    final int c = 100;
    private int d = 100;
    public String method1() {
        return "实例方法1";
    }
    public static String method2() {
        return "静态方法2";
    }
    class Inner {
        int a2 = a + 1; // 访问public的a
        int b2 = b + 1; // 访问static的b
        int c2 = c + 1; // 访问final的c
        int d2 = d + 1; // 访问private的d
        String str1 = method1(); // 访问实例方法method1
        String str2 = method2(); // 访问静态方法method2
    }
    public static void main(String[] args) {
        Inner i = new Outer().new Inner(); // 创建内部类实例
        System.out.println(i.a2); // 输出101
        System.out.println(i.b2); // 输出101
        System.out.println(i.c2); // 输出101
        System.out.println(i.d2); // 输出101
        System.out.println(i.str1); // 输出实例方法1
        System.out.println(i.str2); // 输出静态方法2
    }
}
```

提示：如果有多层嵌套，则内部类可以访问所有外部类的成员。

3）在外部类中不能直接访问内部类的成员，而必须通过内部类的实例去访问。如果类 A 包含内部类 B，类 B 中包含内部类 C，则在类 A 中不能直接访问类 C，而应该通过类 B 的实例去访问类 C。

4）外部类实例与内部类实例是一对多的关系，也就是说一个内部类实例只对应一个外部类实例，而一个外部类实例则可以对应多个内部类实例。

如果实例内部类 B 与外部类 A 包含有同名的成员 t，则在类 B 中 t 和 this.t 都表示 B 中的成员 t，而 A.this.t 表示 A 中的成员 t。

```java
public class Outer {
    int a = 10;
    class Inner {
        int a = 20;
        int b1 = a;
        int b2 = this.a;
        int b3 = Outer.this.a;
    }
    public static void main(String[] args) {
        Inner i = new Outer().new Inner();
        System.out.println(i.b1); // 输出20
        System.out.println(i.b2); // 输出20
        System.out.println(i.b3); // 输出10
    }
}
```

5）在实例内部类中不能定义 static 成员，除非同时使用 final 和 static 修饰。

###  Java静态内部类

静态内部类是指使用 static 修饰的内部类。示例代码如下：

```java
public class Outer {
    static class Inner {
        // 静态内部类
    }
}
```

上述示例中的 Inner 类就是静态内部类。静态内部类有如下特点。

1）在创建静态内部类的实例时，不需要创建外部类的实例。

```java
public class Outer {
    static class Inner {
    }
}
class OtherClass {
    Outer.Inner oi = new Outer.Inner();
}
```

2）静态内部类中可以定义静态成员和实例成员。外部类以外的其他类需要通过完整的类名访问静态内部类中的静态成员，如果要访问静态内部类中的实例成员，则需要通过静态内部类的实例。

```java
public class Outer {
    static class Inner {
        int a = 0;    // 实例变量a
        static int b = 0;    // 静态变量 b
    }
}
class OtherClass {
    Outer.Inner oi = new Outer.Inner();
    int a2 = oi.a;    // 访问实例成员
    int b2 = Outer.Inner.b;    // 访问静态成员
}
```

3）静态内部类可以直接访问外部类的静态成员，如果要访问外部类的实例成员，则需要通过外部类的实例去访问。

```java
public class Outer {
    int a = 0;    // 实例变量
    static int b = 0;    // 静态变量
    static class Inner {
        Outer o = new Outer;
        int a2 = o.a;    // 访问实例变量
        int b2 = b;    // 访问静态变量
    }
}
```

### Java局部内部类

局部内部类是指在一个方法中定义的内部类。示例代码如下：

```java
public class Test {
    public void method() {
        class Inner {
            // 局部内部类
        }
    }
}
```

局部内部类有如下特点：

1）局部内部类与局部变量一样，不能使用访问控制修饰符（public、private 和 protected）和 static 修饰符修饰。

2）局部内部类只在当前方法中有效。

```java
public class Test {
    Inner i = new Inner();    // 编译出错
    Test.Inner ti = new Test.Inner();    // 编译出错
    Test.Inner ti2 = new Test().new Inner();    // 编译出错
    public void method() {
        class Inner{
        
        }
        Inner i = new Inner();
    }
}
```


3）局部内部类中不能定义 static 成员。

4）局部内部类中还可以包含内部类，但是这些内部类也不能使用访问控制修饰符（public、private 和 protected）和 static 修饰符修饰。

5）在局部内部类中可以访问外部类的所有成员。

6）在局部内部类中只可以访问当前方法中 final 类型的参数与变量。如果方法中的成员与外部类中的成员同名，则可以使用 <OuterClassName>.this.<MemberName> 的形式访问外部类中的成员。

```java
public class Test {
    int a = 0;
    int d = 0;
    public void method() {
        int b = 0;
        final int c = 0;
        final int d = 10;
        class Inner {
            int a2 = a;    // 访问外部类中的成员
            // int b2 = b;    // 编译出错
            int c2 = c;    // 访问方法中的成员
            int d2 = d;    // 访问方法中的成员
            int d3 = Test.this.d;    //访问外部类中的成员
        }
        Inner i = new Inner();
        System.out.println(i.d2);    // 输出10
        System.out.println(i.d3);    // 输出0
    }
    public static void main(String[] args) {
        Test t = new Test();
        t.method();
    }
}
```

### Java匿名类，Java匿名内部类

匿名类是指没有类名的内部类，必须在创建时使用 new 语句来声明类。其语法形式如下：

```java
new <类或接口>() {    
// 类的主体
};
```

这种形式的 new 语句声明一个新的匿名类，它对一个给定的类进行扩展，或者实现一个给定的接口。使用匿名类可使代码更加简洁、紧凑，模块化程度更高。

匿名类有两种实现方式：

- 继承一个类，重写其方法。
- 实现一个接口（可以是多个），实现其方法。


下面通过代码来说明。

```java
public class Out {
    void show() {
        System.out.println("调用 Out 类的 show() 方法");
    }
}
public class TestAnonymousInterClass {
    // 在这个方法中构造一个匿名内部类
    private void show() {
        Out anonyInter = new Out() {
            // 获取匿名内部类的实例
            void show() {
                System.out.println("调用匿名类中的 show() 方法");
            }
        };
        anonyInter.show();
    }
    public static void main(String[] args) {
        TestAnonymousInterClass test = new TestAnonymousInterClass();
        test.show();
    }
}
```

程序的输出结果如下：

```
调用匿名类中的 show() 方法
```

从输出结果可以看出，匿名内部类有自己的实现。

提示：匿名内部类实现一个接口的方式与实现一个类的方式相同，这里不再赘述。

匿名类有如下特点：

1）匿名类和局部内部类一样，可以访问外部类的所有成员。如果匿名类位于一个方法中，则匿名类只能访问方法中 final 类型的局部变量和参数。

```java
public static void main(String[] args) {
    int a = 10;
    final int b = 10;
    Out anonyInter = new Out() {
        void show() {
            // System.out.println("调用了匿名类的 show() 方法"+a);    // 编译出错
            System.out.println("调用了匿名类的 show() 方法"+b);    // 编译通过
        }
    };
    anonyInter.show();
}
```

> 从 [Java](http://c.biancheng.net/java/) 8 开始添加了 Effectively final 功能，在 Java 8 及以后的版本中代码第 6 行不会出现编译错误，详情可点击《[Java8新特性之Effectively final](http://c.biancheng.net/view/6564.html)》进行学习。

2）匿名类中允许使用非静态代码块进行成员初始化操作。

```java
Out anonyInter = new Out() {
    int i; {    // 非静态代码块
        i = 10;    //成员初始化
    }
    public void show() {
        System.out.println("调用了匿名类的 show() 方法"+i);
    }
};
```

3）匿名类的非静态代码块会在父类的构造方法之后被执行。



### Java利用内部类实现多重继承

多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征，然而我们知道 [Java](http://c.biancheng.net/java/) 为了保证数据安全，只允许单继承。

有些时候我们会认为如果系统中需要使用多重继承，那往往都是糟糕的设想，这时开发人员往往需要思考的不是怎么使用多重继承，而是他的设计是否存在问题。但是，有时候开发人员确实需要实现多重继承，而且现实生活中真正地存在这样的情况，例如遗传，我们既继承了父亲的行为和特征，也继承了母亲的行为和特征。

Java 提供的两种方法让我们实现多重继承：接口和内部类。

本节我们以生活中常见的遗传例子进行介绍，如儿子（或者女儿）是如何利用多重继承来继承父亲和母亲的优良基因的。

1）创建 Father 类，在该类中添加 strong() 方法。代码如下：

```java
public class Father {
    public int strong() {   
        // 强壮指数
        return 9;
    }
}
```


2）创建 Mother 类，在该类中添加 kind() 方法。代码如下：

```java
public class Mother {
    public int kind() {    
        // 友好指数
        return 8;
    }
}
```

3）重点在于儿子类的实现，创建 Son 类，在该类中通过内部类实现多重继承。代码如下：

```java
public class Son {
    // 内部类继承Father类
    class Father_1 extends Father {
        public int strong() {
            return super.strong() + 1;
        }
    }
    class Mother_1 extends Mother {
        public int kind() {
            return super.kind() - 2;
        }
    }
    public int getStrong() {
        return new Father_1().strong();
    }
    public int getKind() {
        return new Mother_1().kind();
   
```

上述代码定义两个内部类，这两个内部类分别继承 Father（父亲）类和 Mother（母亲）类，且都可以获取各自父类的行为。这是内部类一个很重要的特性：内部类可以继承一个与外部类无关的类，从而保证内部类的独立性。正是基于这一点，多重继承才会成为可能。

4）创建 Test 类进行测试，在 main() 方法中实例化 Son 类的对象，然后分别调用该对象的 getStrong() 方法和 getKind() 方法。代码如下：

```java
public class Test {
    public static void main(String[] args) {
        Son son = new Son();
        System.out.println("Son 的强壮指数：" + son.getStrong());
        System.out.println("Son 的友好指数：" + son.getKind());
    }
}
```

执行上述代码，输出结果如下：

```
Son 的强壮指数：10
Son 的友好指数：6
```

从实现代码和输出结果可以发现，儿子继承父类，变得比父亲更加强壮；同时也继承了母类，只不过友好指数下降。

###  Java8新特性：Effectively final

[Java](http://c.biancheng.net/java/) 中局部内部类和匿名内部类访问的局部变量必须由 final 修饰，以保证内部类和外部类的数据一致性。但从 Java 8 开始，我们可以不加 final 修饰符，由系统默认添加，当然这在 Java 8 以前的版本是不允许的。Java 将这个功能称为 Effectively final 功能。

编写同样的代码，分别在 Java 7 和 Java 8 下运行，代码如下：

```java
public class Test {
    public static void main(String[] args) {
        String name = "C语言中文网";
        new Runnable() {
            @Override
            public void run() {
                System.out.println(name);
            }
        }
    }
}
```

图 1 是 Java 7 编译结果，图 2 和图 3 是 Java 8 编译结果。



![Java 7 运行结果](/Users/jiusonghuang/pic-md/20211025233110.png)
图 1


可以看到在 Java 7（图 1）中出现代码错误，提示我们必须显式的声明这个变量为 final 的run 方法中代码为输出 name 语句，即`System.out.println(name);`）。

![img](/Users/jiusonghuang/pic-md/20211025233119.png)
图 2 

![img](/Users/jiusonghuang/pic-md/20211025233127.png)
图 3


因为系统会默认添加 final 修饰符，所以在图 2 和图 3 中可以在匿名内部类中直接使用非 final 变量，而 final 修饰的局部变量不能在被重新赋值，所以图 3 中出现编译错误。也就是说从 Java 8 开始，它不要求程序员必须将访问的局部变量显式的声明为 final 的。只要该变量不被重新赋值就可以。

一个非 final 的局部变量或方法参数，其值在初始化后就从未更改，那么该变量就是 effectively final。在 Lambda 表达式中，使用局部变量的时候，也要求该变量必须是 final 的，所以 effectively final 在 Lambda 表达式上下文中非常有用。

Lambda 表达式在编程中是经常使用的，而匿名内部类是很少使用的。那么，我们在 Lambda 编程中每一个被使用到的局部变量都去显示定义成 final 吗？显然这不是一个好方法。所以，Java 8 引入了 effectively final 新概念。

总结一下，规则没有改变，Lambda表达式和匿名内部类访问的局部变量必须是 final 的，只是不需要程序员显式的声明变量为 final 的，从而节省时间。

## 4、异常处理

### Java异常（Exception）处理及常见异常

很多事件并非总是按照人们自己设计意愿顺利发展的，经常出现这样那样的异常情况。例如： 你计划周末郊游，计划从家里出发→到达目的→游泳→烧烤→回家。但天有不测风云，当你准备烧烤时候突然天降大雨，只能终止郊游提前回家。“天降大雨”是一种异常情况，你的计划应该考虑到这样的情况，并且应该有处理这种异常的预案。

计算机程序的编写也需要考虑处理这些异常情况。异常（exception）是在运行程序时产生的一种异常情况，已经成为了衡量一门语言是否成熟的标准之一。目前的主流编程语言，如 [C++](http://c.biancheng.net/cplus/)、c#、Ruby 和 [Python](http://c.biancheng.net/python/) 等大都提供了异常处理机制。

#####  异常简介

[Java](http://c.biancheng.net/java/) 中的异常又称为例外，是一个在程序执行期间发生的事件，它中断正在执行程序的正常指令流。为了能够及时有效地处理程序中的运行错误，必须使用异常类，这可以让程序具有极好的容错性且更加健壮。 

在 Java 中一个异常的产生，主要有如下三种原因：

1. Java 内部错误发生异常，Java 虚拟机产生的异常。
2. 编写的程序代码中的错误所产生的异常，例如空指针异常、数组越界异常等。
3. 通过 throw 语句手动生成的异常，一般用来告知该方法的调用者一些必要信息。


Java 通过面向对象的方法来处理异常。在一个方法的运行过程中，如果发生了异常，则这个方法会产生代表该异常的一个对象，并把它交给运行时的系统，运行时系统寻找相应的代码来处理这一异常。

我们把生成异常对象，并把它提交给运行时系统的过程称为拋出（throw）异常。运行时系统在方法的调用栈中查找，直到找到能够处理该类型异常的对象，这一个过程称为捕获（catch）异常。

为了更好地理解什么是异常，下面来看一段非常简单的 Java 程序。下面的示例代码实现了允许用户输入 1~3 以内的整数，其他情况提示输入错误。

```java
import java.util.Scanner;
public class Test01 {
    public static void main(String[] args) {
        System.out.println("请输入您的选择：（1~3 之间的整数）");
        Scanner input = new Scanner(System.in);
        int num = input.nextInt();
        switch (num) {
        case 1:
            System.out.println("one");
            break;
        case 2:
            System.out.println("two");
            break;
        case 3:
            System.out.println("three");
            break;
        default:
            System.out.println("error");
            break;
        }
    }
}
```


正常情况下，用户会按照系统的提示输入 1~3 之间的数字。但是，如果用户没有按要求进行输入，例如输入了一个字母“a”，则程序在运行时将会发生异常，运行结果如下所示。

```
请输入您的选择：（1~3 之间的整数）
a
Exception in thread "main" java.util.InputMismatchException
        at java.util.Scanner.throwFor(Unknown Source)
        at java.util.Scanner.next(Unknown Source)
        at java.util.Scanner.nextInt(Unknown Source)
        at java.util.Scanner.nextInt(Unknown Source)
        at text.text.main(text.java:11)
```

##### 异常类型

为了能够及时有效地处理程序中的运行错误，Java 专门引入了异常类。**在 Java 中所有异常类型都是内置类 java.lang.Throwable 类的子类，**即 Throwable 位于异常类层次结构的顶层。Throwable 类下有两个异常分支 Exception 和 Error，如图 1 所示。



![img](/Users/jiusonghuang/pic-md/20211026235240.jpg)

​																							图 1 异常结构图


由图 2 可以知道，Throwable 类是所有异常和错误的超类，下面有 Error 和 Exception 两个子类分别表示错误和异常。其中异常类 Exception 又分为运行时异常和非运行时异常，这两种异常有很大的区别，也称为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。

- Exception 类用于用户程序可能出现的异常情况，它也是用来创建自定义异常类型类的类。
- Error 定义了在通常环境下不希望被程序捕获的异常。一般指的是 JVM 错误，如堆栈溢出。


本节不讨论关于 Error 类型的异常处理，因为它们通常是灾难性的致命错误，不是程序可以控制的。接下来将讨论 Exception 类型的异常处理。

运行时异常都是 RuntimeException 类及其子类异常，如 NullPointerException、IndexOutOfBoundsException 等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般由程序逻辑错误引起，程序应该从逻辑角度尽可能避免这类异常的发生。

非运行时异常是指 RuntimeException 以外的异常，类型上都属于 Exception 类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如 IOException、ClassNotFoundException 等以及用户自定义的 Exception 异常（一般情况下不自定义检查异常）。

表 1 和表 2 分别列出了 java.lang 中定义的运行时异常和非运行时异常的类型及作用。

表 1 Java中常见运行时异常

| 异常类型                      | 说明                                                  |
| ----------------------------- | ----------------------------------------------------- |
| ArithmeticException           | 算术错误异常，如以零做除数                            |
| ArraylndexOutOfBoundException | 数组索引越界                                          |
| ArrayStoreException           | 向类型不兼容的数组元素赋值                            |
| ClassCastException            | 类型转换异常                                          |
| IllegalArgumentException      | 使用非法实参调用方法                                  |
| lIIegalStateException         | 环境或应用程序处于不正确的状态                        |
| lIIegalThreadStateException   | 被请求的操作与当前线程状态不兼容                      |
| IndexOutOfBoundsException     | 某种类型的索引越界                                    |
| NullPointerException          | 尝试访问 null 对象成员，空指针异常                    |
| NegativeArraySizeException    | 再负数范围内创建的数组                                |
| NumberFormatException         | 数字转化格式异常，比如字符串到 float 型数字的转换无效 |
| TypeNotPresentException       | 类型未找到                                            |

表 2 Java常见非运行时异常

| 异常类型                     | 说明                       |
| ---------------------------- | -------------------------- |
| ClassNotFoundException       | 没有找到类                 |
| IllegalAccessException       | 访问类被拒绝               |
| InstantiationException       | 试图创建抽象类或接口的对象 |
| InterruptedException         | 线程被另一个线程中断       |
| NoSuchFieldException         | 请求的域不存在             |
| NoSuchMethodException        | 请求的方法不存在           |
| ReflectiveOperationException | 与反射有关的异常的超类     |

###  Java中Error和Exception的异同

Error（错误）和 Exception（异常）都是 java.lang.Throwable 类的子类，在 [Java](http://c.biancheng.net/java/) 代码中只有继承了 Throwable 类的实例才能被 throw 或者 catch。

**Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类，Exception 是程序正常运行过程中可以预料到的意外情况，并且应该被开发者捕获，进行相应的处理。Error 是指正常情况下不大可能出现的情况，绝大部分的 Error 都会导致程序处于非正常、不可恢复状态。所以不需要被开发者捕获。**

**Error 错误是任何处理技术都无法恢复的情况，肯定会导致程序非正常终止。并且 Error 错误属于未检查类型，大多数发生在运行时。Exception 又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源码里必须显示的进行捕获处理，这里是编译期检查的一部分。不检查异常就是所谓的运行时异常，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译器强制要求.**

如下是常见的 Error 和 Exception：

1）运行时异常（RuntimeException）：

- NullPropagation：空指针异常；
- ClassCastException：类型强制转换异常
- IllegalArgumentException：传递非法参数异常
- IndexOutOfBoundsException：下标越界异常
- NumberFormatException：数字格式异常


2）非运行时异常：

- ClassNotFoundException：找不到指定 class 的异常
- IOException：IO 操作异常


3）错误（Error）：

- NoClassDefFoundError：找不到 class 定义异常
- StackOverflowError：深递归导致栈被耗尽而抛出的异常
- OutOfMemoryError：内存溢出异常

#### 例 1

下面代码会导致 Java 堆栈溢出错误。

```java
// 通过无限递归演示堆栈溢出错误
class StackOverflow {
    public static void test(int i) {
        if (i == 0) {
            return;
        } else {
            test(i++);
        }
    }
}
public class ErrorEg {
    public static void main(String[] args) {
        // 执行StackOverflow方法
        StackOverflow.test(5);
    }
}
```

运行输出为：

Exception in thread "main" java.lang.StackOverflowError
  at ch11.StackOverflow.test(ErrorEg.java:9)
  at ch11.StackOverflow.test(ErrorEg.java:9)
  at ch11.StackOverflow.test(ErrorEg.java:9)
  at ch11.StackOverflow.test(ErrorEg.java:9)

上面代码通过无限递归调用最终引发了 java.lang.StackOverflowError 错误。

###  Java异常处理机制及异常处理的基本结构

前面介绍了异常的产生是不可避免的，那么为了保证程序有效地执行，需要对发生的异常进行相应的处理。

[Java](http://c.biancheng.net/java/) 的异常处理通过 5 个关键字来实现：try、catch、throw、throws 和 finally。try catch 语句用于捕获并处理异常，finally 语句用于在任何情况下（除特殊情况外）都必须执行的代码，throw 语句用于拋出异常，throws 语句用于声明可能会出现的异常。

本节先主要介绍异常处理的机制及基本的语句结构。

Java 的异常处理机制提供了一种结构性和控制性的方式来处理程序执行期间发生的事件。异常处理的机制如下：

- 在方法中用 try catch 语句捕获并处理异常，catch 语句可以有多个，用来匹配多个异常。
- **对于处理不了的异常或者要转型的异常，在方法的声明处通过 throws 语句拋出异常，即由上层的调用方法来处理。**


以下代码是异常处理程序的基本结构：

```java
try {
    逻辑程序块
} catch(ExceptionType1 e) {
    处理代码块1
} catch (ExceptionType2 e) {
    处理代码块2
    throw(e);    // 再抛出这个"异常"
} finally {
    释放资源代码块
}
```

### Java try catch语句详解

在实际应用中，对于错误的处理是极其重要的，任何程序都很难做到百分百完美，程序中可能存在大量未知问题，所以程序开发时一定要对各种问题进行相应的处理，而 [Java](http://c.biancheng.net/java/) 提供的异常处理机制可以帮用户更好地解决这方面的问题。Java 的异常处理机制可以让程序具有极好的容错性，让程序更加健壮。

Java 的异常处理通过 5 个关键字来实现：try、catch、throw、throws 和 finally。try catch 语句用于捕获并处理异常，finally 语句用于在任何情况下（除特殊情况外）都必须执行的代码，throw 语句用于拋出异常，throws 语句用于声明可能会出现的异常。

本节先主要介绍 Java 中的 try catch 语句。在 Java 中通常采用 try catch 语句来捕获异常并处理。语法格式如下：

```java
try {    // 可能发生异常的语句} catch(ExceptionType e) {    // 处理异常语句}
```

在以上语法中，把可能引发异常的语句封装在 try 语句块中，用以捕获可能发生的异常。catch 后的`( )`里放匹配的异常类，指明 catch 语句可以处理的异常类型，发生异常时产生异常类的实例化对象。

如果 try 语句块中发生异常，那么一个相应的异常对象就会被拋出，然后 catch 语句就会依据所拋出异常对象的类型进行捕获，并处理。处理之后，程序会跳过 try 语句块中剩余的语句，转到 catch 语句块后面的第一条语句开始执行。

如果 try 语句块中没有异常发生，那么 try 块正常结束，后面的 catch 语句块被跳过，程序将从 catch 语句块后的第一条语句开始执行。



注意：try...catch 与 if...else 不一样，try 后面的花括号`{ }`不可以省略，即使 try 块里只有一行代码，也不可省略这个花括号。与之类似的是，catch 块后的花括号`{ }`也不可以省略。另外，try 块里声明的变量只是代码块内的局部变量，它只在 try 块内有效，其它地方不能访问该变量。


在上面语法的处理代码块 1 中，可以使用以下 3 个方法输出相应的异常信息。

- printStackTrace() 方法：指出异常的类型、性质、栈层次及出现在程序中的位置（关于 printStackTrace 方法的使用可参考《[Java的异常跟踪栈](http://c.biancheng.net/view/6657.html)》一节）。
- getMessage() 方法：输出错误的性质。
- toString() 方法：给出异常的类型与性质。

#### 例 1

编写一个录入学生姓名、年龄和性别的程序，要求能捕捉年龄不为数字时的异常。在这里使用 try catch 语句来实现，具体代码如下：

```java
import java.util.Scanner;
public class Test02 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("---------学生信息录入---------------");
        String name = ""; // 获取学生姓名
        int age = 0; // 获取学生年龄
        String sex = ""; // 获取学生性别
        try {
            System.out.println("请输入学生姓名：");
            name = scanner.next();
            System.out.println("请输入学生年龄：");
            age = scanner.nextInt();
            System.out.println("请输入学生性别：");
            sex = scanner.next();
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("输入有误！");
        }
        System.out.println("姓名：" + name);
        System.out.println("年龄：" + age);
    }
}
```

上述代码在 main() 方法中使用 try catch 语句来捕获异常，将可能发生异常的`age = scanner.nextlnt();`代码放在了 try 块中，在 catch 语句中指定捕获的异常类型为 Exception，并调用异常对象的 printStackTrace() 方法输出异常信息。运行结果如下所示。

```
---------学生信息录入---------------
请输入学生姓名：
徐白
请输入学生年龄：
110a
java.util.InputMismatchException
    at java.util.Scanner.throwFor(Unknown Source)
    at java.util.Scanner.next(Unknown Source)
    at java.util.Scanner.nextInt(Unknown Source)
    at java.util.Scanner.nextInt(Unknown Source)
输入有误！
姓名：徐白
年龄：0
    at text.text.main(text.java:19)
```

##### 多重catch语句

如果 try 代码块中有很多语句会发生异常，而且发生的异常种类又很多。那么可以在 try 后面跟有多个 catch 代码块。多 catch 代码块语法如下：

```java
try {
    // 可能会发生异常的语句
} catch(ExceptionType e) {
    // 处理异常语句
} catch(ExceptionType e) {
    // 处理异常语句
} catch(ExceptionType e) {
    // 处理异常语句
...
}
```

在多个 catch 代码块的情况下，当一个 catch 代码块捕获到一个异常时，其它的 catch 代码块就不再进行匹配。

注意：当捕获的多个异常类之间存在父子关系时，捕获异常时一般先捕获子类，再捕获父类。所以子类异常必须在父类异常的前面，否则子类捕获不到。

#### 例 2

```java
public class Test03 {
    public static void main(String[] args) {
        Date date = readDate();
        System.out.println("读取的日期 = " + date);
    }
    public static Date readDate() {
        FileInputStream readfile = null;
        InputStreamReader ir = null;
        BufferedReader in = null;
        try {
            readfile = new FileInputStream("readme.txt");
            ir = new InputStreamReader(readfile);
            in = new BufferedReader(ir);
            // 读取文件中的一行数据
            String str = in.readLine();
            if (str == null) {
                return null;
            }
            DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
            Date date = df.parse(str);
            return date;
        } catch (FileNotFoundException e) {
            System.out.println("处理FileNotFoundException...");
            e.printStackTrace();
        } catch (IOException e) {
            System.out.println("处理IOException...");
            e.printStackTrace();
        } catch (ParseException e) {
            System.out.println("处理ParseException...");
            e.printStackTrace();
        }
        return null;
    }
}
```

上述代码通过 Java I/O（输入输出）流技术从文件 readme.txt 中读取字符串，然后解析成为日期。由于 Java I/O 技术还没有介绍，大家先不要关注 I/O 技术细节，只看调用它们时方法会发生的异常就可以了。

在 try 代码块中第 12 行代码调用 FileInputStream 构造方法可能会发生 FileNotFoundException 异常。第 16 行代码调用 BufferedReader 输入流的 readLine() 方法可能会发生 IOException 异常。FileNotFoundException 异常是 IOException 异常的子类，应该先捕获 FileNotFoundException 异常，见代码第 23 行；后捕获 IOException 异常，见代码第 26 行。

如果将 FileNotFoundException 和 IOException 捕获顺序调换，那么捕获 FileNotFoundException 异常代码块将永远不会进入，FileNotFoundException 异常处理永远不会执行。 上述代码第 29 行 ParseException 异常与 IOException 和 FileNotFoundException 异常没有父子关系，所以捕获 ParseException 异常位置可以随意放置。

### Java try catch finally语句

在实际开发中，根据 try catch 语句的执行过程，try 语句块和 catch 语句块有可能不被完全执行，而有些处理代码则要求必须执行。例如，程序在 try 块里打开了一些物理资源（如数据库连接、网络连接和磁盘文件等），这些物理资源都必须显式回收。

> [Java](http://c.biancheng.net/java/)的垃圾回收机制不会回收任何物理资源，垃圾回收机制只回收堆内存中对象所占用的内存。

所以为了确保一定能回收 try 块中打开的物理资源，异常处理机制提供了 finally 代码块，并且 Java 7 之后提供了自动资源管理（Automatic Resource Management）技术。

finally 语句可以与前面介绍的 [try catch](http://c-local.biancheng.net/view/6732.html) 语句块匹配使用，语法格式如下：

```java
try {
    // 可能会发生异常的语句
} catch(ExceptionType e) {
    // 处理异常语句
} finally {
    // 清理代码块
}
```

对于以上格式，无论是否发生异常（除特殊情况外），finally 语句块中的代码都会被执行。此外，finally 语句也可以和 try 语句匹配使用，其语法格式如下：

```java
try {
    // 逻辑代码块
} finally {
    // 清理代码块
}
```

使用 try-catch-finally 语句时需注意以下几点：

1. 异常处理语法结构中只有 try 块是必需的，也就是说，如果没有 try 块，则不能有后面的 catch 块和 finally 块；
2. catch 块和 finally 块都是可选的，但 catch 块和 finally 块至少出现其中之一，也可以同时出现；
3. 可以有多个 catch 块，捕获父类异常的 catch 块必须位于捕获子类异常的后面；
4. 不能只有 try 块，既没有 catch 块，也没有 finally 块；
5. 多个 catch 块必须位于 try 块之后，finally 块必须位于所有的 catch 块之后。
6. finally 与 try 语句块匹配的语法格式，此种情况会导致异常丢失，所以不常见。


一般情况下，无论是否有异常拋出，都会执行 finally 语句块中的语句，执行流程如图 1 所示。



![img](/Users/jiusonghuang/pic-md/20211027001226.jpg)
   															图 1 try catch finally 语句执行流程图


try catch finally 语句块的执行情况可以细分为以下 3 种情况：

1. 如果 try 代码块中没有拋出异常，则执行完 try 代码块之后直接执行 finally 代码块，然后执行 try catch finally 语句块之后的语句。
2. 如果 try 代码块中拋出异常，并被 catch 子句捕捉，那么在拋出异常的地方终止 try 代码块的执行，转而执行相匹配的 catch 代码块，之后执行 finally 代码块。如果 finally 代码块中没有拋出异常，则继续执行 try catch finally 语句块之后的语句；如果 finally 代码块中拋出异常，则把该异常传递给该方法的调用者。
3. 如果 try 代码块中拋出的异常没有被任何 catch 子句捕捉到，那么将直接执行 finally 代码块中的语句，并把该异常传递给该方法的调用者。


除非在 try 块、catch 块中调用了退出虚拟机的方法`System.exit(int status)`，否则不管在 try 块或者 catch 块中执行怎样的代码，出现怎样的情况，异常处理的 finally 块总会执行。

通常情况下不在 finally 代码块中使用 return 或 throw 等导致方法终止的语句，否则将会导致 try 和 catch 代码块中的 return 和 throw 语句失效，详细讲解可参考《[Java中finally与return的执行顺序](http://c.biancheng.net/view/vip_7075.html)》一节。

#### 例 1

当 Windows 系统启动之后，即使不作任何操作，在关机时都会显示“谢谢使用”。下面编写 Java 程序使用 try catch finally 语句这个过程，具体代码如下：

```java
import java.util.Scanner;
public class Test04 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.println("Windows 系统已启动！");
        String[] pros = { "记事本", "计算器", "浏览器" };
        try {
            // 循环输出pros数组中的元素
            for (int i = 0; i < pros.length; i++) {
                System.out.println(i + 1 + "：" + pros[i]);
            }
            System.out.println("是否运行程序：");
            String answer = input.next();
            if (answer.equals("y")) {
                System.out.println("请输入程序编号：");
                int no = input.nextInt();
                System.out.println("正在运行程序[" + pros[no - 1] + "]");
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            System.out.println("谢谢使用!");
        }
    }
}
```

上述代码在 main() 方法中使用 try catch finally 语句模拟了系统的使用过程。当系统启动之后显示提示语，无论是否运行了程序，或者在运行程序时出现了意外，程序都将执行 finally 块中的语句，即显示“谢谢使用！”。输出时的结果如下所示。

```
Windows 系统已启动！
1：记事本
2：计算器
3：浏览器
是否运行程序：
y
请输入程序编号：
2
正在运行程序[计算器]
谢谢使用!
Windows 系统已启动！
1：记事本
2：计算器
3：浏览器
是否运行程序：
y
请输入程序编号：
5
谢谢使用!
java.lang.ArrayIndexOutOfBoundsException: 4
    at text.text.main(text.java:23)
Windows 系统已启动！
1：记事本
2：计算器
3：浏览器
是否运行程序：
asdfasd
谢谢使用!
```

### Java finally和return的执行顺序（非常重要）

### Java 9增强的自动资源管理

在学习《[Java try catch finally语句](http://c.biancheng.net/view/1046.html)》一节后我们可以发现，当程序使用 finally 块关闭资源时，程序会显得异常臃肿，例如以下代码。

```java
public static void main(String[] args) {
    FileInputStream fis = null;
    try {
        fis = new FileInputStream("a.txt");
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } finally {
        // 关闭磁盘文件，回收资源
        if (fis != null) {
            try {
                fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

[Java](http://c.biancheng.net/java/) 7 以前，上面程序中的 finally 代码块是不得不写的“臃肿代码”，为了解决这种问题，Java 7 增加了一个新特性，该特性提供了另外一种管理资源的方式，这种方式能自动关闭文件，被称为自动资源管理（Automatic Resource Management）。该特性是在 try 语句上的扩展，主要释放不再需要的文件或其他资源。

自动资源管理替代了 finally 代码块，并优化了代码结构和提高程序可读性。语法如下：

```java
try (声明或初始化资源语句) {
    // 可能会生成异常语句
} catch(Throwable e1){
    // 处理异常e1
} catch(Throwable e2){
    // 处理异常e1
} catch(Throwable eN){
    // 处理异常eN
}
```

当 try 代码块结束时，自动释放资源。不再需要显式的调用 close() 方法，该形式也称为“带资源的 try 语句”。

注意：

1. try 语句中声明的资源被隐式声明为 final，资源的作用局限于带资源的 try 语句。
2. 可以在一条 try 语句中声明或初始化多个资源，每个资源以`;`隔开即可。
3. 需要关闭的资源必须实现了 AutoCloseable 或 Closeable 接口。

```
Closeable 是 AutoCloseable 的子接口，Closeable 接口里的 close() 方法声明抛出了 IOException，因此它的实现类在实现 close() 方法时只能声明抛出 IOException 或其子类；AutoCloseable 接口里的 close() 方法声明抛出了 Exc
```

eption，因此它的实现类在实现 close() 方法时可以声明抛出任何异常。

下面示范如何使用自动关闭资源的 try 语句。

```java
public class AutoCloseTest {
    public static void main(String[] args) throws IOException {
        try (
                // 声明、初始化两个可关闭的资源
                // try语句会自动关闭这两个资源
                BufferedReader br = new BufferedReader(new FileReader("AutoCloseTest.java"));
                PrintStream ps = new PrintStream(new FileOutputStream("a.txt"))) {
            // 使用两个资源
            System.out.println(br.readLine());
            ps.println("C语言中文网");
        }
    }
}
```

上面程序中粗体字代码分别声明、初始化了两个 IO 流，BufferedReader 和 PrintStream 都实现了 Closeable 接口，并在 try 语句中进行了声明和初始化，所以 try 语句会自动关闭它们。

自动关闭资源的 try 语句相当于包含了隐式的 finally 块（这个 finally 块用于关闭资源），因此这个 try 语句可以既没有 catch 块，也没有 finally 块。

```
Java 7 几乎把所有的“资源类”（包括文件 IO 的各种类、JDBC 编程的 Connection 和 Statement 等接口）进行了改写，改写后的资源类都实现了 AutoCloseable 或 Closeable 接口。
```

如果程序需要，自动关闭资源的 try 语句后也可以带多个 catch 块和一个 finally 块。

Java 9 再次增强了这种 try 语句。Java 9 不要求在 try 后的圆括号内声明并创建资源**，只需要自动关闭的资源有 final 修饰或者是有效的 final (effectively final)，**Java 9 允许将资源变量放在 try 后的圆括号内。上面程序在 Java 9 中可改写为如下形式。

```java
public class AutoCloseTest {
    public static void main(String[] args) throws IOException {
        // 有final修饰的资源
        final BufferedReader br = new BufferedReader(new FileReader("AutoCloseTest.java"));
        // 没有显式使用final修饰，但只要不对该变量重新赋值，该变量就是有效的
        final PrintStream ps = new PrintStream(new FileOutputStream("a. txt"));
        // 只要将两个资源放在try后的圆括号内即可
        try (br; ps) {
            // 使用两个资源
            System.out.println(br.readLine());
            ps.println("C语言中文网");
        }
    }
}
```

### Java throws和throw：声明和抛出异常

[Java](http://c.biancheng.net/java/) 中的异常处理除了捕获异常和处理异常之外，还包括声明异常和拋出异常。实现声明和抛出异常的关键字非常相似，它们是 throws 和 throw。**可以通过 throws 关键字在方法上声明该方法要拋出的异常，然后在方法内部通过 throw 拋出异常对象。**本节详细介绍在 Java 中如何声明异常和拋出异常。

#### throws 声明异常

当一个方法产生一个它不处理的异常时，那么就需要在该方法的头部声明这个异常，以便将该异常传递到方法的外部进行处理。使用 throws 声明的方法表示此方法不处理异常。throws 具体格式如下：

```java
returnType method_name(paramList) throws Exception 1,Exception2,…{…}
```

其中，returnType 表示返回值类型；method_name 表示方法名；paramList 表示参数列表；Exception 1，Exception2，… 表示异常类。

如果有多个异常类，它们之间用逗号分隔。这些异常类可以是方法中调用了可能拋出异常的方法而产生的异常，也可以是方法体中生成并拋出的异常。

使用 throws 声明抛出异常的思路是，当前方法不知道如何处理这种类型的异常，该异常应该由向上一级的调用者处理；如果 main 方法也不知道如何处理这种类型的异常，也可以使用 throws 声明抛出异常，该异常将交给 JVM 处理。JVM 对异常的处理方法是，打印异常的跟踪栈信息，并中止程序运行，这就是前面程序在遇到异常后自动结束的原因。

#### 例 1

创建一个 readFile() 方法，该方法用于读取文件内容，在读取的过程中可能会产生 IOException 异常，但是在该方法中不做任何的处理，而将可能发生的异常交给调用者处理。在 main() 方法中使用 try catch 捕获异常，并输出异常信息。代码如下：

```java
import java.io.FileInputStream;
import java.io.IOException;
public class Test04 {
    public void readFile() throws IOException {
        // 定义方法时声明异常
        FileInputStream file = new FileInputStream("read.txt"); // 创建 FileInputStream 实例对象
        int f;
        while ((f = file.read()) != -1) {
            System.out.println((char) f);
            f = file.read();
        }
        file.close();
    }
    public static void main(String[] args) {
        Throws t = new Test04();
        try {
            t.readFile(); // 调用 readFHe()方法
        } catch (IOException e) {
            // 捕获异常
            System.out.println(e);
        }
    }
}
```

以上代码，首先在定义 readFile() 方法时用 throws 关键字声明在该方法中可能产生的异常，然后在 main() 方法中调用 readFile() 方法，并使用 catch 语句捕获产生的异常。

#### 方法重写时声明抛出异常的限制

使用 throws 声明抛出异常时有一个限制，是方法重写中的一条规则：子类方法声明抛出的异常类型应该是父类方法声明抛出的异常类型的子类或相同，**子类方法声明抛出的异常不允许比父类方法声明抛出的异常多**。看如下程序。

```java
public class OverrideThrows {
    public void test() throws IOException {
        FileInputStream fis = new FileInputStream("a.txt");
    }
}
class Sub extends OverrideThrows {
    // 子类方法声明抛出了比父类方法更大的异常
    // 所以下面方法出错
    public void test() throws Exception {
    }
}
```

上面程序中 Sub 子类中的 test() 方法声明抛出 Exception，该 Exception 是其父类声明抛出异常 IOException 类的父类，这将导致程序无法通过编译。

所以在编写类继承代码时要注意，子类在重写父类带 throws 子句的方法时，子类方法声明中的 throws 子句不能出现父类对应方法的 throws 子句中没有的异常类型，因此 throws 子句可以限制子类的行为。也就是说，子类方法拋出的异常不能超过父类定义的范围。

#### throw 拋出异常

与 throws 不同的是，throw 语句用来直接拋出一个异常，后接一个可拋出的异常类对象，其语法格式如下：



```java
throw ExceptionObject;
```

其中，ExceptionObject 必须是 Throwable 类或其子类的对象。如果是自定义异常类，也必须是 Throwable 的直接或间接子类。例如，以下语句在编译时将会产生语法错误：

```
throw new String("拋出异常");    // String类不是Throwable类的子类
```

当 throw 语句执行时，它后面的语句将不执行，此时程序转向调用者程序，寻找与之相匹配的 catch 语句，执行相应的异常处理程序。如果没有找到相匹配的 catch 语句，则再转向上一层的调用程序。这样逐层向上，直到最外层的异常处理程序终止程序并打印出调用栈情况。

throw 关键字不会单独使用，它的使用完全符合异常的处理机制，但是，一般来讲用户都在避免异常的产生，所以不会手工抛出一个新的异常类的实例，而往往会抛出程序中已经产生的异常类的实例。

#### 例 2

在某仓库管理系统中，要求管理员的用户名需要由 8 位以上的字母或者数字组成，不能含有其他的字符。当长度在 8 位以下时拋出异常，并显示异常信息；当字符含有非字母或者数字时，同样拋出异常，显示异常信息。代码如下：

```java
import java.util.Scanner;
public class Test05 {
    public boolean validateUserName(String username) {
        boolean con = false;
        if (username.length() > 8) {
            // 判断用户名长度是否大于8位
            for (int i = 0; i < username.length(); i++) {
                char ch = username.charAt(i); // 获取每一位字符
                if ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
                    con = true;
                } else {
                    con = false;
                    throw new IllegalArgumentException("用户名只能由字母和数字组成！");
                }
            }
        } else {
            throw new IllegalArgumentException("用户名长度必须大于 8 位！");
        }
        return con;
    }
    public static void main(String[] args) {
        Test05 te = new Test05();
        Scanner input = new Scanner(System.in);
        System.out.println("请输入用户名：");
        String username = input.next();
        try {
            boolean con = te.validateUserName(username);
            if (con) {
                System.out.println("用户名输入正确！");
            }
        } catch (IllegalArgumentException e) {
            System.out.println(e);
        }
    }
}
```



如上述代码，在 validateUserName() 方法中两处拋出了 IllegalArgumentException 异常，即当用户名字符含有非字母或者数字以及长度不够 8 位时。在 main() 方法中，调用了 validateUserName() 方法，并使用 catch 语句捕获该方法可能拋出的异常。

运行程序，当用户输入的用户名包含非字母或者数字的字符时，程序输出异常信息，如下所示。

```
请输入用户名：
administrator@#
java.lang.IllegalArgumentException: 用户名只能由字母和数字组成！
```

当用户输入的用户名长度不够 8 位时，程序同样会输出异常信息，如下所示。

```
请输入用户名：
admin
java.lang.IllegalArgumentException: 用户名长度必须大于 8 位！
```

**throws 关键字和 throw 关键字在使用上的几点区别如下**：

- throws 用来声明一个方法可能抛出的所有异常信息，表示出现异常的一种可能性，但并不一定会发生这些异常；throw 则是指拋出的一个具体的异常类型，执行 throw 则一定抛出了某种异常对象。

- 通常在一个方法（类）的声明处通过 throws 声明方法（类）可能拋出的异常信息，而在方法（类）内部通过 throw 声明一个具体的异常信息。

- throws 通常不用显示地捕获异常，可由系统自动将所有捕获的异常信息抛给上级方法； throw 则需要用户自己捕获相关的异常，而后再对其进行相关包装，最后将包装后的异常信息抛出。




### Java 7新特性：多异常捕获

前面我们学习的多 catch 代码块虽然客观上提高了程序的健壮性，但是也导致了程序代码量大大增加。如果有些异常种类不同，但捕获之后的处理是相同的，例如以下代码。

```java
try{
    // 可能会发生异常的语句
} catch (FileNotFoundException e) {
    // 调用方法methodA处理
} catch (IOException e) {
    // 调用方法methodA处理
} catch (ParseException e) {
    // 调用方法methodA处理
}
```

3 个不同类型的异常，要求捕获之后的处理都是调用 methodA 方法。为了解决这种问题，[Java](http://c.biancheng.net/java/) 7 推出了多异常捕获技术，可以把这些异常合并处理。上述代码修改如下：

```
try{
    // 可能会发生异常的语句
} catch (IOException | ParseException e) {
    // 调用方法methodA处理
}
```

注意：由于 FileNotFoundException 属于 IOException 异常，IOException 异常可以捕获它的所有子类异常。所以不能写成 `FileNotFoundException | IOException | ParseException` 。

使用一个 catch 块捕获多种类型的异常时需要注意如下两个地方。

- 捕获多种类型的异常时，多种异常类型之间用竖线`|`隔开。
- 捕获多种类型的异常时，异常变量有隐式的 final 修饰，因此程序不能对异常变量重新赋值。


下面程序示范了 Java 7 提供的多异常捕获。

```java
public class ExceptionTest {
    public static void main(String[] args) {
        try {
            int a = Integer.parseInt(args[0]);
            int b = Integer.parseInt(args[1]);
            int c = a / b;
            System.out.println("您输入的两个数相除的结果是：" + c);
        } catch (IndexOutOfBoundsException | NumberFormatException | ArithmeticException e) {
            System.out.println("程序发生了数组越界、数字格式异常、算术异常之一");
            // 捕获多异常时，异常变量默认有final修饰
            // 所以下面代码有错
            e = new ArithmeticException("test");
        } catch (Exception e) {
            System.out.println("未知异常");
            // 捕获一种类型的异常时，异常变量没有final修饰
            // 所以下面代码完全正确
            e = new RuntimeException("test");
        }
    }
}
```

上面程序中第一行粗体字代码使用了`IndexOutOfBoundsException|NumberFormatException|ArithmeticException`来定义异常类型，这就表明该 catch 块可以同时捕获这 3 种类型的异常。捕获多种类型的异常时，异常变量使用隐式的 final 修饰，因此上面程序的第 12 行代码将产生编译错误；捕获一种类型的异常时，异常变量没有 final 修饰，因此上面程序的第 17 行代码完全正确。

### Java异常处理规则

前面介绍了使用异常处理的优势、便捷之处，本节将进一步从程序性能优化、结构优化的角度给出异常处理的一般规则。成功的异常处理应该实现如下 4 个目标。

1. 使程序代码混乱最小化。
2. 捕获并保留诊断信息。
3. 通知合适的人员。
4. 采用合适的方式结束异常活动。


下面介绍达到这种效果的基本准则。

#### 不要过度使用异常

不可否认，[Java](http://c.biancheng.net/java/) 的异常机制确实方便，但滥用异常机制也会带来一些负面影响。过度使用异常主要有以下两个方面：

1. 把异常和普通错误混淆在一起，不再编写任何错误处理代码，而是以简单地抛出异常来代替所有的错误处理。
2. 使用异常处理来代替流程控制。


熟悉了异常使用方法后，程序员可能不再愿意编写烦琐的错误处理代码，而是简单地抛出异常。实际上这样做是不对的，对于完全已知和普通的错误，应该编写处理这种错误处理代码，增加程序的健壮性；只有对外部的、不能确定和预知的运行时错误才使用异常。

下面我们来看《[Java五子棋游戏](http://c.biancheng.net/view/5859.html)》一节中处理用户输入坐标点已有棋子的两种方式。

```java
// 如果用户试图下棋的坐标点已有棋子了
if (!gb.board[xPos - 1][yPos - 1].equals("╋")){
    System.out.println ("您输入的坐标点已有棋子了，请重新输入");
    continue;
}

```

上面这种处理方式检测到用户试图下棋的坐标点已经有棋子了，立即打印一条提示语句，并重新开始下一次循环。这种处理方式简洁明了，逻辑清晰，提高运行效率。

如果将上面的处理机制改为如下方式：

```java
// 如果用户试图下棋的坐标点己经有棋子了，程序自行抛出异常
if (!gb.board[xPos - 1][yPos - 1].equals ("╋")) {
    throw new Exception ("您试图下棋的坐标点已经有棋子了");
}
```

上面的处理方式没有提供有效的错误处理代码，当程序检测到用户试图下棋的坐标点已经有棋子时，并没有提供相应的处理，而是简单的抛出了一个异常。这种处理方式虽然简单，但 Java 运行时接收到这个异常后，还需要进行相应的 catch 块来捕获该异常，所以运行效率要差一些。而且用户下棋重复这个错误完全是预料的，所以程序完全可以针对该错误提供相应的处理，而不是抛出异常。

异常处理机制的效率比正常的流程控制效率差，所以不要使用异常处理来代替正常的程序流程控制。例如，对于以下代码：

```java
// 定义一个字符串数组
String[] arr = { "Hello", "Java", "Spring" };
// 使用异常处理来遍历arr数组的每个元素
try {
    int i = 0;
    while (true) {
        System.out.println(arr[i++]);
    }
} catch (ArrayIndexOutOfBoundsException ae) {
}
```

运行上面程序确实可以实现遍历 arr 数组元素的功能，但这种写法可读性较差，而且运行效率也不高。程序完全有能力避免产生 ArrayIndexOutOfBoundsException 异常，程序“故意”制造这种异常，然后使用 catch 块去捕获该异常，这是不应该的。将程序改为如下形式肯定要好得多。

```java
String arr[] = {"Hello","Java","Spring"};
for (int i = 0; i < arr.length; i++) {
    System.out.println(arr[i]);
}
```

异常只应该用于处理非正常的情况，不要使用异常处理来代替正常的流程控制。对于一些完全可预知，而且处理方式清楚的错误，程序应该提供相应的错误处理代码，而不是将其笼统地称为异常。

#### 不要使用过于庞大的try块

很多初学异常机制的读者喜欢在 try 块里放置大量的代码，这样看上去“很简单“，但这种”简单“只是一种假象，因为 try 块里的代码过于庞大，业务过于复杂，就会造成 try 块中出现异常的可能性大大增加，从而导致分析异常原因的难度也大大增加。而且当 try 块过于庞大时，就难免在 try 块后紧跟大量的 catch 块才可以针对不同的异常提供不同的处理逻辑。同一个 try 块后紧跟大量的 catch 块则需要分析它们之间的逻辑关系，反而增加了变成复杂度。

正确的做法是，把大块的 try 块分割成多个可能出现异常的程序段落，并把它们放在单独的 try 块中，从而分别捕获并处理异常。

#### 避免使用 Catch All 语句

所谓 Catch All 语句指的是一种异常捕获模块，它可以处理程序发生的所有可能异常。例如，如下代码片段：

```java
try {
    // 可能引发Checked异常的代码
} catch (Throwsble t) {
    // 进行异常处理
    t.printStackTrace();
}
```

不可否认，每个程序员都曾经用过这种异常处理方式，但在编写关键程序时就应避免使用这种异常处理方式。这种处理方式有如下两点不足之处。

1. 所有的异常都采用相同的处理方式，这将导致无法对不同的异常分情况处理，如果要分情况处理，则需要在 catch 块中使用分支语句进行控制，这是得不偿失的做法。
2. 这种捕获方式可能将程序中的错误、Runtime 异常等可能导致程序终止的情况全部捕获到，从而“压制”了异常。如果出现了一些“关键”异常，那么此异常也会被“静悄悄”地忽略。


实际上，Catch All 语句不过是一种通过避免错误处理而加快编程进度的机制，应尽量避免在实际应用中使用这种语句。

#### 不要忽略捕获到的异常

不要忽略异常，既然已捕获到异常，那 catch 块理应处理并修复这个错误。catch 块整个为空，或者仅仅打印出错信息都是不妥的。程序出了错误，所有的人都看不到任何异常，但整个应用可能已经彻底坏了，这是最可怕的事情。

对异常进行合适的修复，然后绕过异常发生的地方继续执行；或者用别的数据进行计算，以代替期望的方法返回值；或者提示用户重新操作等。总之，对于 Checked 异常，程序应该尽量修复。

## 5、集合与泛型、枚举

## 6、Java反射机制

通过 Java 的反射机制，程序员可以更深入地控制程序的运行过程。例如，在程序运行时由用户输入一个类名，然后动态获取该类拥有的构造、属性和方法，甚至调用任意类的任意方法。

本章首先介绍 Java 中 Class 类与 Java 反射的基本用法，然后介绍具体的反射应用。为了便于读者理解，在讲解过程中还结合了大量案例。

### Java反射机制是什么？

[Java](http://c.biancheng.net/java/) 反射机制是 Java语言的一个重要特性。在学习 Java 反射机制前，大家应该先了解两个概念，编译期和运行期。

编译期是指把源码交给编译器编译成计算机可以执行的文件的过程。在Java中也就是把 Java代码编成class文件的过程。编译期只是做了一些翻译功能，并没有把代码放在内存中运行起来，而只是把代码当成文本进行操作，比如检查错误。

运行期是把编译后的文件交给计算机执行，直到程序运行结束。所谓运行期就把在磁盘中的代码放到内存中执行起来。

Java 反射机制是在运行状态中，**对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。**简单来说，反射机制指的是程序在运行时能够获取自身的信息。在 Java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。

Java 反射机制在服务器程序和中间件程序中得到了广泛运用。在服务器端，往往需要根据客户的请求，动态调用某一个对象的特定方法。此外，**在 ORM 中间件的实现中，运用 Java 反射机制可以读取任意一个 JavaBean 的所有属性，或者给这些属性赋值。**

![img](/Users/jiusonghuang/pic-md/20210817112337.png)

Java 反射机制主要提供了以下功能，这些功能都位于`java.lang.reflect`包。

- 在运行时判断任意一个对象所属的类。
- 在运行时构造任意一个类的对象。
- 在运行时判断任意一个类所具有的成员变量和方法。
- 在运行时调用任意一个对象的方法。
- **生成动态代理。**

要想知道一个类的属性和方法，必须先获取到该类的字节码文件对象。获取类的信息时，使用的就是 Class 类中的方法。所以先**要获取到每一个字节码文件（.class）对应的 Class 类型的对象.**

众所周知，所有 Java 类均继承了 Object 类，在 Object 类中定义了一个 getClass() 方法，该方法返回同一个类型为 Class 的对象。例如，下面的示例代码：

```java
Class labelCls = label1.getClass();    // label1为 JLabel 类的对象
```

利用 Class 类的对象 labelCls 可以访问 labelCls 对象的描述信息、JLabel 类的信息以及基类 Object 的信息。表 1 列出了通过反射可以访问的信息。

| 类型           | 访问方法                 | 返回值类型         | 说明                                              |
| -------------- | ------------------------ | ------------------ | ------------------------------------------------- |
| 包路径         | getPackage()             | Package 对象       | 获取该类的存放路径                                |
| 类名称         | getName()                | String 对象        | 获取该类的名称                                    |
| 继承类         | getSuperclass()          | Class 对象         | 获取该类继承的类                                  |
| 实现接口       | getlnterfaces()          | Class 型数组       | 获取该类实现的所有接口                            |
| 构造方法       | getConstructors()        | Constructor 型数组 | 获取所有权限为 public 的构造方法                  |
|                | getDeclaredContructors() | Constructor 对象   | 获取当前对象的所有构造方法                        |
| 方法           | getMethods()             | Methods 型数组     | 获取所有权限为 public 的方法                      |
|                | getDeclaredMethods()     | Methods 对象       | 获取当前对象的所有方法                            |
| 成员变量       | getFields()              | Field 型数组       | 获取所有权限为 public 的成员变量                  |
|                | getDeclareFileds()       | Field 对象         | 获取当前对象的所有成员变量                        |
| 内部类         | getClasses()             | Class 型数组       | 获取所有权限为 public 的内部类                    |
|                | getDeclaredClasses()     | Class 型数组       | 获取所有内部类                                    |
| 内部类的声明类 | getDeclaringClass()      | Class 对象         | 如果该类为内部类，则返回它的成员类，否则返回 null |

如表 1 所示，在调用 getFields() 和 getMethods() 方法时将会依次获取权限为 public 的字段和变量，然后将包含从超类中继承到的成员变量和方法。而通过 getDeclareFields() 和 getDeclareMethod() 只是获取在本类中定义的成员变量和方法。

#### Java 反射机制的优缺点

优点：

- 能够运行时动态获取类的实例，大大提高系统的灵活性和扩展性。
- 与 Java 动态编译相结合，可以实现无比强大的功能。
- 对于 Java 这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。


缺点：

- 反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射；
- 反射调用方法时可以忽略权限检查，获取这个类的私有方法和属性，因此可能会破坏类的封装性而导致安全问题。


Java 反射机制在一般的 Java 应用开发中很少使用，即便是 Java EE 阶段也很少使用。

### Java反射机制API

实现 [Java](http://c.biancheng.net/java/) 反射机制的类都位于 java.lang.reflect 包中，java.lang.Class 类是 Java 反射机制 API 中的核心类。本节将从这两个方面讲解 Java 反射机制 API。

> 可参考《[Java反射机制的基本概念](http://c.biancheng.net/view/6907.html)》一节中介绍的关于 Java 反射机制获取类对象相关信息的方法，来学习本节内容。

#### java.lang.Class 类

java.lang.Class 类是实现反射的关键所在，Class 类的一个实例表示 Java 的一种数据类型，包括类、接口、枚举、注解（Annotation）、数组、基本数据类型和 void。Class 没有公有的构造方法，Class 实例是由 JVM 在类加载时自动创建的。

在程序代码中获得 Class 实例可以通过如下代码实现：

```java
// 1. 通过类型class静态变量
Class clz1 = String.class;
String str = "Hello";
// 2. 通过对象的getClass()方法
Class clz2 = str.getClass();
```


每一种类型包括类和接口等，都有一个 class 静态变量可以获得 Class 实例。另外，每一个对象都有 getClass() 方法可以获得 Class 实例，该方法是由 Object 类提供的实例方法。

Class 类提供了很多方法可以获得运行时对象的相关信息，下面的程序代码展示了其中一些方法。

```java
public class ReflectionTest01 {
    public static void main(String[] args) {
        // 获得Class实例
        // 1.通过类型class静态变量
        Class clz1 = String.class;
        String str = "Hello";
        // 2.通过对象的getClass()方法
        Class clz2 = str.getClass();
        // 获得int类型Class实例
        Class clz3 = int.class;
        // 获得Integer类型Class实例
        Class clz4 = Integer.class;
        System.out.println("clz2类名称：" + clz2.getName());
        System.out.println("clz2是否为接口：" + clz2.isInterface());
        System.out.println("clz2是否为数组对象：" + clz2.isArray());
        System.out.println("clz2父类名称：" + clz2.getSuperclass().getName());
        System.out.println("clz2是否为基本类型：" + clz2.isPrimitive());
        System.out.println("clz3是否为基本类型：" + clz3.isPrimitive());
        System.out.println("clz4是否为基本类型：" + clz4.isPrimitive());
    }
}
```

运行结果如下：

clz2类名称：java.lang.String
clz2是否为接口：false
clz2是否为数组对象：false
clz2父类名称：java.lang.Object
clz2是否为基本类型：false
clz3是否为基本类型：true
clz4是否为基本类型：false

注意上述代码第 10 行和第 12 行的区别。int 是基本数据类型，所以输出结果为 true；Integer 是类，是引用数据类型，所以输出结果为 false。

#### java.lang.reflect 包

java.lang.reflect 包提供了反射中用到类，主要的类说明如下：

- Constructor 类：提供类的构造方法信息。
- Field 类：提供类或接口中成员变量信息。
- Method 类：提供类或接口成员方法信息。
- Array 类：提供了动态创建和访问 Java 数组的方法。
- Modifier 类：提供类和成员访问修饰符信息。


示例代码如下：

```java
public class ReflectionTest02 {
    public static void main(String[] args) {
        try {
            // 动态加载xx类的运行时对象
            Class c = Class.forName("java.lang.String");
            // 获取成员方法集合
            Method[] methods = c.getDeclaredMethods();
            // 遍历成员方法集合
            for (Method method : methods) {
                // 打印权限修饰符，如public、protected、private
                System.out.print(Modifier.toString(method.getModifiers()));
                // 打印返回值类型名称
                System.out.print(" " + method.getReturnType().getName() + " ");
                // 打印方法名称
                System.out.println(method.getName() + "();");
            }
        } catch (ClassNotFoundException e) {
            System.out.println("找不到指定类");
        }
    }
}
```

上述代码第 5 行是通过 Class 的静态方法`forName(String)`创建某个类的运行时对象，其中的参数是类全名字符串，如果在类路径中找不到这个类则抛出 ClassNotFoundException 异常，见代码第 17 行。

代码第 7 行是通过 Class 的实例方法 getDeclaredMethods() 返回某个类的成员方法对象数组。代码第 9 行是遍历成员方法集合，其中的元素是 Method 类型。

代Java输入/输出（I/O）流码第 11 行的`method.getModifiers()`方法返回访问权限修饰符常量代码，是 int 类型，例如 1 代表 public，这些数字代表的含义可以通过`Modifier.toString(int)`方法转换为字符串。代码第 13 行通过 Method 的 getReturnType() 方法获得方法返回值类型，然后再调用 getName() 方法返回该类型的名称。代码第 15 行`method.getName()`返回方法名称。

### Java通过反射访问构造方法

为了能够**动态获取**对象构造方法的信息，首先需要通过下列方法之一创建一个 `Constructor` 类型的对象或者数组。

- getConstructors()
- getConstructor(Class<?>…parameterTypes)
- getDeclaredConstructors()
- getDeclaredConstructor(Class<?>...parameterTypes)


如果是访问指定的构造方法，需要根据该构造方法的入口参数的类型来访问。例如，访问一个入口参数类型依次为 int 和 String 类型的构造方法，下面的两种方式均可以实现。

```java
objectClass.getDeclaredConstructor(int.class,String.class);
objectClass.getDeclaredConstructor(new Class[]{int.class,String.class});
```

创建的每个 Constructor 对象表示一个构造方法，然后利用 Constructor 对象的方法操作构造方法。Constructor 类的常用方法如表 1 所示。

表1 Constructor类的常用方法

| 方法名称                       | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| isVarArgs()                    | 查看该构造方法是否允许带可变数量的参数，如果允许，返回 true，否则返回 false |
| getParameterTypes()            | 按照声明顺序以 Class 数组的形式获取该构造方法各个参数的类型  |
| getExceptionTypes()            | 以 Class 数组的形式获取该构造方法可能抛出的异常类型          |
| newInstance(Object … initargs) | 通过该构造方法利用指定参数创建一个该类型的对象，如果未设置参数则表示 采用默认无参的构造方法 |
| setAccessiable(boolean flag)   | 如果该构造方法的权限为 private，默认为不允许通过反射利用 netlnstance() 方法创建对象。如果先执行该方法，并将入口参数设置为 true，则允许创建对 象 |
| getModifiers()                 | 获得可以解析出该构造方法所采用修饰符的整数                   |

通过 java.lang.reflect.Modifier 类可以解析出 getMocMers() 方法的返回值所表示的修饰符信息。在该类中提供了一系列用来解析的静态方法，既可以查看是否被指定的修饰符修饰，还可以字符串的形式获得所有修饰符。表 2 列出了 Modifier 类的常用静态方法。

表2 Modifier类的常用方法

| 静态方法名称         | 说明                                                     |
| -------------------- | -------------------------------------------------------- |
| isStatic(int mod)    | 如果使用 static 修饰符修饰则返回 true，否则返回 false    |
| isPublic(int mod)    | 如果使用 public 修饰符修饰则返回 true，否则返回 false    |
| isProtected(int mod) | 如果使用 protected 修饰符修饰则返回 true，否则返回 false |
| isPrivate(int mod)   | 如果使用 private 修饰符修饰则返回 true，否则返回 false   |
| isFinal(int mod)     | 如果使用 final 修饰符修饰则返回 true，否则返回 false     |
| toString(int mod)    | 以字符串形式返回所有修饰符                               |

例如，下列代码判断对象 con 所代表的构造方法是否被 public 修饰，以及以字符串形式获取该构造方法的所有修饰符。

```java
int modifiers = con.getModifiers();    // 获取构造方法的修饰符整数
boolean isPublic = Modifier.isPublic(modifiers);    // 判断修饰符整数是否为public 
string allModifiers = Modifier.toString(modifiers);
```

#### 例 1

下面通过一个案例来演示如何调用 Constructor 类的方法获取构造方法的信息。

1）首先创建一个 Book 类表示图书信息。在该类中声明一个 String 型变量表示图书名称，两个 int 型变量分别表示图书编号和价格，并提供 3 个构造方法。

Book 类的最终代码如下：

```java
public class Book {
    String name; // 图书名称
    int id, price; // 图书编号和价格
    // 空的构造方法
    private Book() {
    }
    // 带两个参数的构造方法
    protected Book(String _name, int _id) {
        this.name = _name;
        this.id = _id;
    }
    // 带可变参数的构造方法
    public Book(String... strings) throws NumberFormatException {
        if (0 < strings.length)
            id = Integer.valueOf(strings[0]);
        if (1 < strings.length)
            price = Integer.valueOf(strings[1]);
    }
    // 输出图书信息
    public void print() {
        System.out.println("name=" + name);
        System.out.println("id=" + id);
        System.out.println("price=" + price);
    }
}
```

2）编写测试类 Test01，在该类的 main() 方法中通过反射访问 Book 类中的所有构造方法，并将该构造方法是否带可变类型参数、入口参数类型和可能拋出的异常类型信息输出到控制台。

Test01 类的代码如下：

```java
public class Test01 {
    public static void main(String[] args) {
        // 获取动态类Book
        Class book = Book.class;
        // 获取Book类的所有构造方法
        Constructor[] declaredContructors = book.getDeclaredConstructors();
        // 遍历所有构造方法
        for (int i = 0; i < declaredContructors.length; i++) {
            Constructor con = declaredContructors[i];
            // 判断构造方法的参数是否可变
            System.out.println("查看是否允许带可变数量的参数：" + con.isVarArgs());
            System.out.println("该构造方法的入口参数类型依次为：");
            // 获取所有参数类型
            Class[] parameterTypes = con.getParameterTypes();
            for (int j = 0; j < parameterTypes.length; j++) {
                System.out.println(" " + parameterTypes[j]);
            }
            System.out.println("该构造方法可能拋出的异常类型为：");
            // 获取所有可能拋出的异常类型
            Class[] exceptionTypes = con.getExceptionTypes();
            for (int j = 0; j < exceptionTypes.length; j++) {
                System.out.println(" " + parameterTypes[j]);
            }
            // 创建一个未实例化的Book类实例
            Book book1 = null;
            while (book1 == null) {
                try { // 如果该成员变量的访问权限为private，则拋出异常
                    if (i == 1) {
                        // 通过执行带两个参数的构造方法实例化book1
                        book1 = (Book) con.newInstance("Java 教程", 10);
                    } else if (i == 2) {
                        // 通过执行默认构造方法实例化book1
                        book1 = (Book) con.newInstance();
                    } else {
                        // 通过执行可变数量参数的构造方法实例化book1
                        Object[] parameters = new Object[] { new String[] { "100", "200" } };
                        book1 = (Book) con.newInstance(parameters);
                    }
                } catch (Exception e) {
                    System.out.println("在创建对象时拋出异常，下面执行 setAccessible() 方法");
                    con.setAccessible(true); // 设置允许访问 private 成员
                }
            }
            book1.print();
            System.out.println("=============================\n");
        }
    }
}
```

3）运行测试类 Test01，当通过反射访问默认构造方法 Book() 时，将看到如下所示的输出。

```
查看是否允许带可变数量的参数：false
该构造方法的入口参数类型依次为：
该构造方法可能抛出的异常类型为：
在创建对象时抛出异常，下面执行setAccessible()方法
name = null
id = 0
price = 0
=============================
```

当通过反射访问两个参数的构造方法 Book(String_name,int_id) 时，将看到如下所示的输出。

```
查看是否允许带可变数量的参数：false
该构造方法的入口参数类型依次为：
class java.lang.String
int
该构造方法可能抛出的异常类型为：
在创建对象时抛出异常，下面执行setAccessible()方法
name = null
id = 0
price = 0
=============================
```

当通过反射访问可变参数数量的构造方法 Book(String...strings) 时，将看到如下所示的输出。

```
查看是否允许带可变数量的参数：true
该构造方法的入口参数类型依次为：
class java.lang.String;
该构造方法可能抛出的异常类型为：
class java.lang.String;
在创建对象时抛出异常，下面执行setAccessible()方法
name = null
id = 0
price = 0
=============================
```

### Java通过反射执行方法（获取方法）

要**动态获取**一个对象方法的信息，首先需要通过下列方法之一创建一个 `Method` 类型的对象或者数组。

- getMethods()
- getMethods(String name,Class<?> …parameterTypes)
- getDeclaredMethods()
- getDeclaredMethods(String name,Class<?>...parameterTypes)


如果是访问指定的构造方法，需要根据该方法的入口参数的类型来访问。例如，访问一个名称为 max，入口参数类型依次为 int 和 String 类型的方法。

下面的两种方式均可以实现：

```java
objectClass.getDeclaredConstructor("max",int.class,String.class);
objectClass.getDeclaredConstructor("max",new Class[]{int.class,String.class});
```

Method 类的常用方法如表 3 所示。

| 静态方法名称                     | 说明                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| getName()                        | 获取该方法的名称                                             |
| getParameterType()               | 按照声明顺序以 Class 数组的形式返回该方法各个参数的类型      |
| getReturnType()                  | 以 Class 对象的形式获得该方法的返回值类型                    |
| getExceptionTypes()              | 以 Class 数组的形式获得该方法可能抛出的异常类型              |
| invoke(Object obj,Object...args) | 利用 args 参数执行指定对象 obj 中的该方法，返回值为 Object 类型 |
| isVarArgs()                      | 查看该方法是否允许带有可变数量的参数，如果允许返回 true，否则返回 false |
| getModifiers()                   | 获得可以解析出该方法所采用修饰符的整数                       |

#### 例 2

下面通过一个案例来演示如何调用 Method 类的方法获取动态类中方法的信息。

1）首先创建一个 Book1 类，并编写 4 个具有不同作用域的方法。Book1 类的最终代码如下：

```java
public class Book1 {
    // static 作用域方法
    static void staticMethod() {
        System.out.println("执行staticMethod()方法");
    }
    // public 作用域方法
    public int publicMethod(int i) {
        System.out.println("执行publicMethod()方法");
        return 100 + i;
    }
    // protected 作用域方法
    protected int protectedMethod(String s, int i) throws NumberFormatException {
        System.out.println("执行protectedMethod()方法");
        return Integer.valueOf(s) + i;
    }
    // private 作用域方法
    private String privateMethod(String... strings) {
        System.out.println("执行privateMethod()方法");
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < sb.length(); i++) {
            sb.append(strings[i]);
        }
        return sb.toString();
    }
}
```

2）编写测试类 Test02，在该类的 main() 方法中通过反射访问 Book1 类中的所有方法，并将该方法是否带可变类型参数、入口参数类型和可能拋出的异常类型信息输出到控制台。

Test02 类的代码如下：

```java
public class Test02 {
    public static void main(String[] args) {
        // 获取动态类Book1
        Book1 book = new Book1();
        Class class1 = book.getClass();
        // 获取Book1类的所有方法
        Method[] declaredMethods = class1.getDeclaredMethods();
        for (int i = 0; i < declaredMethods.length; i++) {
            Method method = declaredMethods[i];
            System.out.println("方法名称为：" + method.getName());
            System.out.println("方法是否带有可变数量的参数：" + method.isVarArgs());
            System.out.println("方法的参数类型依次为：");
            // 获取所有参数类型
            Class[] methodType = method.getParameterTypes();
            for (int j = 0; j < methodType.length; j++) {
                System.out.println(" " + methodType[j]);
            }
            // 获取返回值类型
            System.out.println("方法的返回值类型为：" + method.getReturnType());
            System.out.println("方法可能抛出的异常类型有：");
            // 获取所有可能抛出的异常
            Class[] methodExceptions = method.getExceptionTypes();
            for (int j = 0; j < methodExceptions.length; j++) {
                System.out.println(" " + methodExceptions[j]);
            }
            boolean isTurn = true;
            while (isTurn) {
                try { // 如果该成员变量的访问权限为private，则抛出异常
                    isTurn = false;
                    if (method.getName().equals("staticMethod")) { // 调用没有参数的方法
                        method.invoke(book);
                    } else if (method.getName().equals("publicMethod")) { // 调用一个参数的方法
                        System.out.println("publicMethod(10)的返回值为：" + method.invoke(book, 10));
                    } else if (method.getName().equals("protectedMethod")) { // 调用两个参数的方法
                        System.out.println("protectedMethod(\"10\",15)的返回值为：" + method.invoke(book, "10", 15));
                    } else if (method.getName().equals("privateMethod")) { // 调用可变数量参数的方法
                        Object[] parameters = new Object[] { new String[] { "J", "A", "V", "A" } };
                        System.out.println("privateMethod()的返回值为：" + method.invoke(book, parameters));
                    }
                } catch (Exception e) {
                    System.out.println("在设置成员变量值时抛出异常，下面执行setAccessible()方法");
                    method.setAccessible(true); // 设置为允许访问private方法
                    isTurn = true;
                }
            }
            System.out.println("=============================\n");
        }
    }
}
```

3）运行测试类 test02，程序将会依次动态访问 Book1 类中的所有方法。访问 staticMethod() 方法的运行效果如下所示：

```
方法名称为：staticMethod
方法是否带有可变数量的参数：false
方法的参数类型依次为：
方法的返回值类型为：void
方法可能抛出的异常类型有：
执行staticMethod()方法
=============================
```

访问 publicMethod() 方法的运行效果如下所示：

```
方法名称为：publicMethod
方法是否带有可变数量的参数：false
方法的参数类型依次为：
int
方法的返回值类型为：int
方法可能抛出的异常类型有：
执行publicMethod()方法
publicMethod(10)的返回值为：110
=============================
```

访问 protectedMethod() 方法的运行效果如下所示：

```
方法名称为：protectedMethod
方法是否带有可变数量的参数：false
方法的参数类型依次为：
class java.lang.String
int
方法的返回值类型为：int
方法可能抛出的异常类型有：
class java.lang.NumberFormatException
执行protectedMethod()方法
protectedMethod("10",15)的返回值为：25
=============================
```

访问 privateMethod() 方法的运行效果如下所示：

```
方法名称为：privateMethod
方法是否带有可变数量的参数：true
方法的参数类型依次为：
class java.lang.String;
方法的返回值类型为：class java.lang.String
方法可能抛出的异常类型有：
在设置成员变量值时抛出异常，下面执行setAccessible()方法
执行privateMethod()方法
privateMethod()的返回值为：
=============================
```



## Java输入/输出（I/O）流

在变量、数组、对象和集合中存储的数据是暂时存在的，一旦程序结束它们就会丢失。为了能够永久地保存程序创建的数据，需要将其保存到磁盘文件中，这样就可以在其他程序中使用它们。Java 的 I/O（输入/输出）技术可以将数据保存到文本文件和二进制文件中， 以达到永久保存数据的要求。

本章首先从基础的流概念、流的分类、系统流的使用开始介绍，进而介绍如何操作文件、读取文件和写入文件。掌握 Java 中 I/O 处理技术能够提高读者对数据的处理能力。