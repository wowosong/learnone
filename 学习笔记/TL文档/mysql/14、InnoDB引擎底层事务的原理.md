# InnoDB引擎底层事务的原理

事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。

原子性指的是一个事务中的操作要么全部成功，要么全部失败。

一致性指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，假设中间sql执行过程中系统崩溃A也不会损失100块，因为事务没有提交，修改也就不会保存到数据库。

隔离性指的是一个事务的修改在最终提交前，对其他事务是不可见的。

持久性指的是一旦事务提交，所做的修改就会永久保存到数据库中。

总的来说，MySQL中事务的原子性是通过 undo log 来实现的，事务的持久性性是通过 redo log 来实现的，事务的隔离性是通过读写锁+MVCC来实现的。

事务的一致性通过原子性、隔离性、持久性来保证。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。同时一致性也需要应用程序的支持，应用程序在事务里故意写出违反约束的代码，一致性还是无法保证的，例如，转账代码里从A账户扣钱而不给B账户加钱，那一致性还是无法保证。

在事务的具体实现机制上，MySQL采用的是WAL（Write-ahead logging，预写式日志）机制来实现的。这也是是当今的主流方案。

在使用WAL的系统中，所有的修改都先被写入到日志中，然后再被应用到系统中。通常包含redo和undo两部分信息。

为什么需要使用WAL，然后包含redo和undo信息呢？举个例子，如果一个系统直接将变更应用到系统状态中，那么在机器掉电重启之后系统需要知道操作是成功了，还是只有部分成功或者是失败了（为了恢复状态）。如果使用了WAL，那么在重启之后系统可以通过比较日志和系统状态来决定是继续完成操作还是撤销操作。

redo log称为重做日志，每当有操作时，在数据变更之前将操作写入redo log，这样当发生掉电之类的情况时系统可以在重启后继续操作。

undo log称为撤销日志，当一些变更执行到一半无法完成时，可以根据撤销日志恢复到变更之间的状态。

前面说过，MySQL中用redo log来在系统Crash重启之类的情况时修复数据（事务的持久性），而undo log来保证事务的原子性。

tips：Commit Logging和Shadow Paging

事务的日志类型的实现除了WAL（Write-ahead logging，预写式日志）外，还有“Commit Logging”（提交日志），这种方式只有在日志记录全部都安全落盘，数据库在日志中看到代表事务成功提交的“提交记录”（Commit Record）后，才会根据日志上的信息对真正的数据进行修改，修改完成后，再在日志中加入一条“结束记录”（End Record）表示事务已完成持久化。两者的区别是，WAL允许在事务提交之前，提前写入变动数据，而Commit Logging则不行；WAL中有undo日志，Commit Logging没有。阿里的OceanBase则是使用的Commit Logging来实现事务。

实现事务的原子性和持久性除日志外，还有另外一种称为“Shadow Paging”（有中文资料翻译为“影子分页”）的事务实现机制，常用的轻量级数据库 SQLite Version 3 采用的事务机制就是 Shadow Paging。

Shadow Paging 的大体思路是对数据的变动会写到硬盘的数据中，但并不是直接就地修改原先的数据，而是先将数据复制一份副本，保留原数据，修改副本数据。在事务过程中，被修改的数据会同时存在两份，一份是修改前的数据，一份是修改后的数据，这也是“影子”（Shadow）这个名字的由来。当事务成功提交，所有数据的修改都成功持久化之后，最后一步是去修改数据的引用指针，将引用从原数据改为新复制出来修改后的副本，最后的“修改指针”这个操作将被认为是原子操作，现代磁盘的写操作可以认为在硬件上保证了不会出现“改了半个值”的现象。所以 Shadow Paging 也可以保证原子性和持久性。Shadow Paging 实现事务要比 Commit Logging 更加简单，但涉及隔离性与并发锁时，Shadow Paging 实现的事务并发能力就相对有限，因此在高性能的数据库中应用不多。

## redo日志

### redo日志的作用

InnoDB存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。在Buffer Pool的时候说过，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer Pool之后才可以访问。但是在事务的时候又强调过一个称之为持久性的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。

如果我们只在内存的Buffer Pool中修改了页面，假设在事务提交后突然发生了某个故障，导致内存中的数据都失效了，那么这个已经提交了的事务对数据库中所做的更改也就跟着丢失了，这是我们所不能忍受的。那么如何保证这个持久性呢？一个很简单的做法就是在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题：

1、刷新一个完整的数据页太浪费了

有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在InnoDB中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太浪费了。

2、随机IO刷起来比较慢

一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面刷新到磁盘时，需要进行很多的随机IO，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。

怎么办呢？我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好，比方说某个事务将系统表空间中的第100号页面中偏移量为1000处的那个字节的值1改成2我们只需要记录一下：

将第0号表空间的100号页面的偏移量为1000处的值更新为2。

这样我们在事务提交时，把上述内容刷新到磁盘中，即使之后系统崩溃了，重启之后只要按照上述内容所记录的步骤重新更新一下数据页，那么该事务对数据库中所做的修改又可以被恢复出来，也就意味着满足持久性的要求。因为在系统崩溃重启时需要按照上述内容所记录的步骤重新更新数据页，所以上述内容也被称之为重做日志，英文名为redo log，也可以称之为redo日志。与在事务提交时将所有修改过的内存中的页面刷新到磁盘中相比，只将该事务执行过程中产生的redo日志刷新到磁盘的好处如下：

1、redo日志占用的空间非常小

存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小的。

2、redo日志是顺序写入磁盘的

在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。

## redo日志格式

通过上边的内容我们知道，redo日志本质上只是记录了一下事务对数据库做了哪些修改。 InnoDB们针对事务对数据库的不同修改场景定义了多种类型的redo日志，但是绝大部分类型的redo日志都有下边这种通用的结构：

![img](./14%E3%80%81InnoDB%E5%BC%95%E6%93%8E%E5%BA%95%E5%B1%82%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86.assets/20220115185142.png)

各个部分的详细释义如下：

type：该条redo日志的类型，redo日志设计大约有53种不同的类型日志。

space ID：表空间ID。

page number：页号。

data：该条redo日志的具体内容。

### 简单的redo日志类型

我们用一个简单的例子来说明最基本的redo日志类型。我们前边介绍InnoDB的记录行格式的时候说过，如果我们没有为某个表显式的定义主键，并且表中也没有定义Unique键，那么InnoDB会自动的为表添加一个称之为row\_id的隐藏列作为主键。为这个row\_id隐藏列赋值的方式如下：

服务器会在内存中维护一个全局变量，每当向某个包含隐藏的row\_id列的表中插入一条记录时，就会把该变量的值当作新记录的row\_id列的值，并且把该变量自增1。

每当这个变量的值为256的倍数时，就会将该变量的值刷新到系统表空间的页号为7的页面中一个称之为Max Row ID的属性处。

当系统启动时，会将上边提到的Max Row ID属性加载到内存中，将该值加上256之后赋值给我们前边提到的全局变量。

这个Max Row ID属性占用的存储空间是8个字节，当某个事务向某个包含row\_id隐藏列的表插入一条记录，并且为该记录分配的row\_id值为256的倍数时，就会向系统表空间页号为7的页面的相应偏移量处写入8个字节的值。但是我们要知道，这个写入实际上是在Buffer Pool中完成的，我们需要为这个页面的修改记录一条redo日志，以便在系统崩溃后能将已经提交的该事务对该页面所做的修改恢复出来。这种情况下对页面的修改是极其简单的，redo日志中只需要记录一下在某个页面的某个偏移量处修改了几个字节的值，具体被修改的内容是啥就好了，InnoDB把这种极其简单的redo日志称之为物理日志，并且根据在页面中写入数据的多少划分了几种不同的redo日志类型：

MLOG\_1BYTE（type字段对应的十进制数字为1）：表示在页面的某个偏移量处写入1个字节的redo日志类型。

MLOG\_2BYTE（type字段对应的十进制数字为2）：表示在页面的某个偏移量处写入2个字节的redo日志类型。

MLOG\_4BYTE（type字段对应的十进制数字为4）：表示在页面的某个偏移量处写入4个字节的redo日志类型。

MLOG\_8BYTE（type字段对应的十进制数字为8）：表示在页面的某个偏移量处写入8个字节的redo日志类型。

MLOG\_WRITE\_STRING（type字段对应的十进制数字为30）：表示在页面的某个偏移量处写入一串数据。

我们上边提到的Max Row ID属性实际占用8个字节的存储空间，所以在修改页面中的该属性时，会记录一条类型为MLOG\_8BYTE的redo日志，MLOG\_8BYTE的redo日志结构如下所示：

![img](./14%E3%80%81InnoDB%E5%BC%95%E6%93%8E%E5%BA%95%E5%B1%82%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86.assets/20220115185154.png)

offset代表在页面中的偏移量。

其余MLOG\_1BYTE、MLOG\_2BYTE、MLOG\_4BYTE类型的redo日志结构和MLOG\_8BYTE的类似，只不过具体数据中包含对应个字节的数据罢了。MLOG\_WRITE\_STRING类型的redo日志表示写入一串数据，但是因为不能确定写入的具体数据占用多少字节，所以需要在日志结构中还会多一个len字段。

### 复杂一些的redo日志类型

有时候执行一条语句会修改非常多的页面，包括系统数据页面和用户数据页面（用户数据指的就是聚簇索引和二级索引对应的B+树）。以一条INSERT语句为例，它除了要向B+树的页面中插入数据，也可能更新系统数据Max Row ID的值，不过对于我们用户来说，平时更关心的是语句对B+树所做更新：

表中包含多少个索引，一条INSERT语句就可能更新多少棵B+树。

针对某一棵B+树来说，既可能更新叶子节点页面，也可能更新非叶子节点页面，也可能创建新的页面（在该记录插入的叶子节点的剩余空间比较少，不足以存放该记录时，会进行页面的分裂，在非叶子节点页面中添加目录项记录）。

在语句执行过程中，INSERT语句对所有页面的修改都得保存到redo日志中去。实现起来是非常麻烦的，比方说将记录插入到聚簇索引中时，如果定位到的叶子节点的剩余空间足够存储该记录时，那么只更新该叶子节点页面就好，那么只记录一条MLOG\_WRITE\_STRING类型的redo日志，表明在页面的某个偏移量处增加了哪些数据就好了么？

别忘了一个数据页中除了存储实际的记录之后，还有什么File Header、Page Header、Page Directory等等部分，所以每往叶子节点代表的数据页里插入一条记录时，还有其他很多地方会跟着更新，比如说：

可能更新Page Directory中的槽信息、Page Header中的各种页面统计信息，比如槽数量可能会更改，还未使用的空间最小地址可能会更改，本页面中的记录数量可能会更改，各种信息都可能会被修改，同时数据页里的记录是按照索引列从小到大的顺序组成一个单向链表的，每插入一条记录，还需要更新上一条记录的记录头信息中的next\_record属性来维护这个单向链表。

画一个简易的示意图就像是这样：

![img](./14%E3%80%81InnoDB%E5%BC%95%E6%93%8E%E5%BA%95%E5%B1%82%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86.assets/20220115185243.png)

其实说到底，把一条记录插入到一个页面时需要更改的地方非常多。这时我们如果使用上边介绍的简单的物理redo日志来记录这些修改时，可以有两种解决方案：

方案一：在每个修改的地方都记录一条redo日志。

也就是如上图所示，有多少个加粗的块，就写多少条物理redo日志。这样子记录redo日志的缺点是显而易见的，因为被修改的地方是在太多了，可能记录的redo日志占用的空间都比整个页面占用的空间都多了。

方案二：将整个页面的第一个被修改的字节到最后一个修改的字节之间所有的数据当成是一条物理redo日志中的具体数据。

从图中也可以看出来，第一个被修改的字节到最后一个修改的字节之间仍然有许多没有修改过的数据，我们把这些没有修改的数据也加入到redo日志中去依然很浪费。

正因为上述两种使用物理redo日志的方式来记录某个页面中做了哪些修改比较浪费，InnoDB中就有非常多的redo日志类型来做记录。

这些类型的redo日志既包含物理层面的意思，也包含逻辑层面的意思，具体指：

物理层面看，这些日志都指明了对哪个表空间的哪个页进行了修改。

逻辑层面看，在系统崩溃重启时，并不能直接根据这些日志里的记载，将页面内的某个偏移量处恢复成某个数据，而是需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复成系统崩溃前的样子。

简单来说，一个redo日志类型而只是把在本页面中变动（比如插入、修改）一条记录所有必备的要素记了下来，之后系统崩溃重启时，服务器会调用相关向某个页面变动（比如插入、修改）一条记录的那个函数，而redo日志中的那些数据就可以被当成是调用这个函数所需的参数，在调用完该函数后，页面中的相关值也就都被恢复到系统崩溃前的样子了。这就是所谓的逻辑日志的意思。

当然，如果不是为了写一个解析redo日志的工具或者自己开发一套redo日志系统的话，那就不需要去研究InnoDB中的redo日志具体格式。

大家只要记住：redo日志会把**事务在执行过程中对数据库所做的所有修改都记录下来**，在之后系统崩溃重启后可以把事务所做的任何修改都恢复出来。

### redo日志的写入过程

#### redo log block和日志缓冲区

InnoDB为了更好的进行系统崩溃恢复，把redo日志都放在了大小为512字节的块（block）中。

我们前边说过，为了解决磁盘速度过慢的问题而引入了Buffer Pool。同理，写入redo日志时也不能直接直接写到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为redo log buffer的连续内存空间，翻译成中文就是redo日志缓冲区，我们也可以简称为 redo log buffer。这片内存空间被划分成若干个连续的redo log block，我们可以通过启动参数innodb\_log\_buffer\_size来指定log buffer的大小，该启动参数的默认值为16MB。

向log buffer中写入redo日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。

#### redo日志刷盘时机

我们前边说redo日志在内存中有个log buffer，可是这些日志总在内存里呆着也不是个办法，在一些情况下它们会被刷新到磁盘里，比如：

1、log buffer空间不足时，log buffer的大小是有限的（通过系统变量innodb\_log\_buffer\_size指定），如果不停的往这个有限大小的log buffer里塞入日志，很快它就会被填满。InnoDB认为如果当前写入log buffer的redo日志量已经占满了log buffer总容量的大约一半左右，就需要把这些日志刷新到磁盘上。

2、事务提交时，我们前边说过之所以使用redo日志主要是因为它占用的空间少，还是顺序写，在事务提交时可以不把修改过的Buffer Pool页面刷新到磁盘，但是为了保证持久性，必须要把修改这些页面对应的redo日志刷新到磁盘。

3、后台有一个线程，大约每秒都会刷新一次log buffer中的redo日志到磁盘。

4、正常关闭服务器时等等。

#### redo日志文件组

MySQL的数据目录（使用SHOW VARIABLES LIKE 'datadir'查看）下默认有两个名为ib\_logfile0和ib\_logfile1的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。如果我们对默认的redo日志文件不满意，可以通过下边几个启动参数来调节：

innodb\_log\_group\_home\_dir，该参数指定了redo日志文件所在的目录，默认值就是当前的数据目录。

innodb\_log\_file\_size，该参数指定了每个redo日志文件的大小，默认值为48MB，

innodb\_log\_files\_in\_group，该参数指定redo日志文件的个数，默认值为2，最大值为100。

所以磁盘上的redo日志文件可以不只一个，而是以一个日志文件组的形式出现的。这些文件以ib\_logfile\[数字\]（数字可以是0、1、2...）的形式进行命名。在将redo日志写入日志文件组时，是从ib\_logfile0开始写，如果ib\_logfile0写满了，就接着ib\_logfile1写，同理，ib\_logfile1写满了就去写ib\_logfile2，依此类推。如果写到最后一个文件该咋办？那就重新转到ib\_logfile0继续写。

既然**Redo log文件是循环写入的**，在覆盖写之前，总是要保证对应的脏页已经刷到了磁盘。在非常大的负载下，为避免错误的覆盖，InnoDB 会强制的flush脏页。

#### redo日志文件格式

我们前边说过log buffer本质上是一片连续的内存空间，被划分成了若干个512字节大小的block。将log buffer中的redo日志刷新到磁盘的本质就是把block的镜像写入日志文件中，所以redo日志文件其实也是由若干个512字节大小的block组成。

redo日志文件组中的每个文件大小都一样，格式也一样，都是由两部分组成：前2048个字节，也就是前4个block是用来存储一些管理信息的。

从第2048字节往后是用来存储log buffer中的block镜像的。

## **Log Sequence Number**

自系统开始运行，就不断的在修改页面，也就意味着会不断的生成redo日志。redo日志的量在不断的递增，就像人的年龄一样，自打出生起就不断递增，永远不可能缩减了。

InnoDB为记录已经写入的redo日志量，设计了一个称之为Log Sequence Number的全局变量，翻译过来就是：日志序列号，简称LSN。规定初始的lsn值为8704（也就是一条redo日志也没写入时，LSN的值为8704）。

redo日志都有一个唯一的LSN值与其对应，LSN值越小，说明redo日志产生的越早。

### **flushed\_to\_disk\_lsn**

redo日志是首先写到log buffer中，之后才会被刷新到磁盘上的redo日志文件。InnoDB中有一个称之为buf\_next\_to\_write的全局变量，标记当前log buffer中已经有哪些日志被刷新到磁盘中了。

我们前边说lsn是表示当前系统中写入的redo日志量，这包括了写到log buffer而没有刷新到磁盘的日志，相应的，InnoDB也有一个表示刷新到磁盘中的redo日志量的全局变量，称之为flushed\_to\_disk\_lsn。系统第一次启动时，该变量的值和初始的lsn值是相同的，都是8704。随着系统的运行，redo日志被不断写入log buffer，但是并不会立即刷新到磁盘，lsn的值就和flushed\_to\_disk\_lsn的值拉开了差距。我们演示一下：

系统第一次启动后，向log buffer中写入了mtr\_1、mtr\_2、mtr\_3这三个redo日志，假设这三个mtr开始和结束时对应的lsn值分别是：

mtr\_1：8716 ～ 8916

mtr\_2：8916 ～ 9948

mtr\_3：9948 ～ 10000

此时的lsn已经增长到了10000，但是由于没有刷新操作，所以此时flushed\_to\_disk\_lsn的值仍为8704。

随后进行将log buffer中的block刷新到redo日志文件的操作，假设将mtr\_1和mtr\_2的日志刷新到磁盘，那么flushed\_to\_disk\_lsn就应该增长mtr\_1和mtr\_2写入的日志量，所以flushed\_to\_disk\_lsn的值增长到了9948。

综上所述，当有新的redo日志写入到log buffer时，首先lsn的值会增长，但flushed\_to\_disk\_lsn不变，随后随着不断有log buffer中的日志被刷新到磁盘上，flushed\_to\_disk\_lsn的值也跟着增长。如果两者的值相同时，说明log buffer中的所有redo日志都已经刷新到磁盘中了。

Tips：应用程序向磁盘写入文件时其实是先写到操作系统的缓冲区中去，如果某个写入操作要等到操作系统确认已经写到磁盘时才返回，那需要调用一下操作系统提供的fsync函数。其实只有当系统执行了fsync函数后，flushed\_to\_disk\_lsn的值才会跟着增长，当仅仅把log buffer中的日志写入到操作系统缓冲区却没有显式的刷新到磁盘时，另外的一个称之为write\_lsn的值跟着增长。

当然系统的LSN值远不止我们前面描述的lsn，还有很多。

### **查看系统中的各种LSN值**

我们可以使用SHOW ENGINE INNODB STATUS命令查看当前InnoDB存储引擎中的各种LSN值的情况，比如：

SHOW ENGINE INNODB STATUS\\G

 ![img](./14%E3%80%81InnoDB%E5%BC%95%E6%93%8E%E5%BA%95%E5%B1%82%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86.assets/20220115185319.png)

其中：

Log sequence number：代表系统中的lsn值，也就是当前系统已经写入的redo日志量，包括写入log buffer中的日志。

Log flushed up to：代表flushed\_to\_disk\_lsn的值，也就是当前系统已经写入磁盘的redo日志量。

Pages flushed up to：代表flush链表中被最早修改的那个页面对应的oldest\_modification属性值。

Last checkpoint at：当前系统的checkpoint\_lsn值。

### innodb\_flush\_log\_at\_trx\_commit的用法

我们前边说为了保证事务的持久性，用户线程在事务提交时需要将该事务执行过程中产生的所有redo日志都刷新到磁盘上。会很明显的降低数据库性能。如果对事务的持久性要求不是那么强烈的话，可以选择修改一个称为innodb\_flush\_log\_at\_trx\_commit的系统变量的值，该变量有3个可选的值：

0：当该系统变量值为0时，表示在事务提交时不立即向磁盘中同步redo日志，这个任务是交给后台线程做的。

这样很明显会加快请求处理速度，但是如果事务提交后服务器挂了，后台线程没有及时将redo日志刷新到磁盘，那么该事务对页面的修改会丢失。

1：当该系统变量值为1时，表示在事务提交时需要将redo日志同步到磁盘，可以保证事务的持久性。1也是innodb\_flush\_log\_at\_trx\_commit的默认值。
![img](./14%E3%80%81InnoDB%E5%BC%95%E6%93%8E%E5%BA%95%E5%B1%82%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86.assets/20220115185325.png)

2：当该系统变量值为2时，表示在事务提交时需要将redo日志写到操作系统的缓冲区中，但并不需要保证将日志真正的刷新到磁盘。

这种情况下如果数据库挂了，操作系统没挂的话，事务的持久性还是可以保证的，但是操作系统也挂了的话，那就不能保证持久性了。

## undo日志

### 事务回滚的需求

我们说过事务需要保证原子性，也就是事务中的操作要么全部完成，要么什么也不做。但是偏偏有时候事务执行到一半会出现一些情况，比如：

情况一：事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误。

情况二：程序员可以在事务执行过程中手动输入ROLLBACK语句结束当前的事务的执行。

这两种情况都会导致事务执行到一半就结束，但是事务执行过程中可能已经修改了很多东西，为了保证事务的原子性，我们需要把东西改回原先的样子，这个过程就称之为回滚（英文名：rollback），这样就可以造成这个事务看起来什么都没做，所以符合原子性要求。

每当我们要对一条记录做改动时（这里的改动可以指INSERT、DELETE、UPDATE），都需要把回滚时所需的东西都给记下来。比方说：

你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉。

你删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中。

你修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值。

这些为了回滚而记录的这些东西称之为撤销日志，英文名为undo log/undo日志。这里需要注意的一点是，由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo日志。

当然，在真实的InnoDB中，undo日志其实并不像我们上边所说的那么简单，不同类型的操作产生的undo日志的格式也是不同的。

### 事务id

#### 给事务分配id的时机

一个事务可以是一个只读事务，或者是一个读写事务：

我们可以通过START TRANSACTION READ ONLY语句开启一个只读事务。

在只读事务中不可以对普通的表（其他事务也能访问到的表）进行增、删、改操作，但可以对用户临时表做增、删、改操作。

我们可以通过START TRANSACTION READ WRITE语句开启一个读写事务，或者使用BEGIN、START TRANSACTION语句开启的事务默认也算是读写事务。

在读写事务中可以对表执行增删改查操作。

如果某个事务执行过程中对某个表执行了增、删、改操作，那么InnoDB存储引擎就会给它分配一个独一无二的事务id，分配方式如下：

对于只读事务来说，只有在它第一次对某个用户创建的临时表执行增、删、改操作时才会为这个事务分配一个事务id，否则的话是不分配事务id的。

我们前边说过对某个查询语句执行EXPLAIN分析它的查询计划时，有时候在Extra列会看到Using temporary的提示，这个表明在执行该查询语句时会用到内部临时表。这个所谓的内部临时表和我们手动用CREATE TEMPORARY TABLE创建的用户临时表并不一样，在事务回滚时并不需要把执行SELECT语句过程中用到的内部临时表也回滚，在执行SELECT语句用到内部临时表时并不会为它分配事务id。

对于读写事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增、删、改操作时才会为这个事务分配一个事务id，否则的话也是不分配事务id的。

有的时候虽然我们开启了一个读写事务，但是在这个事务中全是查询语句，并没有执行增、删、改的语句，那也就意味着这个事务并不会被分配一个事务id。

上边描述的事务id分配策略是针对MySQL 5.7来说的，前边的版本的分配方式可能不同。

#### 事务id生成机制

这个事务id本质上就是一个数字，它的分配策略和我们前边提到的对隐藏列row\_id（当用户没有为表创建主键和UNIQUE键时InnoDB自动创建的列）的分配策略大抵相同，具体策略如下：

服务器会在内存中维护一个全局变量，每当需要为某个事务分配一个事务id时，就会把该变量的值当作事务id分配给该事务，并且把该变量自增1。

每当这个变量的值为256的倍数时，就会将该变量的值刷新到系统表空间的页号为5的页面中一个称之为Max Trx ID的属性处，这个属性占用8个字节的存储空间。

当系统下一次重新启动时，会将上边提到的Max Trx ID属性加载到内存中，将该值加上256之后赋值给我们前边提到的全局变量（因为在上次关机时该全局变量的值可能大于Max Trx ID属性值）。

这样就可以保证整个系统中分配的事务id值是一个递增的数字。先被分配id的事务得到的是较小的事务id，后被分配id的事务得到的是较大的事务id。

#### **trx\_id隐藏列**

我们在学习InnoDB记录行格式的时候重点强调过：聚簇索引的记录除了会保存完整的用户数据以外，而且还会自动添加名为trx\_id、roll\_pointer的隐藏列，如果用户没有在表中定义主键以及UNIQUE键，还会自动添加一个名为row\_id的隐藏列。

![img](./14%E3%80%81InnoDB%E5%BC%95%E6%93%8E%E5%BA%95%E5%B1%82%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86.assets/20220115185406.png)

其中的trx\_id列就是某个对这个聚簇索引记录做改动的语句所在的事务对应的事务id而已（此处的改动可以是INSERT、DELETE、UPDATE操作）。至于roll\_pointer隐藏列我们后边分析。

#### undo日志的格式

为了实现事务的原子性，InnoDB存储引擎在实际进行增、删、改一条记录时，都需要先把对应的undo日志记下来。一般每对一条记录做一次改动，就对应着一条undo日志，但在某些更新记录的操作中，也可能会对应着2条undo日志。

一个事务在执行过程中可能新增、删除、更新若干条记录，也就是说需要记录很多条对应的undo日志，这些undo日志会被从0开始编号，也就是说根据生成的顺序分别被称为第0号undo日志、第1号undo日志、...、第n号undo日志等，这个编号也被称之为undo NO。

我们前边说明表空间的时候说过，表空间其实是由许许多多的页面构成的，页面默认大小为16KB。这些页面有不同的类型，其中有一种称之为FIL\_PAGE\_UNDO\_LOG类型的页面是专门用来存储undo日志的。也就是说Undo page跟储存的数据和索引的页等是类似的。

FIL\_PAGE\_UNDO\_LOG页面可以从系统表空间中分配，也可以从一种专门存放undo日志的表空间，也就是所谓的undo tablespace中分配。先来看看不同操作都会产生什么样子的undo日志。

#### INSERT操作对应的undo日志

当我们向表中插入一条记录时最终导致的结果就是这条记录被放到了一个数据页中。如果希望回滚这个插入操作，那么把这条记录删除就好了，也就是说在写对应的undo日志时，主要是把这条记录的主键信息记上。InnoDB的设计了一个类型为TRX\_UNDO\_INSERT\_REC的undo日志。

当我们向某个表中插入一条记录时，实际上需要向聚簇索引和所有的二级索引都插入一条记录。不过记录undo日志时，我们只需要考虑向聚簇索引插入记录时的情况就好了，因为其实聚簇索引记录和二级索引记录是一一对应的，我们在回滚插入操作时，只需要知道这条记录的主键信息，然后根据主键信息做对应的删除操作，做删除操作时就会顺带着把所有二级索引中相应的记录也删除掉。后边说到的DELETE操作和UPDATE操作对应的undo日志也都是针对聚簇索引记录而言的。

#### roll\_pointer的作用

roll\_pointer本质上就是一个指向记录对应的undo日志的一个指针。比方说我们向表里插入了2条记录，每条记录都有与其对应的一条undo日志。记录被存储到了类型为FIL\_PAGE\_INDEX的页面中（就是我们前边一直所说的数据页），undo日志被存放到了类型为FIL\_PAGE\_UNDO\_LOG的页面中。roll\_pointer本质就是一个指针，指向记录对应的undo日志。

#### DELETE操作对应的undo日志

我们知道插入到页面中的记录会根据记录头信息中的next\_record属性组成一个单向链表，我们把这个链表称之为正常记录链表；被删除的记录其实也会根据记录头信息中的next\_record属性组成一个链表，只不过这个链表中的记录占用的存储空间可以被重新利用，所以也称这个链表为垃圾链表。Page Header部分有一个称之为PAGE\_FREE的属性，它指向由被删除记录组成的垃圾链表中的头节点。

假设此刻某个页面中的记录分布情况是这样的

![img](./14%E3%80%81InnoDB%E5%BC%95%E6%93%8E%E5%BA%95%E5%B1%82%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86.assets/20220115185428.png)

我们只把记录的delete\_mask标志位展示了出来。从图中可以看出，正常记录链表中包含了3条正常记录，垃圾链表里包含了2条已删除记录。页面的Page Header部分的PAGE\_FREE属性的值代表指向垃圾链表头节点的指针。

假设现在我们准备使用DELETE语句把正常记录链表中的最后一条记录给删除掉，其实这个删除的过程需要经历两个阶段：

阶段一：将记录的delete\_mask标识位设置为1，这个阶段称之为delete mark。

![img](./14%E3%80%81InnoDB%E5%BC%95%E6%93%8E%E5%BA%95%E5%B1%82%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86.assets/20220115185436.png)

可以看到，正常记录链表中的最后一条记录的delete\_mask值被设置为1，但是并没有被加入到垃圾链表。也就是此时记录处于一个中间状态。在删除语句所在的事务提交之前，被删除的记录一直都处于这种所谓的中间状态。

为啥会有这种奇怪的中间状态呢？其实主要是为了实现MVCC的功能。

阶段二：当该删除语句所在的事务提交之后，会有专门的线程后来真正的把记录删除掉。所谓真正的删除就是把该记录从正常记录链表中移除，并且加入到垃圾链表中，然后还要调整一些页面的其他信息，比如页面中的用户记录数量PAGE\_N\_RECS、上次插入记录的位置PAGE\_LAST\_INSERT、垃圾链表头节点的指针PAGE\_FREE、页面中可重用的字节数量PAGE\_GARBAGE、还有页目录的一些信息等等。这个阶段称之为purge。

把阶段二执行完了，这条记录就算是真正的被删除掉了。这条已删除记录占用的存储空间也可以被重新利用了。

![img](./14%E3%80%81InnoDB%E5%BC%95%E6%93%8E%E5%BA%95%E5%B1%82%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86.assets/20220115185441.png)

从上边的描述中我们也可以看出来，在删除语句所在的事务提交之前，只会经历阶段一，也就是delete mark阶段（提交之后我们就不用回滚了，所以只需考虑对删除操作的阶段一做的影响进行回滚）。InnoDB中就会产生一种称之为TRX\_UNDO\_DEL\_MARK\_REC类型的undo日志。

#### **版本链**

同时，在对一条记录进行delete mark操作前，需要把该记录的旧的trx\_id和roll\_pointer隐藏列的值都给记到对应的undo日志中来，就是我们图中显示的old trx\_id和old roll\_pointer属性。这样有一个好处，那就是可以通过undo日志的old roll\_pointer找到记录在修改之前对应的undo日志。比方说在一个事务中，我们先插入了一条记录，然后又执行对该记录的删除操作，这个过程的示意图就是这样：

![img](./14%E3%80%81InnoDB%E5%BC%95%E6%93%8E%E5%BA%95%E5%B1%82%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86.assets/20220115185448.png)

从图中可以看出来，执行完delete mark操作后，它对应的undo日志和INSERT操作对应的undo日志就串成了一个链表。这个链表就称之为版本链。版本链在事务的隔离性中有很重要的作用，具体请参考第四期MySQL《07-VIP-深入理解MVCC与BufferPool缓存机制》

#### **UPDATE操作对应的undo日志**

在执行UPDATE语句时，InnoDB对更新主键和不更新主键这两种情况有截然不同的处理方案。

**不更新主键的情况**

在不更新主键的情况下，又可以细分为被更新的列占用的存储空间不发生变化和发生变化的情况。

**就地更新（in-place update）**

更新记录时，对于被更新的每个列来说，如果更新后的列和更新前的列占用的存储空间都一样大，那么就可以进行就地更新，也就是直接在原记录的基础上修改对应列的值。再次强调一边，是每个列在更新前后占用的存储空间一样大，有任何一个被更新的列更新前比更新后占用的存储空间大，或者更新前比更新后占用的存储空间小都不能进行就地更新。

**先删除掉旧记录，再插入新记录**

在不更新主键的情况下，如果有任何一个被更新的列更新前和更新后占用的存储空间大小不一致，那么就需要先把这条旧的记录从聚簇索引页面中删除掉，然后再根据更新后列的值创建一条新的记录插入到页面中。

请注意一下，我们这里所说的删除并不是delete mark操作，而是真正的删除掉，也就是把这条记录从正常记录链表中移除并加入到垃圾链表中，并且修改页面中相应的统计信息（比如PAGE\_FREE、PAGE\_GARBAGE等这些信息）。由用户线程同步执行真正的删除操作，真正删除之后紧接着就要根据各个列更新后的值创建的新记录插入。

这里如果新创建的记录占用的存储空间大小不超过旧记录占用的空间，那么可以直接重用被加入到垃圾链表中的旧记录所占用的存储空间，否则的话需要在页面中新申请一段空间以供新记录使用，如果本页面内已经没有可用的空间的话，那就需要进行页面分裂操作，然后再插入新记录。

针对UPDATE不更新主键的情况（包括上边所说的就地更新和先删除旧记录再插入新记录），InnoDB设计了一种类型为TRX\_UNDO\_UPD\_EXIST\_REC的undo日志。

**更新主键的情况**

在聚簇索引中，记录是按照主键值的大小连成了一个单向链表的，如果我们更新了某条记录的主键值，意味着这条记录在聚簇索引中的位置将会发生改变，比如你将记录的主键值从1更新为10000，如果还有非常多的记录的主键值分布在1 ~ 10000之间的话，那么这两条记录在聚簇索引中就有可能离得非常远，甚至中间隔了好多个页面。针对UPDATE语句中更新了记录主键值的这种情况，InnoDB在聚簇索引中分了两步处理：

**将旧记录进行delete mark操作**

也就是说在UPDATE语句所在的事务提交前，对旧记录只做一个delete mark操作，在事务提交后才由专门的线程做purge操作，把它加入到垃圾链表中。这里一定要和我们上边所说的在不更新记录主键值时，先真正删除旧记录，再插入新记录的方式区分开！

之所以只对旧记录做delete mark操作，是因为别的事务同时也可能访问这条记录，如果把它真正的删除加入到垃圾链表后，别的事务就访问不到了。这个功能就是所谓的MVCC。

**创建一条新记录**

根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中（需重新定位插入的位置）。

由于更新后的记录主键值发生了改变，所以需要重新从聚簇索引中定位这条记录所在的位置，然后把它插进去。

针对UPDATE语句更新记录主键值的这种情况，在对该记录进行delete mark操作前，会记录一条类型为TRX\_UNDO\_DEL\_MARK\_REC的undo日志；之后插入新记录时，会记录一条类型为TRX\_UNDO\_INSERT\_REC的undo日志，也就是说每对一条记录的主键值做改动时，会记录2条undo日志。

### 总结事务的流程

总的来说，事务流程分为事务的执行流程和事务恢复流程。

#### 事务执行

我们已经知道了MySQL的事务主要主要是通过 Redo Log和 Undo Log实现的。

MySQL事务执行流程如下图

![img](./14%E3%80%81InnoDB%E5%BC%95%E6%93%8E%E5%BA%95%E5%B1%82%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86.assets/20220115185502.png)

可以看出，MySQL在事务执行的过程中，会记录相应SQL语句的UndoLog 和 Redo Log，然后在内存中更新数据并形成数据脏页。接下来RedoLog会根据一定规则触发刷盘操作，Undo Log 和数据脏页则通过刷盘机制刷盘。事务提交时，会将当前事务相关的所有Redo Log刷盘，只有当前事务相关的所有Redo Log 刷盘成功，事务才算提交成功。

#### **事务恢复**

如果一切正常，则MySQL事务会按照上图中的顺序执行。如果MySQL由于某种原因崩溃或者宕机，当然进行数据的恢复或者回滚操作。

如果事务在执行第8步,即事务提交之前，MySQL 崩溃或者宕机,此时会先使用Redo Log恢复数据,然后使用Undo Log回滚数据。

如果在执行第8步之后MySQL崩溃或者宕机，此时会使用Redo Log恢复数据，大体流程如下图所示。

![img](./14%E3%80%81InnoDB%E5%BC%95%E6%93%8E%E5%BA%95%E5%B1%82%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86.assets/20220115185512.png)

很明显，MySQL崩溃恢复后，首先会获取日志检查点信息，随后根据日志检查点信息使用Redo Log进行恢复。MySQL崩溃或者宕机时事务未提交，则接下来使用Undo Log回滚数据。如果在MySQL崩溃或者宕机时事务已经提交，则用Redo Log恢复数据即可。

#### **恢复机制**

在服务器不挂的情况下，redo日志简直就是个大累赘，不仅没用，反而让性能变得更差。但是万一数据库挂了，就可以在重启时根据redo日志中的记录就可以将页面恢复到系统崩溃前的状态。

MySQL可以根据redo日志中的各种LSN值，来确定恢复的起点和终点。然后将redo日志中的数据，以哈希表的形式，将一个页面下的放到哈希表的一个槽中。之后就可以遍历哈希表，因为对同一个页面进行修改的redo日志都放在了一个槽里，所以可以一次性将一个页面修复好（避免了很多读取页面的随机IO）。并且通过各种机制，避免无谓的页面修复，比如已经刷新的页面，进而提升崩溃恢复的速度。

#### 崩溃后的恢复为什么不用binlog？

什么是BinLog？请参考第四期MySQL《03-VIP-Mysql内部SQL执行原理》一章。

1、这两者使用方式不一样

binlog 会记录表所有更改操作，包括更新删除数据，更改表结构等等，主要用于人工恢复数据，而 redo log 对于我们是不可见的，它是 InnoDB 用于保证 crash-safe 能力的，也就是在事务提交后MySQL崩溃的话，可以保证事务的持久性，即事务提交后其更改是永久性的。

一句话概括：binlog 是用作人工恢复数据，redo log 是 MySQL 自己使用，用于保证在数据库崩溃时的事务持久性。

2、redo log 是 InnoDB 引擎特有的，binlog 是 MySQL 的 Server 层实现的,所有引擎都可以使用。

3、redo log是物理日志，记录的是“在某个数据页上做了什么修改”，恢复的速度更快；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这的c字段加1 ” ；

4、redo log是“循环写”的日志文件，redo log 只会记录未刷盘的日志，已经刷入磁盘的数据都会从 redo log 这个有限大小的日志文件里删除。binlog 是追加日志，保存的是全量的日志。

5、最重要的是，当数据库 crash 后，想要恢复未刷盘但已经写入 redo log 和 binlog 的数据到内存时，binlog 是无法恢复的。虽然 binlog 拥有全量的日志，但没有一个标志让 innoDB 判断哪些数据已经入表(写入磁盘)，哪些数据还没有。

比如，binlog 记录了两条日志：

给 ID=2 这一行的 c 字段加1

给 ID=2 这一行的 c 字段加1

在记录1入表后，记录2未入表时，数据库 crash。重启后，只通过 binlog 数据库无法判断这两条记录哪条已经写入磁盘，哪条没有写入磁盘，不管是两条都恢复至内存，还是都不恢复，对 ID=2 这行数据来说，都不对。

但 redo log 不一样，只要刷入磁盘的数据，都会从 redo log 中抹掉，数据库重启后，直接把 redo log 中的数据都恢复至内存就可以了。

### Redo日志和Undo日志的关系

数据库崩溃重启后，需要先从redo log中把未落盘的脏页数据恢复回来，重新写入磁盘，保证用户的数据不丢失。当然，在崩溃恢复中还需要把未提交的事务进行回滚操作。由于回滚操作需要undo log日志支持，undo log日志的完整性和可靠性需要redo log日志来保证，所以数据库崩溃需要先做redo log数据恢复，然后做undo log回滚。

在事务执行过程中，除了记录redo一些记录，还会记录undo log日志。Undo log记录了数据每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。

因为redo log是物理日志，记录的是数据库页的物理修改操作。所以undo log（可以看成数据库的数据）的写入也会伴随着redo log的产生，这是因为undo log也需要持久化的保护。

事务进行过程中，每次sql语句执行，都会记录undo log和redo log，然后更新数据形成脏页。事务执行COMMIT操作时，会将本事务相关的所有redo log进行落盘，只有所有的redo log落盘成功，才算COMMIT成功。然后内存中的undo log和脏页按照同样的规则进行落盘。如果此时发生崩溃，则只使用redo log恢复数据。

#### 同时写Redo和Binlog怎么保持一致？

当我们开启了MySQL的BinLog日志，很明显需要保证BinLog和事务日志的一致性，为了保证二者的一致性，使用了两阶段事务2PC（所谓的两个阶段是指：第一阶段：准备阶段和第二阶段：提交阶段，具体的内容请参考分布式事务的相关的课程内容）。步骤如下：

1）当事务提交时InnoDB存储引擎进行prepare操作。

2）MySQL上层会将数据库、数据表和数据表中的数据的更新操作写入BinLog文件。

3）InnoDB存储引擎将事务日志写入Redo Log文件中。

## MySQL8中的新增特性

MySQL8在功能上的我们需要关注增强主要有：账户与安全方面；系统方面；索引方面；InnoDB方面。

### 账户与安全

#### 用户的创建与授权

用户的创建与授权需要两条单独的SQL语句执行

在MySQL5.7的版本：

\> grant all privileges on \*.\* to '用户名'@'主机' identified by '密码'；

在MySQL8.0需要分开执行：

\>create user '用户名'@'主机' identified by '密码'；

\>grant all privileges on \*.\* to '用户名'@'主机'；

用以前的一条命令在8.0里面创建用户，会出现sql语法错误

#### 密码管理

MySQL8.0的密码管理策略提供了3个变量：

1、password\_history 修改密码不允许与最近几次使用或的密码重复，默认是0，即不限制；

2、password\_reuse\_interval 修改密码不允许与最近多少天的使用过的密码重复，默认是0,即不限制；

3、password\_require\_current 修改密码是否需要提供当前的登录密码，默认是OFF,即不需要；如果需要，则设置成ON。

还可针对某一个用户单独设置密码管理策略

alter user '用户名'@'主机' password history 5;

#### 其他

认证插件更新；角色管理也有调整。

### 索引

隐藏索引，被隐藏的索引不会被优化器使用，但依然真实存在，主要用于软删除，可以根据需要后续真正删除或者重新可视化。我们可以隐藏一个索引，然后观察对数据库的影响。如果数据库性能有所下降，就说明这个索引是有用的，于是将其“恢复显示”即可；如果数据库性能看不出变化，说明这个索引是多余的，可以考虑去除了。当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的，这个特性本身是专门为优化调试使用。如果你长期隐藏一个索引，那还不如干脆删掉，因为毕竟索引的存在会影响插入、更新和删除的性能。

开始真正支持降序索引，以往的MySQL虽然支持降序索引，但是写盘的时候依然是升序保存。MySQL8.0中则是真正的按降序保存。

不再对group by操作进行隐式排序。

索引中可以使用函数表达式，创建表时创建一个函数索引，查询的时候使用同样的函数就可以利用索引了。

### 系统方面

#### 原子ddl操作

MySQL5.7执行drop命令 drop table t1,t2; 如果t1存在，t2不存在，会提示t2表不存在，但是t1表仍然会被删除，MySQL8.0执行同样的drop命令，会提示t2表不存在，而且t1表不会被删除，保证了原子性。

#### 自增列持久化

解决了之前的版本，主键重复的问题。MySQL5.7及其以前的版本，MySQL服务器重启，会重新扫描表的主键最大值，如果之前已经删除过id=100的数据，但是表中当前记录的最大值如果是99，那么经过扫描，下一条记录的id是100，而不是101。MySQL8.0则是每次在变化的时候，都会将自增计数器的最大值写入redo log，同时在每次检查点将其写入引擎私有的系统表。则不会出现自增主键重复的问题。

#### 重构SQL分析器

改进SQL分析器。旧的分析器由于其语法复杂性和自顶向下的分析方式从而有严重的限制，导致难以维护和扩展。

#### 新的系统字典表

整合了存储有关数据库对象信息的事务数据字典，所有的元数据都用InnoDB引擎进行存储

#### 支持资源管理

支持创建和管理资源组，并允许将服务器运行的线程分配给特定的组，以便线程根据资源组可用的资源执行

#### 更好支持文档型数据库和JSON

#### 聚合函数

JSON\_ARRAYAGG(),将多行数据组合成json数组

JSON\_OBJECTAGG()，用于生成json对象

JSON实用函数

JSON\_PRETTY() 输出json数据的时候，格式化。

JSON\_STORAGE\_SIZE() json数据所占用的存储空间(单位：字节)

JSON\_STORAGE\_FREE() json数据更新后所释放的空间(单位：字节)

#### JSON合并函数

MySQL8.0废弃了JSON\_MERGE()函数，推荐使用以下两个函数合并JSON数据

JSON\_MERGE\_PATCH()

JSON\_MERGE\_PRESERV()

#### JSON表函数

MySQL8.0新增了JSON\_TABLE()函数，将JSON数据转换成关系表，可以将该函数的返回结果当做一个普通的临时表进行sql查询。

#### 支持RANK(), LAG()、NTILE()等函数

#### 正则表达式增强

提供了REGEXP\_LIKE()，EGEXP\_INSTR(), REGEXP\_REPLACE(), REGEXP\_SUBSTR()等函数

#### 新增备份锁

允许在线备份期间的DML，同时防止可能导致快照不一致的操作。 备份锁由LOCK INSTANCE FOR BACKUP和UNLOCK INSTANCE语法支持

#### 默认字符集

默认字符集由latin1变为utf8mb4

#### 配置参数

#### 全局参数持久化

MySQL 8.0版本支持在线修改全局参数持久化，通过加上PERSIST关键字，可以将调整持久化到新的配置文件中，再次重启db还可以应用到最新的参数。

#### 支持会话级别动态调整部分参数

有利于提升语句性能。

select /\*+ SET\_VAR(sort\_buffer\_size = 16M) \*/ id from test order id ;

insert /\*+ SET\_VAR(foreign\_key\_checks=OFF) \*/ into test(name) values(1);

#### 默认参数的调整

调整back\_log的默认值，保持和 max\_connections一致，增强突发流量带来的连接处理容量。

修改 event\_scheduler 默认为ON，之前默认是关闭的。

调整max\_allowed\_packet 的默认值，从4M增加到64M。

调整bin\_log,log\_slave\_updates默认值为on。

调整expire\_logs\_days的过期时间为30天，老版本是7天，生产环境时，检查该参数，防止binlog过多造成空间紧张。

调整innodb\_undo\_log\_truncate 默认为ON

调整innodb\_undo\_tablespaces 默认值为2

调整innodb\_max\_dirty\_pages\_pct\_lwm 默认值10

调整innodb\_max\_dirty\_pages\_pct默认值为90

新增innodb\_autoinc\_lock\_mode 默认值为2

### InnoDB

innodb 增强

新增INFORMATION\_SCHEMA.INNODB\_CACHED\_INDEXES，查看每个索引缓存在InnoDB缓冲池中的索引页数

InnoDB临时表都将在共享临时表空间ibtmp1中创建

对于SELECT ... FOR SHARE和SELECT ... FOR UPDATE语句，InnoDB支持NOWAIT和SKIP LOCKED

innodb\_undo\_tablespaces的最小值为2，并且不再允许将innodb\_undo\_tablespaces设置为0。 最小值2确保回滚段始终在撤消表空间中创建，而不是在系统表空间中创建

支持 ALTER TABLESPACE ... RENAME TO 语法

新增innodb\_dedicated\_server，让InnoDB根据服务器上检测到的内存量自动配置innodb\_buffer\_pool\_size，innodb\_log\_file\_size，innodb\_flush\_method

新增INFORMATION\_SCHEMA.INNODB\_TABLESPACES\_BRIEF视图

新增了动态配置项 innodb\_deadlock\_detect，用来禁用死锁检查，因为在高并发系统中，当大量线程等待同一个锁时，死锁检查会大大拖慢数据库

支持使用innodb\_directories选项在服务器脱机时将表空间文件移动或恢复到新位置

#### InnoDB性能提升

**并发**

废除buffer pool mutex,将原来一个mutex拆分成多个，提高并发

拆分LOCK\_thd\_list 和 LOCK\_thd\_remove 这两个mutex，大约可提高线程链接效率5%。

**行缓存**

MySQL8.0的优化器可以估算将要读取的行数，因此可以提供给存储引擎一个合适大小的row buffer来存储需要的数据。大批量的连续数据扫描的性能将受益于更大的record buffer

**改进扫描性能**

改进InnoDB范围查询的性能，可提升全表查询和范围查询 5-20%的性能。

**改进成本模型**

InnoDB缓冲区可以估算缓存区中的有多少表和索引，这可以让优化器选择访问方式时知道数据是否可以存储在内存中还是必须存储到磁盘上。

**废弃特性**

移除了一些功能，例如query cache

在线文档：

﻿[http://note.youdao.com/noteshare?id=b4bb951d2d5da6551e6b962f1f35d04c&sub=8634788ECCA24FEE8A698223CDC1BC20](http://note.youdao.com/noteshare?id=b4bb951d2d5da6551e6b962f1f35d04c&sub=8634788ECCA24FEE8A698223CDC1BC20)
