Redisson supports auto-retry policy for each operation and tries to send command during each attempt. Retry policy controlled by `retryAttempts` (default is 3) and `retryInterval` (default is 1000 ms) settings. Each attempt executed after `retryInterval` time interval.

Redisson instances are fully thread-safe. Objects with `synchronous/asynchronous` methods could be reached via [RedissonClient](https://www.javadoc.io/doc/org.redisson/redisson/latest/org/redisson/api/RedissonClient.html) interface.  
`Reactive` and `RxJava3` methods through [RedissonReactiveClient](https://www.javadoc.io/doc/org.redisson/redisson/latest/org/redisson/api/RedissonReactiveClient.html) and [RedissonRxClient](https://www.javadoc.io/doc/org.redisson/redisson/latest/org/redisson/api/RedissonRxClient.html) interfaces respectively.

Here is an example for `RAtomicLong` object:
```java
RedissonClient client = Redisson.create(config);
RAtomicLong longObject = client.getAtomicLong('myLong');
// sync way
longObject.compareAndSet(3, 401);
// async way
RFuture<Boolean> result = longObject.compareAndSetAsync(3, 401);

RedissonReactiveClient client = Redisson.createReactive(config);
RAtomicLongReactive longObject = client.getAtomicLong('myLong');
// reactive way
Mono<Boolean> result = longObject.compareAndSet(3, 401);

RedissonRxClient client = Redisson.createRx(config);
RAtomicLongRx longObject= client.getAtomicLong("myLong");
// RxJava2 way
Flowable<Boolean result = longObject.compareAndSet(3, 401);
```
### 3.1. Async way
Most Redisson objects extend asynchronous interface with asynchronous methods which mirror to synchronous methods. Like this:
```java
// RAtomicLong extends RAtomicLongAsync
RAtomicLongAsync longObject = client.getAtomicLong("myLong");
RFuture<Boolean> future = longObject.compareAndSetAsync(1, 401);
```
Asynchronous method returns extended `RFuture` object extending [CompletionStage](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html) and [Future](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html) interfaces.

```java
future.whenComplete((res, exception) -> {

    // handle both result and exception

});


// or
future.thenAccept(res -> {

    // handle result

}).exceptionally(exception -> {

    // handle exception

});

```
Avoid to use blocking methods in future listeners. Listeners executed by netty-threads and delays in listeners may cause errors in Redis request/response processing. Use follow methods to execute blocking methods in listeners:

```java
future.whenCompleteAsync((res, exception) -> {

    // handle both result and exception

}, executor);


// or
future.thenAcceptAsync(res -> {

    // handle result

}, executor).exceptionallyAsync(exception -> {

    // handle exception

}, executor);
```
### 3.2. Reactive way
Redisson exposes [Reactive Streams](http://reactive-streams.org) API for most objects and based on two implementations:

1. [Project Reactor](https://projectreactor.io) based implementation. Code example:
```java
RedissonReactiveClient client = redissonClient.reactive();

RAtomicLongReactive atomicLong = client.getAtomicLong("myLong");
Mono<Boolean> cs = longObject.compareAndSet(10, 91);
Mono<Long> get = longObject.get();

get.doOnNext(res -> {
   // ...
}).subscribe();
```

2. [RxJava3](https://github.com/ReactiveX/RxJava) based implementation. Code example:
```java
RedissonRxClient client = redissonClient.rxJava();

RAtomicLongRx atomicLong = client.getAtomicLong("myLong");
Single<Boolean> cs = longObject.compareAndSet(10, 91);
Single<Long> get = longObject.get();

get.doOnSuccess(res -> {
   // ...
}).subscribe();
```