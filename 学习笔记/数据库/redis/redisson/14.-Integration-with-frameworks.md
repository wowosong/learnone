### 14.1. Spring Framework

### 14.2. Spring Cache
Redisson provides Redis based Spring Cache implementation made according to Spring Cache specification. Each Cache instance has two important parameters: `ttl` and `maxIdleTime`. Data is stored infinitely if these settings are not defined or equal to `0`.  

Config example:
```java
    @Configuration
    @ComponentScan
    @EnableCaching
    public static class Application {

        @Bean(destroyMethod="shutdown")
        RedissonClient redisson() throws IOException {
            Config config = new Config();
            config.useClusterServers()
                  .addNodeAddress("redis://127.0.0.1:7004", "redis://127.0.0.1:7001");
            return Redisson.create(config);
        }

        @Bean
        CacheManager cacheManager(RedissonClient redissonClient) {
            Map<String, CacheConfig> config = new HashMap<String, CacheConfig>();

            // create "testMap" cache with ttl = 24 minutes and maxIdleTime = 12 minutes
            config.put("testMap", new CacheConfig(24*60*1000, 12*60*1000));
            return new RedissonSpringCacheManager(redissonClient, config);
        }

    }
```

Cache configuration can be read from YAML configuration files:

```java
    @Configuration
    @ComponentScan
    @EnableCaching
    public static class Application {

        @Bean(destroyMethod="shutdown")
        RedissonClient redisson(@Value("classpath:/redisson.yaml") Resource configFile) throws IOException {
            Config config = Config.fromYAML(configFile.getInputStream());
            return Redisson.create(config);
        }

        @Bean
        CacheManager cacheManager(RedissonClient redissonClient) throws IOException {
            return new RedissonSpringCacheManager(redissonClient, "classpath:/cache-config.yaml");
        }

    }
```

#### 14.2.1 Spring Cache. Local cache and data partitioning
Redisson provides various Spring Cache managers with two important features:  

**local cache** - so called `near cache` is used to speed up read operations and avoid network roundtrips. It caches Spring Cache entries on Redisson side and executes read operations up to **45x faster** in comparison with common implementation. Local cache instances with the same name connected to the same pub/sub channel. This channel is used for exchanging of update/invalidate events between instances. Local cache store doesn't use `hashCode()`/`equals()` methods of key object, instead it uses hash of serialized state.  

**data partitioning** - allows to scale available memory, write operations and entry eviction process for individual Spring Cache instance in Redis cluster.  

Below is complete list of available managers:  

|Class name | Local cache | Data<br/>partitioning | Ultra-fast read/write |
| ------------- | :-----------: | :----------:| :----------:|
|RedissonSpringCacheManager<br/><sub><i>open-source version</i></sub> | ❌ | ❌ | ❌ |
|RedissonSpringCacheManager<br/><sub><i>[Redisson PRO](https://redisson.pro) version</i></sub> | ❌ | ❌ | ✔️ |
|RedissonSpringLocalCachedCacheManager<br/><sub><i>available only in [Redisson PRO](https://redisson.pro)</i></sub>  | ✔️ | ❌ | ✔️ |
|RedissonClusteredSpringCacheManager<br/><sub><i>available only in [Redisson PRO](https://redisson.pro)</i></sub> | ❌ | ✔️ | ✔️ |
|RedissonClusteredSpringLocalCachedCacheManager<br/><sub><i>available only in [Redisson PRO](https://redisson.pro)</i></sub> | ✔️ | ✔️ | ✔️ |


Follow options object should be supplied during `org.redisson.spring.cache.RedissonSpringLocalCachedCacheManager` or `org.redisson.spring.cache.RedissonClusteredSpringLocalCachedCacheManager` initialization:

```java
      LocalCachedMapOptions options = LocalCachedMapOptions.defaults()

      // Defines whether to store a cache miss into the local cache.
      // Default value is false.
      .storeCacheMiss(false);

      // Defines store mode of cache data.
      // Follow options are available:
      // LOCALCACHE - store data in local cache only.
      // LOCALCACHE_REDIS - store data in both Redis and local cache.
      .storeMode(StoreMode.LOCALCACHE_REDIS)

      // Defines Cache provider used as local cache store.
      // Follow options are available:
      // REDISSON - uses Redisson own implementation
      // CAFFEINE - uses Caffeine implementation
      .cacheProvider(CacheProvider.REDISSON)

      // Defines local cache eviction policy.
      // Follow options are available:
      // LFU - Counts how often an item was requested. Those that are used least often are discarded first.
      // LRU - Discards the least recently used items first
      // SOFT - Uses weak references, entries are removed by GC
      // WEAK - Uses soft references, entries are removed by GC
      // NONE - No eviction
     .evictionPolicy(EvictionPolicy.NONE)

      // If cache size is 0 then local cache is unbounded.
     .cacheSize(1000)

      // Used to load missed updates during any connection failures to Redis. 
      // Since, local cache updates can't be get in absence of connection to Redis. 
      // Follow reconnection strategies are available:
      // CLEAR - Clear local cache if map instance has been disconnected for a while.
      // LOAD - Store invalidated entry hash in invalidation log for 10 minutes
      //        Cache keys for stored invalidated entry hashes will be removed 
      //        if LocalCachedMap instance has been disconnected less than 10 minutes
      //        or whole cache will be cleaned otherwise.
      // NONE - Default. No reconnection handling
     .reconnectionStrategy(ReconnectionStrategy.NONE)

      // Used to synchronize local cache changes.
      // Follow sync strategies are available:
      // INVALIDATE - Default. Invalidate cache entry across all LocalCachedMap instances on map entry change
      // UPDATE - Insert/update cache entry across all LocalCachedMap instances on map entry change
      // NONE - No synchronizations on map changes
     .syncStrategy(SyncStrategy.INVALIDATE)

      // time to live for each map entry in local cache
     .timeToLive(10000)
      // or
     .timeToLive(10, TimeUnit.SECONDS)

      // max idle time for each map entry in local cache
     .maxIdle(10000)
      // or
     .maxIdle(10, TimeUnit.SECONDS);
```

Each Spring Cache instance has two important parameters: `ttl` and `maxIdleTime` and stores data infinitely if they are not defined or equal to `0`.

Complete config example:
```java
    @Configuration
    @ComponentScan
    @EnableCaching
    public static class Application {

        @Bean(destroyMethod="shutdown")
        RedissonClient redisson() throws IOException {
            Config config = new Config();
            config.useClusterServers()
                  .addNodeAddress("redis://127.0.0.1:7004", "redis://127.0.0.1:7001");
            return Redisson.create(config);
        }

        @Bean
        CacheManager cacheManager(RedissonClient redissonClient) {
            Map<String, CacheConfig> config = new HashMap<String, CacheConfig>();

            // define local cache settings for "testMap" cache.
            // ttl = 48 minutes and maxIdleTime = 24 minutes for local cache entries
            LocalCachedMapOptions options = LocalCachedMapOptions.defaults()
                .evictionPolicy(EvictionPolicy.LFU)
                .timeToLive(48, TimeUnit.MINUTES)
                .maxIdle(24, TimeUnit.MINUTES);
                .cacheSize(1000);
     
            // create "testMap" Redis cache with ttl = 24 minutes and maxIdleTime = 12 minutes
            LocalCachedCacheConfig cfg = new LocalCachedCacheConfig(24*60*1000, 12*60*1000, options);
            // Max size of map stored in Redis
            cfg.setMaxSize(2000);
            config.put("testMap", cfg);
            return new RedissonSpringLocalCachedCacheManager(redissonClient, config);
        }

    }
```

Cache configuration could be read from YAML configuration files:

```java
    @Configuration
    @ComponentScan
    @EnableCaching
    public static class Application {

        @Bean(destroyMethod="shutdown")
        RedissonClient redisson(@Value("classpath:/redisson.yaml") Resource configFile) throws IOException {
            Config config = Config.fromYAML(configFile.getInputStream());
            return Redisson.create(config);
        }

        @Bean
        CacheManager cacheManager(RedissonClient redissonClient) throws IOException {
            return new RedissonSpringLocalCachedCacheManager(redissonClient, "classpath:/cache-config.yaml");
        }

    }
```

#### 14.2.2 Spring Cache. YAML config format
Below is the configuration of Spring Cache with name `testMap` in YAML format:

```yaml
---
testMap:
  ttl: 1440000
  maxIdleTime: 720000
  localCacheOptions:
    invalidationPolicy: "ON_CHANGE"
    evictionPolicy: "NONE"
    cacheSize: 0
    timeToLiveInMillis: 0
    maxIdleInMillis: 0
```

_Please note: `localCacheOptions` settings are available for `org.redisson.spring.cache.RedissonSpringLocalCachedCacheManager` and `org.redisson.spring.cache.RedissonSpringClusteredLocalCachedCacheManager` classes only._

### 14.3. Hibernate Cache
Please find more information regarding this chapter [here](https://github.com/redisson/redisson/tree/master/redisson-hibernate).

#### 14.3.1. Hibernate Cache. Local cache and data partitioning

Please find more information regarding this chapter [here](https://github.com/redisson/redisson/tree/master/redisson-hibernate).

### 14.4 JCache API (JSR-107) implementation
Redisson provides an implementation of JCache API ([JSR-107](https://www.jcp.org/en/jsr/detail?id=107)) for Redis.

Below are examples of JCache API usage.

**1.** Using default config located at `/redisson-jcache.yaml`:
```java
MutableConfiguration<String, String> config = new MutableConfiguration<>();
        
CacheManager manager = Caching.getCachingProvider().getCacheManager();
Cache<String, String> cache = manager.createCache("namedCache", config);
```

**2.** Using config file with custom location:
```java
MutableConfiguration<String, String> config = new MutableConfiguration<>();

// yaml config
URI redissonConfigUri = getClass().getResource("redisson-jcache.yaml").toURI();
CacheManager manager = Caching.getCachingProvider().getCacheManager(redissonConfigUri, null);
Cache<String, String> cache = manager.createCache("namedCache", config);
```

**3.** Using Redisson's config object:
```java
MutableConfiguration<String, String> jcacheConfig = new MutableConfiguration<>();

Config redissonCfg = ...
Configuration<String, String> config = RedissonConfiguration.fromConfig(redissonCfg, jcacheConfig);

CacheManager manager = Caching.getCachingProvider().getCacheManager();
Cache<String, String> cache = manager.createCache("namedCache", config);
```

**4.** Using Redisson instance object:
```java
MutableConfiguration<String, String> jcacheConfig = new MutableConfiguration<>();

RedissonClient redisson = ...
Configuration<String, String> config = RedissonConfiguration.fromInstance(redisson, jcacheConfig);

CacheManager manager = Caching.getCachingProvider().getCacheManager();
Cache<String, String> cache = manager.createCache("namedCache", config);
```

Read more [here](https://github.com/redisson/redisson/wiki/2.-Configuration) about Redisson configuration.

Provided implementation fully passes TCK tests. Here is the [test](https://github.com/cruftex/jsr107-test-zoo/tree/master/redisson-V2-test) module.

#### 14.4.1 JCache API. Asynchronous, Reactive and RxJava3 interfaces

Along with usual JCache API, Redisson provides Asynchronous, Reactive and RxJava3 API.

**[Asynchronous interface](https://static.javadoc.io/org.redisson/redisson/3.11.6/org/redisson/api/CacheAsync.html)**. Each method returns `org.redisson.api.RFuture` object.  
Example:

```java
MutableConfiguration<String, String> config = new MutableConfiguration<>();
        
CacheManager manager = Caching.getCachingProvider().getCacheManager();
Cache<String, String> cache = manager.createCache("myCache", config);

CacheAsync<String, String> asyncCache = cache.unwrap(CacheAsync.class);
RFuture<Void> putFuture = asyncCache.putAsync("1", "2");
RFuture<String> getFuture = asyncCache.getAsync("1");
```

**[Reactive interface](https://static.javadoc.io/org.redisson/redisson/latest/org/redisson/api/CacheReactive.html)**. Each method returns `reactor.core.publisher.Mono` object.  
Example:

```java
MutableConfiguration<String, String> config = new MutableConfiguration<>();
        
CacheManager manager = Caching.getCachingProvider().getCacheManager();
Cache<String, String> cache = manager.createCache("myCache", config);

CacheReactive<String, String> reactiveCache = cache.unwrap(CacheReactive.class);
Mono<Void> putFuture = reactiveCache.put("1", "2");
Mono<String> getFuture = reactiveCache.get("1");
```

**[RxJava3 interface](https://static.javadoc.io/org.redisson/redisson/latest/org/redisson/api/CacheRx.html)**. Each method returns one of the following object: `io.reactivex.Completable`, `io.reactivex.Single`, `io.reactivex.Maybe`.  
Example:

```java
MutableConfiguration<String, String> config = new MutableConfiguration<>();
        
CacheManager manager = Caching.getCachingProvider().getCacheManager();
Cache<String, String> cache = manager.createCache("myCache", config);

CacheRx<String, String> rxCache = cache.unwrap(CacheRx.class);
Completable putFuture = rxCache.put("1", "2");
Maybe<String> getFuture = rxCache.get("1");
```
#### 14.4.2 JCache API. Local cache and data partitioning

Redisson provides JCache implementations with two important features:  

**local cache** - so called `near cache` is used to speed up read operations and avoid network roundtrips. It caches Spring Cache entries on Redisson side and executes read operations up to **45x faster** in comparison with common implementation. Local cache instances with the same name connected to the same pub/sub channel. This channel is used for exchanging of update/invalidate events between instances. Local cache store doesn't use `hashCode()`/`equals()` methods of key object, instead it uses hash of serialized state.  

**data partitioning** - allows to scale available memory, write operations and entry eviction process for individual Spring Cache instance in Redis cluster.  

Below is the complete list of available managers:  

| | Local cache | Data<br/>partitioning | Ultra-fast read/write |
| ------------- | :-----------: | :----------:| :----------:|
|JCache<br/><sub><i>open-source version</i></sub> | ❌ | ❌ | ❌ |
|JCache<br/><sub><i>[Redisson PRO](https://redisson.pro) version</i></sub> | ❌ | ❌ | ✔️ |
|JCache with local cache<br/><sub><i>available only in [Redisson PRO](https://redisson.pro)</i></sub>  | ✔️ | ❌ | ✔️ |
|JCache with data partitioning<br/><sub><i>available only in [Redisson PRO](https://redisson.pro)</i></sub> | ❌ | ✔️ | ✔️ |

##### 1.1. Local cache configuration:

```java
      LocalCacheConfiguration<String, String> configuration = new LocalCacheConfiguration<>()

      // Defines whether to store a cache miss into the local cache.
      // Default value is false.
      .storeCacheMiss(false);

      // Defines store mode of cache data.
      // Follow options are available:
      // LOCALCACHE - store data in local cache only and use Redis only for data update/invalidation.
      // LOCALCACHE_REDIS - store data in both Redis and local cache.
      .storeMode(StoreMode.LOCALCACHE_REDIS)

      // Defines Cache provider used as local cache store.
      // Follow options are available:
      // REDISSON - uses Redisson own implementation
      // CAFFEINE - uses Caffeine implementation
      .cacheProvider(CacheProvider.REDISSON)

      // Defines local cache eviction policy.
      // Follow options are available:
      // LFU - Counts how often an item was requested. Those that are used least often are discarded first.
      // LRU - Discards the least recently used items first
      // SOFT - Uses weak references, entries are removed by GC
      // WEAK - Uses soft references, entries are removed by GC
      // NONE - No eviction
     .evictionPolicy(EvictionPolicy.NONE)

      // If cache size is 0 then local cache is unbounded.
     .cacheSize(1000)

      // Used to load missed updates during any connection failures to Redis. 
      // Since, local cache updates can't be get in absence of connection to Redis. 
      // Follow reconnection strategies are available:
      // CLEAR - Clear local cache if map instance has been disconnected for a while.
      // LOAD - Store invalidated entry hash in invalidation log for 10 minutes
      //        Cache keys for stored invalidated entry hashes will be removed 
      //        if LocalCachedMap instance has been disconnected less than 10 minutes
      //        or whole cache will be cleaned otherwise.
      // NONE - Default. No reconnection handling
     .reconnectionStrategy(ReconnectionStrategy.NONE)

      // Used to synchronize local cache changes.
      // Follow sync strategies are available:
      // INVALIDATE - Default. Invalidate cache entry across all LocalCachedMap instances on map entry change
      // UPDATE - Insert/update cache entry across all LocalCachedMap instances on map entry change
      // NONE - No synchronizations on map changes
     .syncStrategy(SyncStrategy.INVALIDATE)

      // time to live for each map entry in local cache
     .timeToLive(10000)
      // or
     .timeToLive(10, TimeUnit.SECONDS)

      // max idle time for each map entry in local cache
     .maxIdle(10000)
      // or
     .maxIdle(10, TimeUnit.SECONDS);
```

##### 1.2. Local cache usage examples:

```java

LocalCacheConfiguration<String, String> config = new LocalCacheConfiguration<>();
                .setEvictionPolicy(EvictionPolicy.LFU)
                .setTimeToLive(48, TimeUnit.MINUTES)
                .setMaxIdle(24, TimeUnit.MINUTES);
                .setCacheSize(1000);
        
CacheManager manager = Caching.getCachingProvider().getCacheManager();
Cache<String, String> cache = manager.createCache("myCache", config);

// or

URI redissonConfigUri = getClass().getResource("redisson-jcache.yaml").toURI();
CacheManager manager = Caching.getCachingProvider().getCacheManager(redissonConfigUri, null);
Cache<String, String> cache = manager.createCache("myCache", config);

// or 

Config redissonCfg = ...
Configuration<String, String> rConfig = RedissonConfiguration.fromConfig(redissonCfg, config);

CacheManager manager = Caching.getCachingProvider().getCacheManager();
Cache<String, String> cache = manager.createCache("namedCache", rConfig);
```

##### 1.3. Data partitioning usage examples:

```java

ClusteredConfiguration<String, String> config = new ClusteredConfiguration<>();
        
CacheManager manager = Caching.getCachingProvider().getCacheManager();
Cache<String, String> cache = manager.createCache("myCache", config);

// or

URI redissonConfigUri = getClass().getResource("redisson-jcache.yaml").toURI();
CacheManager manager = Caching.getCachingProvider().getCacheManager(redissonConfigUri, null);
Cache<String, String> cache = manager.createCache("myCache", config);

// or 

Config redissonCfg = ...
Configuration<String, String> rConfig = RedissonConfiguration.fromConfig(redissonCfg, config);

CacheManager manager = Caching.getCachingProvider().getCacheManager();
Cache<String, String> cache = manager.createCache("namedCache", rConfig);
```


### 14.5. MyBatis Cache
Please find more information regarding this chapter [here](https://github.com/redisson/redisson/tree/master/redisson-mybatis).

#### 14.5.1. MyBatis Cache. Local cache and data partitioning

Please find more information regarding this chapter [here](https://github.com/redisson/redisson/tree/master/redisson-mybatis).

### 14.6. Tomcat Redis Session Manager

Please find more information regarding this chapter [here](https://github.com/redisson/redisson/tree/master/redisson-tomcat).

### 14.7. Spring Session
Please note that Redis `notify-keyspace-events` setting should contain `Exg` letters to make Spring Session integration work.

Ensure you have Spring Session library in your classpath, add it if necessary:
   #### Maven
   ```xml
   <dependency>
       <groupId>org.springframework.session</groupId>
       <artifactId>spring-session-core</artifactId>
       <version>2.5.2</version>
   </dependency>

   <dependency>
      <groupId>org.redisson</groupId>
      <artifactId>redisson-spring-data-25</artifactId>
      <version>3.16.0</version>
   </dependency>
   ```

   #### Gradle
   ```gradle
   compile 'org.springframework.session:spring-session-core:2.5.2'

   compile 'org.redisson:redisson-spring-data-25:3.16.0'
   ```  

#### Usage example of Spring Http Session configuration:

Add configuration class which extends `AbstractHttpSessionApplicationInitializer` class:
   ```java
   @Configuration
   @EnableRedisHttpSession
   public class SessionConfig extends AbstractHttpSessionApplicationInitializer { 

        @Bean
        public RedissonConnectionFactory redissonConnectionFactory(RedissonClient redisson) {
            return new RedissonConnectionFactory(redisson);
        }

        @Bean(destroyMethod = "shutdown")
        public RedissonClient redisson(@Value("classpath:/redisson.yaml") Resource configFile) throws IOException {
           Config config = Config.fromYAML(configFile.getInputStream());
           return Redisson.create(config);
        }

   }
   ```

#### Usage example of Spring WebFlux’s Session configuration:

Add configuration class which extends `AbstractReactiveWebInitializer` class:
   ```java
   @Configuration
   @EnableRedisWebSession
   public class SessionConfig extends AbstractReactiveWebInitializer { 

        @Bean
        public RedissonConnectionFactory redissonConnectionFactory(RedissonClient redisson) {
            return new RedissonConnectionFactory(redisson);
        }

        @Bean(destroyMethod = "shutdown")
        public RedissonClient redisson(@Value("classpath:/redisson.yaml") Resource configFile) throws IOException {
           Config config = Config.fromYAML(configFile.getInputStream());
           return Redisson.create(config);
        }
   }
   ```

#### Usage example with Spring Boot configuration:

1. Add Spring Session Data Redis library in classpath:
   #### Maven
   ```xml
   <dependency>
      <groupId>org.springframework.session</groupId>
      <artifactId>spring-session-data-redis</artifactId>
      <version>2.4.2</version>
   </dependency>
   ```
   #### Gradle
   ```gradle
   compile 'org.springframework.session:spring-session-data-redis:2.4.2'  
   ```  

2. Add Redisson Spring Data Redis library in classpath:
   #### Maven
   ```xml
   <dependency>
      <groupId>org.redisson</groupId>
      <artifactId>redisson-spring-data-24</artifactId>
      <version>3.15.5</version>
   </dependency>
   ```
   #### Gradle
   ```gradle
   compile 'org.redisson:redisson-spring-data-24:3.15.5'  
   ```  

3. Define follow properties in spring-boot settings

```
spring.session.store-type=redis
spring.redis.redisson.file=classpath:redisson.yaml
spring.session.timeout.seconds=900
```

Try __[Redisson PRO](https://redisson.pro)__ with **ultra-fast performance** and **support by SLA**.

### 14.8. Spring Transaction Manager
 
Redisson provides implementation of both `org.springframework.transaction.PlatformTransactionManager` and `org.springframework.transaction.ReactiveTransactionManager` interfaces to participant in Spring transactions. See also [Transactions](./10.-Additional-features#104-transactions) section.

#### Usage example of Spring Transaction Management:

```java
@Configuration
@EnableTransactionManagement
public class RedissonTransactionContextConfig {
    
    @Bean
    public TransactionalBean transactionBean() {
        return new TransactionalBean();
    }
    
    @Bean
    public RedissonTransactionManager transactionManager(RedissonClient redisson) {
        return new RedissonTransactionManager(redisson);
    }
    
    @Bean(destroyMethod="shutdown")
    public RedissonClient redisson(@Value("classpath:/redisson.yaml") Resource configFile) throws IOException {
         Config config = Config.fromYAML(configFile.getInputStream());
        return Redisson.create(config);
    }
    
}


public class TransactionalBean {

    @Autowired
    private RedissonTransactionManager transactionManager;

    @Transactional
    public void commitData() {
        RTransaction transaction = transactionManager.getCurrentTransaction();
        RMap<String, String> map = transaction.getMap("test1");
        map.put("1", "2");
    }

}
```

#### Usage example of Reactive Spring Transaction Management:

```java
@Configuration
@EnableTransactionManagement
public class RedissonReactiveTransactionContextConfig {
    
    @Bean
    public TransactionalBean transactionBean() {
        return new TransactionalBean();
    }
    
    @Bean
    public ReactiveRedissonTransactionManager transactionManager(RedissonReactiveClient redisson) {
        return new ReactiveRedissonTransactionManager(redisson);
    }
    
    @Bean(destroyMethod="shutdown")
    public RedissonReactiveClient redisson(@Value("classpath:/redisson.yaml") Resource configFile) throws IOException {
         Config config = Config.fromYAML(configFile.getInputStream());
        return Redisson.createReactive(config);
    }
    
}

public class TransactionalBean {

    @Autowired
    private ReactiveRedissonTransactionManager transactionManager;

    @Transactional
    public Mono<Void> commitData() {
        Mono<RTransactionReactive> transaction = transactionManager.getCurrentTransaction();
        return transaction.flatMap(t -> {
            RMapReactive<String, String> map = t.getMap("test1");
            return map.put("1", "2");
        }).then();
    }

}
```

### 14.9. Spring Data Redis

Please find information regarding this chapter [here](https://github.com/redisson/redisson/tree/master/redisson-spring-data#spring-data-redis-integration).

### 14.10. Spring Boot Starter

Please find the information regarding this chapter [here](https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter#spring-boot-starter).

### 14.11. Micronaut
Please find the information regarding this chapter [here](https://github.com/redisson/redisson/tree/master/redisson-micronaut).

### 14.12. Quarkus
Please find the information regarding this chapter [here](https://github.com/redisson/redisson/tree/master/redisson-quarkus).

### 14.13. Helidon
Please find the information regarding this chapter [here](https://github.com/redisson/redisson/tree/master/redisson-helidon).

### 14.14. Statistics monitoring (JMX and other systems)

_This feature is available only in [Redisson PRO](https://redisson.pro)_

Redisson provides integration with different monitoring systems:

#### 1. AppOptics
| | |
|-|-|
|Class| org.redisson.config.metrics.AppOpticsMeterRegistryProvider |
|Params| `uri` - AppOptics host uri<br/>`hostTag` - tag mapped to host<br/>`apiToken` - AppOptics api token<br/>`numThreads` - number of threads used by scheduler (default is 2)<br/>`step` - update interval in ISO-8601 format (default is 1 min)<br/>`batchSize` - number of measurements sent per request (default is 500) |
|Dependency| groupId: `io.micrometer`<br/>artifactId: `micrometer-registry-appoptics` |

#### 2. Atlas
| | |
|-|-|
|Class| org.redisson.config.metrics.AtlasMeterRegistryProvider |
|Params| `uri` - Atlas host uri<br/>`configUri` - Atlas LWC endpoint uri to retrieve current subscriptions<br/>`evalUri` - Atlas LWC endpoint uri to evaluate the data for a subscription<br/>`numThreads` - number of threads used by scheduler (default is 4)<br/>`step` - update interval in ISO-8601 format (default is 1 min)<br/>`batchSize` - number of measurements sent per request (default is 10000) |
|Dependency| groupId: `io.micrometer`<br/>artifactId: `micrometer-registry-atlas` |

#### 3. Azure
| | |
|-|-|
|Class| org.redisson.config.metrics.AzureMonitorMeterRegistryProvider |
|Params| `instrumentationKey` - instrumentation key<br/>`numThreads` - number of threads used by scheduler (default is 2)<br/>`step` - update interval in ISO-8601 format (default is 1 min)<br/>`batchSize` - number of measurements sent per request (default is 500) |
|Dependency| groupId: `io.micrometer`<br/>artifactId: `micrometer-registry-azure-monitor` |

#### 4. Amazon CloudWatch
| | |
|-|-|
|Class| org.redisson.config.metrics.CloudWatchMeterRegistryProvider |
|Params| `accessKey` - AWS access key<br/>`secretKey` - AWS secret access key<br/>`namespace` - namespace value<br/>`numThreads` - number of threads used by scheduler (default is 2)<br/>`step` - update interval in ISO-8601 format (default is 1 min)<br/>`batchSize` - number of measurements sent per request (default is 500) |
|Dependency| groupId: `io.micrometer`<br/>artifactId: `micrometer-registry-cloudwatch` |

#### 5. Datadog
| | |
|-|-|
|Class| org.redisson.config.metrics.DatadogMeterRegistryProvider |
|Params| `uri` - Datadog host uri<br/>`hostTag` - tag mapped to host<br/>`apiKey` - api key<br/>`numThreads` - number of threads used by scheduler (default is 2)<br/>`step` - update interval in ISO-8601 format (default is 1 min)<br/>`batchSize` - number of measurements sent per request (default is 500) |
|Dependency| groupId: `io.micrometer`<br/>artifactId: `micrometer-registry-datadog` |

#### 6. Dropwizard
| | |
|-|-|
|Class| org.redisson.config.metrics.DropwizardMeterRegistryProvider|
|Params| `sharedRegistryName` - name used to store instance in `SharedMetricRegistries`<br/>`nameMapper` - custom implementation of `io.micrometer.core.instrument.util.HierarchicalNameMapper`  |

#### 7. Dynatrace
| | |
|-|-|
|Class| org.redisson.config.metrics.DynatraceMeterRegistryProvider |
|Params| `uri` - Dynatrace host uri<br/>`apiToken` - api token<br/>`deviceId` - device id<br/>`numThreads` - number of threads used by scheduler (default is 2)<br/>`step` - update interval in ISO-8601 format (default is 1 min)<br/>`batchSize` - number of measurements sent per request (default is 500) |
|Dependency| groupId: `io.micrometer`<br/>artifactId: `micrometer-registry-dynatrace` |

#### 8. Elastic
| | |
|-|-|
|Class| org.redisson.config.metrics.ElasticMeterRegistryProvider |
|Params| `host` - Elasticsearch host uri<br/>`userName` - user name<br/>`password` - password<br/>`numThreads` - number of threads used by scheduler (default is 2)<br/>`step` - update interval in ISO-8601 format (default is 1 min)<br/>`batchSize` - number of measurements sent per request (default is 500) |
|Dependency| groupId: `io.micrometer`<br/>artifactId: `micrometer-registry-elastic` |

#### 9. Ganglia
| | |
|-|-|
|Class| org.redisson.config.metrics.GangliaMeterRegistryProvider |
|Params| `host` - Ganglia host address<br/>`port` - Ganglia port<br/>`numThreads` - number of threads used by scheduler (default is 2)<br/>`step` - update interval in ISO-8601 format (default is 1 min)<br/>`batchSize` - number of measurements sent per request (default is 500) |
|Dependency| groupId: `io.micrometer`<br/>artifactId: `micrometer-registry-ganglia` |

#### 10. Graphite
| | |
|-|-|
|Class| org.redisson.config.metrics.GraphiteMeterRegistryProvider |
|Params| `host` - Graphite host address<br/>`port` - Graphite port |
|Dependency| groupId: `io.micrometer`<br/>artifactId: `micrometer-registry-graphite` |

#### 11. Humio
| | |
|-|-|
|Class| org.redisson.config.metrics.HumioMeterRegistryProvider|
|Params| `uri` - Humio host uri<br/>`repository` - repository name<br/>`apiToken` - api token<br/>`numThreads` - number of threads used by scheduler (default is 2)<br/>`step` - update interval in ISO-8601 format (default is 1 min)<br/>`batchSize` - number of measurements sent per request (default is 500) |
|Dependency| groupId: `io.micrometer`<br/>artifactId: `micrometer-registry-humio` |

#### 12. Influx
| | |
|-|-|
|Class| org.redisson.config.metrics.InfluxMeterRegistryProvider|
|Params| `uri` - Influx host uri<br/>`db` - db name<br/>`userName` - user name<br/>`password` - password<br/>`numThreads` - number of threads used by scheduler (default is 2)<br/>`step` - update interval in ISO-8601 format (default is 1 min)<br/>`batchSize` - number of measurements sent per request (default is 500) |
|Dependency| groupId: `io.micrometer`<br/>artifactId: `micrometer-registry-influx` |

#### 13. JMX
| | |
|-|-|
|Class| org.redisson.config.metrics.JmxMeterRegistryProvider|
|Params| `domain` - domain name<br/>`sharedRegistryName` - name used to store instance in `SharedMetricRegistries`|
|Dependency| groupId: `io.micrometer`<br/>artifactId: `micrometer-registry-jmx` |

#### 14. Kairos
| | |
|-|-|
|Class| org.redisson.config.metrics.KairosMeterRegistryProvider|
|Params| `uri` - Kairos host uri<br/>`userName` - user name<br/>`password` - password<br/>`numThreads` - number of threads used by scheduler (default is 2)<br/>`step` - update interval in ISO-8601 format (default is 1 min)<br/>`batchSize` - number of measurements sent per request (default is 500) |
|Dependency| groupId: `io.micrometer`<br/>artifactId: `micrometer-registry-kairos` |

#### 15. NewRelic
| | |
|-|-|
|Class| org.redisson.config.metrics.NewRelicMeterRegistryProvider|
|Params| `uri` - NewRelic host uri<br/>`apiKey` - api key<br/>`accountId` - account id<br/>`numThreads` - number of threads used by scheduler (default is 2)<br/>`step` - update interval in ISO-8601 format (default is 1 min)<br/>`batchSize` - number of measurements sent per request (default is 500) |
|Dependency| groupId: `io.micrometer`<br/>artifactId: `micrometer-registry-new-relic` |

#### 16. Prometheus
| | |
|-|-|
|Class| org.redisson.config.metrics.PrometheusMeterRegistryProvider|
|Params| `registry` - instance of `PrometheusMeterRegistry` object |
|Dependency| groupId: `io.micrometer`<br/>artifactId: `micrometer-registry-prometheus` |

#### 17. SingnalFx
| | |
|-|-|
|Class| org.redisson.config.metrics.SingnalFxMeterRegistryProvider|
|Params| `apiHost` - SingnalFx host uri<br/>`accessToken` - access token<br/>`source` - application instance id<br/>`numThreads` - number of threads used by scheduler (default is 2)<br/>`step` - update interval in ISO-8601 format (default is 10 secs)<br/>`batchSize` - number of measurements sent per request (default is 500) |
|Dependency| groupId: `io.micrometer`<br/>artifactId: `micrometer-registry-signalfx` |

#### 18. Stackdriver
| | |
|-|-|
|Class| org.redisson.config.metrics.StackdriverMeterRegistryProvider|
|Params| `projectId` - project id<br/>`numThreads` - number of threads used by scheduler (default is 2)<br/>`step` - update interval in ISO-8601 format (default is 1 min)<br/>`batchSize` - number of measurements sent per request (default is 500) |
|Dependency| groupId: `io.micrometer`<br/>artifactId: `micrometer-registry-stackdriver` |

#### 19. Statsd
| | |
|-|-|
|Class| org.redisson.config.metrics.StatsdMeterRegistryProvider|
|Params| `host` - Statsd host address<br/>`port` - Statsd port<br/>`flavor` - metrics format ETSY/DATADOG/TELEGRAF/SYSDIG |
|Dependency| groupId: `io.micrometer`<br/>artifactId: `micrometer-registry-statsd` |

#### 20. Wavefront
| | |
|-|-|
|Class| org.redisson.config.metrics.WavefrontMeterRegistryProvider|
|Params| `uri` - Wavefront host uri<br/>`source` - application instance id<br/>`apiToken` - api token<br/>`numThreads` - number of threads used by scheduler (default is 2)<br/>`step` - update interval in ISO-8601 format (default is 1 min)<br/>`batchSize` - number of measurements sent per request (default is 500) |
|Dependency| groupId: `io.micrometer`<br/>artifactId: `micrometer-registry-wavefront` |

#### Config

```java
Config config = ... // redisson config object
JmxMeterRegistryProvider provider = new JmxMeterRegistryProvider();
provider.setDomain("appStats");
config.setMeterRegistryProvider(provider);
```

YAML config is appended to Redisson config:

```yaml
meterRegistryProvider: !<org.redisson.config.metrics.JmxMeterRegistryProvider> 
   domain: "appStats"
```

The following metrics are available:

#### Configuration metrics

* `redisson.license.expiration-year` - A Gauge of the number of expiration year  
* `redisson.license.expiration-month` - A Gauge of the number of expiration month  
* `redisson.license.expiration-day` - A Gauge of the number of expiration day  
* `redisson.license.active-instances` - A Gauge of the number of active Redisson PRO clients  
* `redisson.executor-pool-size` - A Gauge of the number of executor threads pool size  
* `redisson.netty-pool-size` - A Gauge of the number of netty threads pool size  

#### Metrics per Redis node.
Base name: `redisson.redis.<host>:<port>`

* `status` - A Gauge of the string value [connected, disconnected]  
* `type` - A Gauge of the Redis node type [MASTER, SLAVE]  
<br/>

* `total-response-bytes` - A Meter of the total amount of bytes received from Redis  
* `response-bytes` - A Histogram of the number of bytes received from Redis  
* `total-request-bytes` - A Meter of the total amount of bytes sent to Redis  
* `request-bytes` - A Histogram of the number of bytes sent to Redis  
<br/>

* `connections.active` - A Counter of the number of busy connections  
* `connections.free` - A Counter of the number of free connections  
* `connections.max-pool-size` - A Counter of the number of maximum connection pool size  
* `connections.reconnected` - A Counter of the number of reconnected connections  
* `connections.total` - A Counter of the number of total connections in pool  
<br/>

* `operations.total` - A Meter of the number of total executed operations  
* `operations.total-failed` - A Meter of the number of total failed operations  
* `operations.total-successful` - A Meter of the number of total successful operations
<br/>

* `publish-subscribe-connections.active` - A Counter of the number of active publish subscribe connections  
* `publish-subscribe-connections.free` - A Counter of the number of free publish subscribe connections  
* `publish-subscribe-connections.max-pool-size` - A Counter of the number of maximum publish subscribe connection pool size  
* `publish-subscribe-connections.total` - A Counter of the number of total publish subscribe connections in pool  

#### Metrics per RRemoteService object
Base name: `redisson.remote-service.<name>`

* `invocations.total` - A Meter of the number of total executed invocations  
* `invocations.total-failed` - A Meter of the number of total failed to execute invocations  
* `invocations.total-successful` - A Meter of the number of total successful to execute invocations  

#### Metrics per RExecutorService object
Base name: `redisson.executor-service.<name>`

* `tasks.submitted` - A Meter of the number of submitted tasks  
* `tasks.executed` - A Meter of the number of executed tasks  
<br/>

* `workers.active` - A Gauge of the number of busy task workers  
* `workers.free` - A Gauge of the number of free task workers  
* `workers.total` - A Gauge of the number of total task workers  
* `workers.tasks-executed.total` - A Meter of the number of total executed tasks by workers  
* `workers.tasks-executed.total-failed` - A Meter of the number of total failed to execute tasks by workers  
* `workers.tasks-executed.total-successful` - A Meter of the number of total successful to execute tasks by workers  


#### Metrics per RMap object
Base name: `redisson.map.<name>`

* `hits` - A Meter of the number of get requests for data contained in cache  
* `misses` - A Meter of the number of get requests for data not contained in cache  
* `puts` - A Meter of the number of puts to the cache  
* `removals` - A Meter of the number of removals from the cache  

#### Metrics per RMapCache object
Base name: `redisson.map-cache.<name>`

* `hits` - A Meter of the number of get requests for data contained in cache  
* `misses` - A Meter of the number of get requests for data not contained in cache  
* `puts` - A Meter of the number of puts to the cache  
* `removals` - A Meter of the number of removals from the cache  


#### Metrics per RClusteredMapCache object
Base name: `redisson.clustered-map-cache.<name>`

* `hits` - A Meter of the number of get requests for data contained in cache  
* `misses` - A Meter of the number of get requests for data not contained in cache  
* `puts` - A Meter of the number of puts to the cache  
* `removals` - A Meter of the number of removals from the cache  


#### Metrics per RLocalCachedMap object
Base name: `redisson.local-cached-map.<name>`

* `hits` - A Meter of the number of get requests for data contained in cache  
* `misses` - A Meter of the number of get requests for data not contained in cache  
* `puts` - A Meter of the number of puts to the cache  
* `removals` - A Meter of the number of removals from the cache  
<br/>

* `local-cache.hits` - A Meter of the number of get requests for data contained in local cache  
* `local-cache.misses` - A Meter of the number of get requests for data contained in local cache  
* `local-cache.evictions` - A Meter of the number of evictions for data contained in local cache  
* `local-cache.size` - A Gauge of the number of local cache size  

#### Metrics per RClusteredLocalCachedMap object
Base name: `redisson.clustered-local-cached-map.<name>`

* `hits` - A Meter of the number of get requests for data contained in cache  
* `misses` - A Meter of the number of get requests for data not contained in cache  
* `puts` - A Meter of the number of puts to the cache  
* `removals` - A Meter of the number of removals from the cache  
<br/>

* `local-cache.hits` - A Meter of the number of get requests for data contained in local cache  
* `local-cache.misses` - A Meter of the number of get requests for data contained in local cache  
* `local-cache.evictions` - A Meter of the number of evictions for data contained in local cache  
* `local-cache.size` - A Gauge of the number of local cache size  

#### Metrics per RLocalCachedMapCache object
Base name: `redisson.local-cached-map-cache.<name>`

* `hits` - A Meter of the number of get requests for data contained in cache  
* `misses` - A Meter of the number of get requests for data not contained in cache  
* `puts` - A Meter of the number of puts to the cache  
* `removals` - A Meter of the number of removals from the cache  
<br/>

* `local-cache.hits` - A Meter of the number of get requests for data contained in local cache  
* `local-cache.misses` - A Meter of the number of get requests for data contained in local cache  
* `local-cache.evictions` - A Meter of the number of evictions for data contained in local cache  
* `local-cache.size` - A Gauge of the number of local cache size  

#### Metrics per RClusteredLocalCachedMapCache object
Base name: `redisson.clustered-local-cached-map-cache.<name>`

* `hits` - A Meter of the number of get requests for data contained in cache  
* `misses` - A Meter of the number of get requests for data not contained in cache  
* `puts` - A Meter of the number of puts to the cache  
* `removals` - A Meter of the number of removals from the cache  
<br/>

* `local-cache.hits` - A Meter of the number of get requests for data contained in local cache  
* `local-cache.misses` - A Meter of the number of get requests for data contained in local cache  
* `local-cache.evictions` - A Meter of the number of evictions for data contained in local cache  
* `local-cache.size` - A Gauge of the number of local cache size  


#### Metrics per RTopic object
Base name: `redisson.topic.<name>`

* `messages-sent` - A Meter of the number of messages sent for topic  
* `messages-received` - A Meter of the number of messages received for topic  

#### Metrics per RBucket object
Base name: `redisson.bucket.<name>`

* `gets` - A Meter of the number of get operations executed for bucket object
* `sets` - A Meter of the number of set operations executed for bucket object