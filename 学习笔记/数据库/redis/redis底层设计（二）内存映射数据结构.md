# [redis底层设计（二）——内存映射数据结构](https://www.cnblogs.com/gaopengfirst/p/10065796.html)

我们继续接着上一篇博客，今天来看看内存映射数据结构。

上篇我们讲了内部数据结构，虽然内部数据结构非常强大，但是创建一系列完整的数据结构本身也是一件相当耗费时间的工作，当一个对象包含的元素数量并不多，或者元素本身的体积并不大时，使用代价高昂的内部数据结构并不是最好的办法。因此我们会用内存映射数据结构来代替内部数据结构。

内存映射数据结构是一系列经过特殊编码的字节序列，创建他们所消耗的内存通常比作用类似的内部数据结构要少得多，如果使用得当，内存映射数据结构可以为用户节省大量的内存。不过，内存映射数据结构的编码和操作方式要比内部数据结构复杂的多，所以内存映射数据结构所占用的CPU时间会比作用类似的内部结构要多。

## 2.1整数集合

整数集合（intset）用于有序、无重复地保存多个整数值，他会根据元素的值，自动选择该用什么长度的整数类型来保存元素。

### 2.1.1 整数集合的应用

intset是集合键的底层实现之一，如果一个集合满足：

\* 值保存着整数元素；

\* 元素的数量不多；

那么就会使用intset来保存集合元素。

### 2.1.2 数据结构和主要操作

```plain
typedef struct intset {
//
保存元素所使用的类型的长度
uint32_t encoding;
//
元素个数
uint32_t length;
//
保存元素的数组
int8_t contents[];} intset;
```
encoding 的值可以是以下三个常量的其中一个（定义位于intset.c ）：  
#define INTSET\_ENC\_INT16 (sizeof(int16\_t))  
#define INTSET\_ENC\_INT32 (sizeof(int32\_t))  
#define INTSET\_ENC\_INT64 (sizeof(int64\_t))

contents数组是实际保存元素的地方，数组有一下两个特性：

\* 没有重复元素；

\* 从小到大排序；

contents的 int8\_t类型只是作为一个占位符使用，intset不使用int8\_t类型保存任何元素。新增元素默认的encoding是int16\_t,当添加的新元素不适合于当前intset的编码类型时，intset集合将会进行升级。

### 2.1.3 小结

\* intset用于有序、无重复的保存多个整数值。他会根据元素的值，自动选择该用什么长度的整数类型来保存元素；

\* 当一个位长度更长的整数值添加到intset时，需要对intset进行升级，新intset中的每个元素的位长度都等于新添加值的位长度，但原有元素的值不变；

\* 升级会引起整个intset进行内存重分配，并移动集合中的所有元素，这个操作的复杂度为O(N);

\* intset只支持升级，不支持降级；

\* intset是有序的，程序使用二分法查找算法来实现查找操作，复杂度为O(lgN)；

## 2.2 压缩列表 

ziplist 是由一系列特殊编码的内存块构成的列表，一个ziplist 可以包含多个节点（entry），每个节点可以保存一个长度受限的字符数组（不以\\0结尾的char数组）或者整数，包括：　　

• 字符数组  
– 长度小于等于63 （26 - 1）字节的字符数组  
– 长度小于等于16383 （214 - 1）字节的字符数组  
– 长度小于等于4294967295 （232 - 1）字节的字符数组  
• 整数  
– 4 位长，介于0 至12 之间的无符号整数  
– 1 字节长，有符号整数  
– 3 字节长，有符号整数  
– int16\_t 类型整数  
– int32\_t 类型整数  
– int64\_t 类型整数

因为ziplist节约内存的性质，它被哈希键、列表建和有序集合键作为初始化的底层实现来使用。

### 2.2.1 ziplist的结构：

![](./redis%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20220113230032.png)

因为ziplist header 部分的长度总是固定的（4 字节+ 4 字节+ 2 字节），因此将指针移动到表头节点的复杂度为常数时间；除此之外，因为表尾节点的地址可以通过zltail 计算得出，因此将指针移动到表尾节点的复杂度也为常数时间。　　

因为ziplist 由连续的内存块构成，在最坏情况下，当ziplistPush 、ziplistDelete 这类对节点进行增加或删除的函数之后，程序需要执行一种称为连锁更新的动作来维持ziplist 结构本身的性质，所以这些函数的最坏复杂度都为O(N2) 。不过，因为这种最坏情况出现的概率并不高，所以大可以放心使用ziplist ，而不必太担心出现最坏情况。

### 2.2.2 节点的构成：

![](./redis%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20220113230042.png)

pre\_entry\_length:记录了前一个节点的长度，通过这个值，可以进行指针计算，从而跳转到上一个节点。（注：若前一个节点的长度小于254字节，则使用一个字节保存pre\_entry\_length的值，若大于等于254，则使用5个字节保存，其中第一个字节保存254，后4个字节保存前一个节点的实际长度）；

encoding:记录了content的数据类型，长度为2个bit，它的值可以是00、01、10和11（其中00、01和10表示Content中保存着字符数组；11表示content中保存着整数）；

length：记录了content的数据长度；

content：保存着节点的内容

### 2.2.3 小结：

\* ziplist是由一系列特殊编码的内存块构成的列表，它可以保存字符数组或整数值，它还是哈希键、列表键和有序集合键的底层实现之一。

\* 添加和删除ziplist节点有可能会引起连锁更新，因此，添加和删除操作的最坏复杂度为O(N2)，不过，因为连锁更新的出现概率并不高，所以一般可以将添加和删除操作的复杂度视为O(N)。

[«](https://www.cnblogs.com/gaopengfirst/p/10062980.html) 上一篇： [redis底层设计（一）——内部数据结构](https://www.cnblogs.com/gaopengfirst/p/10062980.html "发布于 2018-12-04 11:15")  
[»](https://www.cnblogs.com/gaopengfirst/p/10072680.html) 下一篇： [redis底层设计（三）——redis数据类型](https://www.cnblogs.com/gaopengfirst/p/10072680.html "发布于 2018-12-05 18:47")

