**高并发、微服务 、性能调优实战案例100讲，所有案例均源于个人工作实战，均配合代码落地**

加我微信：<span style="font-weight:bold; color:red">itsoku</span>，所有案例均提供在线答疑。



# 第98节 经典并发案例分析，确实有点难，一起来挑战下

本文如果你能看懂，说明你解决并发问题的能力已经相当高了，先收藏点赞，慢慢看。

<span style="font-weight:bold; color:red">目前整个课程59块钱，100个案例，含所有源码 & 文档 & 技术支持，可点击左下角小黄车了解</span>



# 1、先来了解下业务

如下图，我们有个视频网站，视频下方允许用户发表评论，用户还可以对别人的评论进行回复。

![image-20240914200710601](https://learnone.oss-cn-beijing.aliyuncs.com/pic/202409201110576.png)

评论表如下(t_comment)，比较简单

| 字段                | 描述               |
| ------------------- | ------------------ |
| comment_id          | 评论记录id，主键   |
| video_id            | 被评论的视频id     |
| user_id             | 评论者用户id       |
| reply_to_comment_id | 指向被回复的评论id |
| content             | 评论的内容         |
| create_time         | 评论时间           |



# 2、产品提了2个需求，看下怎么实现？

1. 用户删除评论的时候，需要删掉其所有子评论（也就是其下的回复）
2. 用户对某个评论回复的时候，需要校验被回复的评论必须存在，不存在，则给个错误提示



# 3、方案1：第1个版本代码

## 删除评论的代码

```java
/**
 * 删除评论，顺便会删除所有的子评论
 * @param commentId 评论id
 */
@Transactional
public void deleteComment(String commentId){
	//删除主评论
	delete from t_comment where id = #{commentId};
    
	//删除子评论列表
	delete from t_comment where repay_to_comment_id = #{commentId};
}
```

## 评论回复的代码

```java
/**
 * 对评论进行回复
 * @param videoId 视频id
 * @param userId 用户id
 * @param content 评论内容
 * @param repayToCommentId 被回复的评论id
 */
@Transactional
public void repay(String videoId, String userId, String content, String repayToCommentId){
    //查看主评论是否存在
    CommentPO repayToCommentPO = select * from t_comment where commentId = #{reapyToCommentId};

    //主评论不存在
    if(repayToCommentPO == null){
        throw new RuntimeException("评论不存在");
    }
    //插入评论
    insert t_comment (video_id, user_id, content, repay_to_comment_id)
    values (#{videoId}, #{userId}, #{content}, #{repayToCommentId});
}
```

## 使用并发对代码进行验证

| 时间点 | 请求1：对评论1进行回复 | 请求2：删除评论1                    |
| ------ | ---------------------- | ----------------------------------- |
| T1     | 开启事务               | 开启事务                            |
| T2     | 查询主评论1，存在      |                                     |
| T3     |                        | 调用删除评论的方法，主评论1会被删掉 |
| T4     |                        | 删除评论1下面的所有子评论           |
| T5     |                        | 提交事务                            |
| T6     | 插入子评论，插入成功   |                                     |
| T7     | 提交事务               |                                     |

按照上面这个并发过程，最终的结果就是，评论1被删掉了，但是子评论却插入成功了。

产品要求，主评论删除的时候，所有的子评论都需要删掉，上面这种方案并没有满足产品需求。

怎么解决？见方案2



# 4、方案2：加互斥锁，让2个操作排队执行

## 方法如下

- 删除评论和对评论进行回复的这两个方法，都会用到主评论id，可以对主评论记录加互斥锁，从而保证2个方法在并发情况下，操作同一个主评论的时候排队执行，便可以解决上面的问题

- 目前删除评论的时候，主评论已经加锁了（`delete from t_comment where comment_id = #{commentId}`，数据库中对某一条记录执行delete、update、for update的时候会加互斥锁）

- 调整下评论回复的代码，查询主评论是否存在的时候，采用`for update`的方式对主评论加互斥锁：`select * from t_comment where commentId = #{reapyToCommentId} for update`

评论回复的代码，调整后如下，这样，在同一条主评论上面加了互斥锁，确保2个方法排队执行，就解决了上面的问题。

```java
/**
 * 对评论进行回复
 * @param videoId 视频id
 * @param userId 用户id
 * @param content 评论内容
 * @param repayToCommentId 被回复的评论id
 */
@Transactional
public void repay(String videoId, String userId, String content, String repayToCommentId){
    //查看主评论是否存在，通过for update 对主评论加互斥锁，加互斥锁之后，这条记录执行修改、删除、
    CommentPO repayToCommentPO = select * from t_comment where commentId = #{reapyToCommentId} for update;

    // 剩下的代码。。。和方案1中是一样的
}
```

## 使用并发对代码进行验证

| 时间点 | 请求1：对评论1进行回复                                       | 请求2：删除评论1                                             |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| T1     | 开启事务                                                     |                                                              |
| T2     | 查询主评论1：select * from t_comment where commentId = 1 for update，会对这条评论加互斥锁 | 开启事务                                                     |
| T3     |                                                              | 删除评论1：delete from t_comment where comment_id = 1；<br />由于请求1中对这条记录添加了互斥锁，这里会被阻塞，直到请求1事务结束 |
| T4     | 插入评论，评论插入成功                                       | 阻塞中                                                       |
| T5     | 提交事务                                                     | 阻塞中                                                       |
| T6     |                                                              | 恢复了，删除子评论，此时请求1刚才发表的评论也会被删掉        |
| T7     |                                                              | 提交事务                                                     |

大家好好看看这个过程，此时问题解决了。

## 又带来了新的问题，来看下

![image-20240914205448529](https://learnone.oss-cn-beijing.aliyuncs.com/pic/202409201111858.png)

对同一条评论进行回复，变成串行了，有点追求的我们，肯定是无法接受的。

我们期望，对于同一条评论记录，上面2个方法并发的时候排队执行，但是如果当前只有repay方法发生并发，要支持并行执行，不要排队。

如何解决？见方案3



# 5、方案3：将repay方法中的互斥锁改成共享锁

## MySQL互斥锁和共享锁

这里给大家普及一个知识点，mysql中有2种很重要的锁：互斥锁和共享锁。

- 互斥锁：对记录执行update、delete、或者执行select ... for update的时候，会加互斥锁
- 共享锁：加锁语法：`select * from 表名 where 查询条件 lock in share mode;` 

看下下面这个表格，互斥锁和互斥锁不能共存，互斥锁和共享锁不能共存，共享锁和共享锁可以共存

|        | 互斥锁   | 共享锁   |
| ------ | -------- | -------- |
| 互斥锁 | 不能共存 | 不能共存 |
| 共享锁 | 不能共存 | 可共存   |

大家可以理解是什么意思么？给大家举个例子吧

- 请求1对记录1添加了互斥锁，请求2此时如果想对记录1添加互斥锁、或者共享锁，就需要等待，直到请求1释放锁
- 请求1对记录1添加了共享锁，请求2此时也可以对请求1添加共享锁；但是请求2此时如果想对记录1添加互斥锁，就需要等待，直到请求1释放锁

可能大家还是无法理解，带大家看下效果

## 效果1：验证互斥锁和互斥锁不能共存

准备数据

```sql
drop table if exists t_user;
create table t_user (id int primary key, name varchar(20));
insert into t_user values (1,'路人');
```

| 窗口1                                                        | 窗口2                                                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| start transaction;                                           |                                                              |
| delete from t_user where id = 1; -- 对id=1这条记录添加互斥锁 |                                                              |
|                                                              | start transaction;                                           |
|                                                              | delete from t_user where id = 1; --这里会被阻塞（原因：窗口1中对id=1这条记录添加了互斥锁） |
|                                                              | 阻塞中                                                       |
| rollback; -- 结束事务(commit或者rollback)                    | 唤醒了（原因：窗口1事务结束了，释放了互斥锁）                |
|                                                              | rollback; -- 结束事务(commit或者rollback)                    |
## 效果2：验证互斥锁和共享锁不能共存

| 窗口1                                                        | 窗口2                                                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| start transaction;                                           |                                                              |
| delete from t_user where id = 1; -- 对id=1这条记录添加互斥锁 |                                                              |
|                                                              | start transaction;                                           |
|                                                              | select * from t_user where id = 1 lock in share mode;  --这里会被阻塞（原因：窗口1中对id=1这条记录添加了互斥锁） |
|                                                              | 阻塞中                                                       |
| rollback; -- 结束事务(commit或者rollback)                    | 唤醒了（原因：窗口1事务结束了，释放了互斥锁）                |
|                                                              | rollback; -- 结束事务(commit或者rollback)                    |

## 效果3：验证共享锁和共享锁可以共存

| 窗口1                                                        | 窗口2                                                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| start transaction;                                           | start transaction;                                           |
| select * from t_user where id = 1 lock in share mode; --对id=1这条记录添加了共享锁 |                                                              |
|                                                              | select * from t_user where id = 1 lock in share mode; --对id=1这条记录添加了共享锁，共享锁可以共存，所以这里不会被阻塞 |
| rollback; -- 结束事务(commit或者rollback)                    | rollback; -- 结束事务(commit或者rollback)                    |

理解了这些之后，我们对repay方法进行调整，将互斥锁(for update) 调整成共享锁（lock in share model）就可以了。

## 方案3，代码如下

![image-20240914212320389](https://learnone.oss-cn-beijing.aliyuncs.com/pic/202409201111626.png)



# 6、总结

本文内容稍微有点多，大家多看两遍，好好消化下。



# 获取，源码 & 文档 & 技术支持

需要的小伙伴可以加我微信：itsoku，获取。



# 高并发 & 微服务 & 性能调优实战案例100讲

## 已更新 98 节课

<span style="font-weight:bold; color:red">目前整个课程59块钱，含所有源码 & 文档 & 技术支持，一杯咖啡的价格，还没下手的朋友，赶紧了</span>。

```java
1. 分片上传实战
2. 通用并发处理工具类实战
3. 实现一个好用接口性能压测工具类
4. 超卖问题的4种解决方案，也是防止并发修改数据出错的通用方案
5. Semaphore实现接口限流实战
6. 并行查询，优化接口响应速度实战
7. 接口性能优化之大事务优化
8. 通用的Excel动态导出功能实战
9. 手写线程池管理器，管理&监控所有线程池
10. 动态线程池
11. SpringBoot实现动态Job实战
12. 并行查询，性能优化利器，可能有坑
13. 幂等的4种解决方案，吃透幂等性问题
14. 接口通用返回值设计与实现
15. 接口太多，各种dto、vo不计其数，如何命名？
16. 一个业务太复杂了，方法太多，如何传参？
17. 接口报错，如何快速定位日志？
18. 线程数据共享必学的3个工具类：ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal
19. 通过AOP统一打印请求链路日志，排错效率飞升
20. 大批量任务处理常见的方案（模拟余额宝发放收益）
21. 并发环境下，如何验证代码是否正常？
22. MySql和Redis数据一致性
23. SpringBoot数据脱敏优雅设计与实现
24. 一行代码搞定系统操作日志
25. Aop简化MyBatis分页功能
26. ThreadLocal 遇到线程池有大坑 & 通用解决方案
27. SpringBoot读写分离实战（一个注解搞定读写分离 && 强制路由主库）
28. MQ专题-MQ典型的使用场景
29. MQ专题-如何确保消息的可靠性
30. MQ专题-SpringBoot中，手把手教你实现事务消息
31. 手写一个好用的延迟任务处理工具类
32. MQ专题-MQ延迟消息通用方案实战
33. MQ消息幂等消费 & 消费失败衰减式重试通用方案 & 代码 & 文档
34. MQ专题：顺序消息通用方案实战 & 代码落地 & 文档
35. MQ专题：消息积压相关问题及解决思路
36. 分布式事务-MQ最终一致性-实现跨库转账（案例+源码+文档）
37. 分布式事务-MQ最终一致性-实现电商账户余额提现到微信钱包（案例+源码+文档）
38. 分布式事务：通用的TCC分布式事务生产级代码落地实战
39. 分布式锁详解
40. 分享一个特别好用的Redissson分布式锁工具类
41. 一个注解轻松搞定分布式锁
42. 微服务中如何传递公共参数？
43. 接口幂等，通用方案 & 代码落地
44. 微服务链路日志追踪实战
45. 接口测试利器HTTP Client，不用Postman也可以
46. 封装MyBatis，实现通用无SQL版CRUD功能ORM框架
47. MyBatisPlus 轻松实现多租户数据隔离
48. 电商系统-资金账户表设计 及 应用实战
49. UML画图神器：PlantUML，画图效率飞升
50. 多线程事务，3秒插入百万数据
51. SpringBoot中自动初始化数据库功能，非常好用
52. SpringBoot优雅停机
53. 分享一个特好用的集合工具类，开发效率轻松翻倍
54. 性能调优：线程死锁相关问题
55. 如何排查OOM？
56. cpu飙升，如何快速排查？
57. cpu飙升，使用Arthas，3秒定位问题
58. 接口响应慢，使用Arthas，3秒定位问题代码
59. 策略模式，轻松消除ifelse代码
60. 生产上，代码未生效，如何排查？
61. 使用MySQL，实现一个高性能，分布式id生成器
62. 方法执行异常，使用arthas，快速定位问题
63. 扫码登录详解
64. 使用hutool生成&解析二维码，太方便了
65. SpringBoot中，redis中实现排行榜
66. SpringBoot中，Redis如何实现查找附近的人功能？
67. SpringBoot中，接口签名，通用方案，一次性搞懂
68. SpringBoot中，接口加解密，通用方案实战
69. 分库、分表、分库分表，如何选择？
70. 分库分表：分表字段如何选择？
71. 分库分表：分表数量为什么建议是2的n次方？
72. 分库分表：如何平滑迁移数据？
73. 并发编程有多难？值得反复研究的一个案例
74. 使用Redis Pipeline，接口性能提升10倍
75. 电商中，重复支付如何解决？
76. 千万级数据，全表update的正确姿势
77. 优雅实现树形菜单，适用于所有树，太好用了
78. 接口调用利器：RestTemplate，吃透它
79. 微服务跨库查询，如何解决？一次性搞懂
80. 逻辑删除与唯一约束冲突，如何解决？
81. 评论系统如何设计，一次性给你讲清楚
82. SpringBoot下载文件的几种方式，一次性搞懂
83. 订单超时自动取消，最常见的方案
84. 责任链模式优化代码，太好用了
85. CompletableFuture 实现异步任务编排，太好用了
86. idea中的必备debug技巧，高手必备
87. Java动态生成word，太强大了
88. 海量据量统计，如何提升性能？
89. MyBatis模糊查询，千万不要再用${}了，容易搞出大事故
90. Spring事务失效，常见的几种场景，带你精通Spring事务
91. idea多线程调试，这个技巧也太棒了吧，你会么？
92. MySQL排序分页，可能有坑，需要注意
93. 涉及到钱的，千万不要用double，请用BigDecimal
94. MyBatis动态SQL不要乱用
95. MySQL数据如何同步到ES？靠谱方案
96. 订单状态流转代码优化，确实优雅
97. 线上问题排查思路
98. 经典并发案例分析，确实有点难，一起来挑战下
```




## 课程部分大纲，连载中。。。。

以下课程均来源于个人多年的实战，均提供原理讲解 && 源码落地

1. 分片上传实战
2. 通用并发处理工具类实战
3. 实现一个好用接口性能压测工具类
4. 超卖问题的4种解决方案，也是防止并发修改数据出错的通用方案
5. Semaphore实现接口限流实战
6. 并行查询，优化接口响应速度实战
7. 接口性能优化之大事务优化
8. 通用的Excel动态导出功能实战
9. 手写线程池管理器，管理&监控所有线程池
10. 动态线程池
11. SpringBoot实现动态Job实战
12. 并行查询，性能优化利器，可能有坑
13. 幂等的4种解决方案，吃透幂等性问题
14. 接口通用返回值设计与实现
15. 接口太多，各种dto、vo不计其数，如何命名？
16. 一个业务太复杂了，方法太多，如何传参？
17. 接口报错，如何快速定位日志？
18. 线程数据共享必学的3个工具类：ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal
19. 通过AOP统一打印请求链路日志，排错效率飞升
20. 大批量任务处理常见的方案（模拟余额宝发放收益）
21. 并发环境下，如何验证代码是否正常？
22. MySql和Redis数据一致性
23. SpringBoot数据脱敏优雅设计与实现
24. 一行代码搞定系统操作日志
25. Aop简化MyBatis分页功能
26. ThreadLocal 遇到线程池有大坑 & 通用解决方案
27. SpringBoot读写分离实战（一个注解搞定读写分离 && 强制路由主库）
28. MQ专题：MQ典型的7种使用场景
29. MQ专题：如何确保消息的可靠性
30. MQ专题：SpringBoot中，手把手教你实现事务消息
31. 手写一个好用的延迟任务处理工具类
32. MQ专题：延迟消息通用方案实战
33. MQ专题：消息幂等消费 & 消费失败自动重试通用方案 & 代码落地
34. MQ专题：顺序消息通用方案实战
35. MQ专题：消息积压问题
36. 分布式事务-MQ最终一致性-实现跨库转账（案例+源码+文档）
37. 分布式事务-MQ最终一致性-实现电商账户余额提现到微信钱包（案例+源码+文档）
38. 分布式事务：通用的TCC分布式事务生产级代码落地实战
39. 分布式锁详解
40. 分享一个特别好用的Redissson分布式锁工具类
41. 分布式锁：一个注解轻松实现布式锁
42. 微服务中如何传递上下文？实战
43. 接口幂等，通用方案 & 代码落地
44. 微服务链路日志追踪实战
45. 接口测试利器HTTP Client，不用Postman也可以
46. 封装MyBatis，实现通用无SQL版CRUD功能
47. MyBatisPlus 轻松实现 多租户数据隔离
48. 电商系统-资金账户表设计 及 应用实战
49. 开发者必须掌握的一款UML画图工具，画图效率飞升
50. 多线程事务，3秒插入百万数据
51. SpringBoot自动初始化数据库功能，太好用了
52. SpringBoot优雅停机
53. 分享一个特别好用的集合工具类，开发效率大幅提升
54. 性能调优：如何排查死锁？
55. 如何排查OOM？
56. cpu飙升，如何快速排查？
57. cpu飙升，使用Arthas，3秒定位问题
58. 接口响应慢，使用Arthas，3秒定位问题代码
59. 策略模式，轻松消除ifelse代码
60. 生产上，代码未生效，如何排查？
61. 使用MySQL，实现一个高性能，分布式id生成器
62. 方法执行异常，使用arthas，快速定位问题
63. 扫码登录详解
64. 使用hutool生成&解析二维码，太方便了
65. SpringBoot中，Redis如何实现排行榜功能？
66. SpringBoot中，Redis如何实现查找附近的人功能？
67. SpringBoot中，接口签名，通用方案，一次性搞懂
68. SpringBoot中，接口加解密，通用方案实战
69. 分库、分表、分库分表，如何选择？
70. 分库分表：分表字段如何选择？
71. 分库分表：分表数量为什么建议是2的n次方？
72. 分库分表：如何平滑迁移数据？
73. 并发编程有多难？值得反复研究的一个案例
74. 使用Redis Pipeline，接口性能提升10倍
75. 电商系统中，如何解决重复支付？
76. 千万级数据，全表update的正确姿势
77. 优雅实现树形菜单，适用于所有树，太好用了
78. 接口调用利器：RestTemplate，太好用了，吃透它
79. 微服务跨库查询，如何解决？
80. 逻辑删除与唯一约束冲突，如何解决？
81. 评论系统如何设计，一次性给你讲清楚
82. SpringBoot下载文件的几种方式，一次性搞懂
83. 订单超时自动取消，最常见的方案
84. 责任链模式优化代码，太好用了
85. CompletableFuture 实现异步任务编排，太好用了
86. idea中的必备debug技巧，高手必备
87. Java动态生成word，太强大了
88. 海量据量统计，如何提升性能？
89. MyBatis模糊查询，千万不要再用${}了，容易搞出大事故
90. Spring事务失效，常见的几种场景，带你精通Spring事务
91. idea多线程调试，这个技巧也太棒了吧，你会么？
92. MySQL排序分页，可能有坑，需要注意
93. 涉及到钱的，千万不要用double，请用BigDecimal
94. MyBatis动态SQL不要乱用
95. MySQL数据如何同步到ES？靠谱方案
96. 订单状态流转代码优化，确实优雅
97. 线上问题排查思路
98. 经典并发案例分析，确实有点难，一起来挑战下
99. 更多实战案例详解