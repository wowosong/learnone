**高并发、微服务 、性能调优实战案例100讲，所有案例均源于个人工作实战，均配合代码落地**

加我微信：itsoku，所有案例均提供在线答疑。



# 第75节 电商中，重复支付如何解决？

本篇是一个场景题，工作中也可能会遇到，先收藏点赞，慢慢看。

<span style="font-weight:bold; color:red">目前整个课程59块钱，100个案例，含所有源码 & 文档 & 技术支持，可点击左下角小黄车了解</span>



# 1、什么是重复支付

同一笔订单，用户付了两次款，且两次都成功了



# 2、重复支付演示

美团外面APP，可以重现这个问题，流程如下：

1. 准备2部手机，手机1、手机2
2. 2部手机登录同一个美团账号
3. 手机1：随便找一个店铺，下一笔订单，将订单提交，先别支付，此时订单待支付
4. 手机1：对这笔订单，发起微信支付，此时会跳转到微信，先别支付
5. 手机2：也能看到这笔订单，对这笔订单发起支付宝支付，此时会跳转到支付宝，然后输入支付密码，支付成功
6. 回到手机1：输入微信支付密码，支付成功

此时就出现了同一笔订单，成功支付了2次，一次微信支付、一次支付宝支付；不过稍后会收到美团的一笔退款



# 3、出现重复支付，怎么处理？

支付，涉及到和第三方支付进行交互，里面涉及到网络问题，数据一致性的问题，单靠商户端很难避免重复支付，大部分app是允许重复支付发生的。

那我们只需要考虑，若出现了重复支付的问题，怎么解决就可以了。

比如去包子店买包子，用手机支付了2次，那么只需要和老板核对下，老板确认后，会将第二笔支付金额退还给我们。

同样，电商系统也可以借鉴这个思路，当订单出现重复支付的时，只保留第一笔成功的支付记录，其他支付成功的记录原路退回给用户就可以了。



# 4、代码应该如何落地？

## 4.1、需要2张表

一张订单表，一张订单支付记录表，他们是一对多的关系，一个订单可能有多条支付记录，下面来看下这2张表，这里只列出关键的一些字段。

## 4.2、订单表（t_order）

- id：订单
- price：订单金额
- status：0：待支付；100：已支付

用户下单的时候，会向这张表写入一条数据，状态为`待支付`

## 4.3、订单支付记录表（t_order_pay)

- id：支付记录
- order_id：订单id，指向（t_order表中的id）
- price：支付金额
- status：状态，0：支付中，100：支付成功，200：退款中，300：退款成功

当用户对某一笔订单进行支付的时候，会向该表插入一条记录，状态为`支付中`

## 4.4、支付流程

先带大家熟悉下支付流程，熟悉后，解决重复支付就很容易了。

![](https://learnone.oss-cn-beijing.aliyuncs.com/pic/202409201042743.png)

## 4.5、处理支付回调：含重复支付处理

下面是支付回调的伪代码，里面包含了重复支付的处理，对于重复支付，只保留第一笔成功的支付记录，其他的成功支付记录将原路退款

```java
/**
 * outOrderNo：电商这边订单支付记录id
 * paySuccess：支付结果，true：支付成功，false：支付失败
 **/
public boolean payCallBack(String outOrderNo, boolean paySuccess) {

    //1、先根据outOrderNo找到支付记录
    OrderPay orderPay = select * from t_order_pay where id = #{outOrderNo} ;

    //2、若支付订单不是待支付，说明已处理过了
    if (orderPay != 待支付) {
        return true;
    }

    //3、为了避免并发问题，这里对同一笔订单加分布式锁，确保同一笔订单，并发收到多个通知时，排队执行
    String orderId = orderPay.orderId;
    distributeLock.lock("order-" + orderId);

    try {
        //4、支付失败
        if (!paySuccess) {
            //将支付订单改成支付失败状态
            update t_order_pay set status = 支付失败 where id = #{outOrderNo} ;
            return true;
        }

        /**
         *支付成功的逻辑，如下
         **/
        //5、根据订单id，查询成功的支付记录
        OrderPay successOrderPay = select * from t_order_pay where id = #{orderId} and status = 支付成功 limit 1;

        //6、不存在成功的记录，说明还未成功支付过
        if (successOrderPay == null) {
            //6.1、则将outOrderNo这笔支付记录置为支付成功
            update t_order_pay set status = 支付成功 where id = #{outOrderNo} ;
            
            //6.2、将关联的订单状态支付支付成功
            update t_order set status = 支付成功 where id = #{orderId} ;
            return true;
        }

        //7、若存在已支付成功的记录，且id和outOrderNo不一样，说明重复支付了，则要对outOrderNo这边支付记录发起退款
        if (!successOrderPay.id.equals(outOrderNo)) {
            
            //7.1、对outOrderNo这笔支付记录发起退款，状态置为：退款中
            update t_order_pay set status = 退款中 where id = #{outOrderNo} ;
            
            //7.2、调用微信支付发起退款，这里需要注意，退款结果可能是异步的
            发起微信退款，原路退款;
            
            //7.3、将outOrderNo这笔支付记录，状态置为：退款成功
            update t_order_pay set status = 退款成功 where id = #{outOrderNo} ;
            return ture;
        }
    } finally {
        //8、释放分布式锁
        distributeLock.unlock();
    }

    //返回成功
    return ture;
}
```



# 5、总结

重复支付，极端情况下，难以避免，推荐的做法是：出现这种问题后，将资金原路返回到用户的支付账户，就可以了

不管是依靠人工处理还是程序自动处理，都可以。



# 获取，源码 & 文档 & 技术支持

需要的小伙伴可以加我微信：itsoku，获取。



# 高并发 & 微服务 & 性能调优实战案例100讲

## 已更新 75 节课

<span style="font-weight:bold; color:red">目前整个课程59块钱，含所有源码 & 文档 & 技术支持，一杯咖啡的价格，还没下手的朋友，赶紧了，马上要涨价了</span>。

```java
1. 分片上传实战
2. 通用并发处理工具类实战
3. 实现一个好用接口性能压测工具类
4. 超卖问题的4种解决方案，也是防止并发修改数据出错的通用方案
5. Semaphore实现接口限流实战
6. 并行查询，优化接口响应速度实战
7. 接口性能优化之大事务优化
8. 通用的Excel动态导出功能实战
9. 手写线程池管理器，管理&监控所有线程池
10. 动态线程池
11. SpringBoot实现动态Job实战
12. 并行查询，性能优化利器，可能有坑
13. 幂等的4种解决方案，吃透幂等性问题
14. 接口通用返回值设计与实现
15. 接口太多，各种dto、vo不计其数，如何命名？
16. 一个业务太复杂了，方法太多，如何传参？
17. 接口报错，如何快速定位日志？
18. 线程数据共享必学的3个工具类：ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal
19. 通过AOP统一打印请求链路日志，排错效率飞升
20. 大批量任务处理常见的方案（模拟余额宝发放收益）
21. 并发环境下，如何验证代码是否正常？
22. MySql和Redis数据一致性
23. SpringBoot数据脱敏优雅设计与实现
24. 一行代码搞定系统操作日志
25. Aop简化MyBatis分页功能
26. ThreadLocal 遇到线程池有大坑 & 通用解决方案
27. SpringBoot读写分离实战（一个注解搞定读写分离 && 强制路由主库）
28. MQ专题-MQ典型的使用场景
29. MQ专题-如何确保消息的可靠性
30. MQ专题-SpringBoot中，手把手教你实现事务消息
31. 手写一个好用的延迟任务处理工具类
32. MQ专题-MQ延迟消息通用方案实战
33. MQ消息幂等消费 & 消费失败衰减式重试通用方案 & 代码 & 文档
34. MQ专题：顺序消息通用方案实战 & 代码落地 & 文档
35. MQ专题：消息积压相关问题及解决思路
36. 分布式事务-MQ最终一致性-实现跨库转账（案例+源码+文档）
37. 分布式事务-MQ最终一致性-实现电商账户余额提现到微信钱包（案例+源码+文档）
38. 分布式事务：通用的TCC分布式事务生产级代码落地实战
39. 分布式锁详解
40. 分享一个特别好用的Redissson分布式锁工具类
41. 一个注解轻松搞定分布式锁
42. 微服务中如何传递公共参数？
43. 接口幂等，通用方案 & 代码落地
44. 微服务链路日志追踪实战
45. 接口测试利器HTTP Client，不用Postman也可以
46. 封装MyBatis，实现通用无SQL版CRUD功能ORM框架
47. MyBatisPlus 轻松实现多租户数据隔离
48. 电商系统-资金账户表设计 及 应用实战
49. UML画图神器：PlantUML，画图效率飞升
50. 多线程事务，3秒插入百万数据
51. SpringBoot中自动初始化数据库功能，非常好用
52. SpringBoot优雅停机
53. 分享一个特好用的集合工具类，开发效率轻松翻倍
54. 性能调优：线程死锁相关问题
55. 如何排查OOM？
56. cpu飙升，如何快速排查？
57. cpu飙升，使用Arthas，3秒定位问题
58. 接口响应慢，使用Arthas，3秒定位问题代码
59. 策略模式，轻松消除ifelse代码
60. 生产上，代码未生效，如何排查？
61. 使用MySQL，实现一个高性能，分布式id生成器
62. 方法执行异常，使用arthas，快速定位问题
63. 扫码登录详解
64. 使用hutool生成&解析二维码，太方便了
65. SpringBoot中，redis中实现排行榜
66. SpringBoot中，Redis如何实现查找附近的人功能？
67. SpringBoot中，接口签名，通用方案，一次性搞懂
68. SpringBoot中，接口加解密，通用方案实战
69. 分库、分表、分库分表，如何选择？
70. 分库分表：分表字段如何选择？
71. 分库分表：分表数量为什么建议是2的n次方？
72. 分库分表：如何平滑迁移数据？
73. 并发编程有多难？值得反复研究的一个案例
74. 使用Redis Pipeline，接口性能提升10倍
75. 电商中，重复支付如何解决？
```



## 课程部分大纲，连载中。。。。

以下课程均来源于个人多年的实战，均提供原理讲解 && 源码落地

1. 分片上传实战
2. 通用并发处理工具类实战
3. 实现一个好用接口性能压测工具类
4. 超卖问题的4种解决方案，也是防止并发修改数据出错的通用方案
5. Semaphore实现接口限流实战
6. 并行查询，优化接口响应速度实战
7. 接口性能优化之大事务优化
8. 通用的Excel动态导出功能实战
9. 手写线程池管理器，管理&监控所有线程池
10. 动态线程池
11. SpringBoot实现动态Job实战
12. 并行查询，性能优化利器，可能有坑
13. 幂等的4种解决方案，吃透幂等性问题
14. 接口通用返回值设计与实现
15. 接口太多，各种dto、vo不计其数，如何命名？
16. 一个业务太复杂了，方法太多，如何传参？
17. 接口报错，如何快速定位日志？
18. 线程数据共享必学的3个工具类：ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal
19. 通过AOP统一打印请求链路日志，排错效率飞升
20. 大批量任务处理常见的方案（模拟余额宝发放收益）
21. 并发环境下，如何验证代码是否正常？
22. MySql和Redis数据一致性
23. SpringBoot数据脱敏优雅设计与实现
24. 一行代码搞定系统操作日志
25. Aop简化MyBatis分页功能
26. ThreadLocal 遇到线程池有大坑 & 通用解决方案
27. SpringBoot读写分离实战（一个注解搞定读写分离 && 强制路由主库）
28. MQ专题：MQ典型的7种使用场景
29. MQ专题：如何确保消息的可靠性
30. MQ专题：SpringBoot中，手把手教你实现事务消息
31. 手写一个好用的延迟任务处理工具类
32. MQ专题：延迟消息通用方案实战
33. MQ专题：消息幂等消费 & 消费失败自动重试通用方案 & 代码落地
34. MQ专题：顺序消息通用方案实战
35. MQ专题：消息积压问题
36. 分布式事务-MQ最终一致性-实现跨库转账（案例+源码+文档）
37. 分布式事务-MQ最终一致性-实现电商账户余额提现到微信钱包（案例+源码+文档）
38. 分布式事务：通用的TCC分布式事务生产级代码落地实战
39. 分布式锁详解
40. 分享一个特别好用的Redissson分布式锁工具类
41. 分布式锁：一个注解轻松实现布式锁
42. 微服务中如何传递上下文？实战
43. 接口幂等，通用方案 & 代码落地
44. 微服务链路日志追踪实战
45. 接口测试利器HTTP Client，不用Postman也可以
46. 封装MyBatis，实现通用无SQL版CRUD功能
47. MyBatisPlus 轻松实现 多租户数据隔离
48. 电商系统-资金账户表设计 及 应用实战
49. 开发者必须掌握的一款UML画图工具，画图效率飞升
50. 多线程事务，3秒插入百万数据
51. SpringBoot自动初始化数据库功能，太好用了
52. SpringBoot优雅停机
53. 分享一个特别好用的集合工具类，开发效率大幅提升
54. 性能调优：如何排查死锁？
55. 如何排查OOM？
56. cpu飙升，如何快速排查？
57. cpu飙升，使用Arthas，3秒定位问题
58. 接口响应慢，使用Arthas，3秒定位问题代码
59. 策略模式，轻松消除ifelse代码
60. 生产上，代码未生效，如何排查？
61. 使用MySQL，实现一个高性能，分布式id生成器
62. 方法执行异常，使用arthas，快速定位问题
63. 扫码登录详解
64. 使用hutool生成&解析二维码，太方便了
65. SpringBoot中，Redis如何实现排行榜功能？
66. SpringBoot中，Redis如何实现查找附近的人功能？
67. SpringBoot中，接口签名，通用方案，一次性搞懂
68. SpringBoot中，接口加解密，通用方案实战
69. 分库、分表、分库分表，如何选择？
70. 分库分表：分表字段如何选择？
71. 分库分表：分表数量为什么建议是2的n次方？
72. 分库分表：如何平滑迁移数据？
73. 并发编程有多难？值得反复研究的一个案例
74. 使用Redis Pipeline，接口性能提升10倍
75. 电商系统中，如何解决重复支付？
76. 接口调用利器RestTemplate
77. 更多实战案例详解