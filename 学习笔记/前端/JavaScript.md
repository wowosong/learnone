# JavaScript介绍

我们已经知道了一个完整的JavaScript实现包含了三个部分：ECMAScript、DOM和BOM。 

• 由此我们也知道了我们所要学习的内容就是这三部分。

**– ECMAScript**

**– DOM**

**– BOM**

**特点**

• JS的特点

– 解释型语言

– 类似于 C 和 Java 的语法结构

– 动态语言

– 基于原型的面向对象

**类似于 C 和 Java 的语法结构**

• JavaScript的语法结构与C和Java很像，向for、if、while等语句和Java的基本上是一模一样的。

• 所以有过C和Java基础的同学学习起来会轻松很多。

• 不过JavaScript和与Java的关系也仅仅是看起来像而已。

**基于原型的面向对象**

• JavaScript是一门面向对象的语言。啥是对象？下次聊。

• Java也是一门面向对象的语言，但是与Java不同JavaScript是基于原型的面向对象。啥是原型？下次聊

# JavaScript基本语法

## JS编写位置

### 写到script标签中

```javascript
		//可以将js代码编写到script标签	
		<script type="text/javascript">
			alert("我是script标签中的代码！！");
		</script>
```
### 写到外部js文件

```javascript
<!--
可以将js代码编写到外部js文件中，然后通过script标签引入
写到外部文件中可以在不同的页面中同时引用，也可以利用到浏览器的缓存机制
推荐使用的方式
 -->
<!--
script标签一旦用于引入外部文件了，就不能在编写代码了，即使编写了浏览器也会忽略
如果需要则可以在创建一个新的script标签用于编写内部代码
-->
<script type="text/javascript" src="js/script.js"></script>
<script type="text/javascript">
  alert("我是内部的JS代码");
</script>
```
### 写在标签的onClick属性

```javascript
<!--
  可以将js代码编写到标签的onclick属性中
  当我们点击按钮时，js代码才会执行

  虽然可以写在标签的属性中，但是他们属于结构与行为耦合，不方便维护，不推荐使用
-->
  <button onclick="alert('讨厌，你点我干嘛~~');">点我一下</button>
```
### 写在超链接的href属性

```javascript
		<!--
			可以将js代码写在超链接的href属性中，这样当点击超链接时，会执行js代码
		-->
		<a href="javascript:alert('让你点你就点！！');">你也点我一下</a>
		<a href="javascript:console.log('test');">你也点我一下</a>
		
```

**严格区分大小写**

• JavaScript是严格区分大小写的，也就是abc和Abc会被解析器认为是两个不同的东西。

• 所以在编写上边的HelloWorld时，一定要注意区分大小写。

**注释**

• 注释中的内容不会被解析器解析执行，但是会在源码中显示，我们一般会使用注释对程序中的内容进行解释。

• JS中的注释和Java的的一致，分为两种：

– 单行注释：//注释内容

– 多行注释：/*注释内容*/

```
/*
* 1.JS中严格区分大小写
* 2.JS中每一条语句以分号(;)结尾
* 		- 如果不写分号，浏览器会自动添加，但是会消耗一些系统资源，
* 			而且有些时候，浏览器会加错分号，所以在开发中分号必须写
* 3.JS中会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化
*
*/
```

**标识符**

* 所谓标识符，就是指变量、函数、属性的名字，或函数的参数。 

* 标识符可以是按照下列格式规则组合起来的一或多个字符： 
*  第一个字符必须是一个字母、下划线（ _ ）或一个美元符号（ $ ）。 
* 其他字符可以是字母、下划线、美元符号或数字。 

* 按照惯例，ECMAScript 标识符采用驼峰命名法。 

* 但是要注意的是JavaScript中的标识符不能是关键字和保留字符。

## **关键字和保留字符**

• 关键字

| break | do | instanceof | typeof | case |
| ---- | ---- | ---- |       |      |
| else     | new     | var        | catch  | finally |
| return   | void    | continue   | for    | switch  |
| while    | default | if         | throw  | delete  |
| in       | try     | function   | this   | with    |
| debugger | false   | true       | null   |         |

• 保留字符

| class | enum | extends | super | const |
| ---- | ---- | ---- |     |      |
| import    | implements | let       | private | public |
| interface | package    | protected | static  |        |

**其他不建议使用的标识符**

| abstract   | double      | goto        |
| ---------- | ----------- | ----------- |
| enum       | implements  | package     |
| import     | private     | synchronize |
| protected  | throws      | class       |
| transient  | const       | float       |
| arguments  | encodeURI   | Infinity    |
| isFinite   | Object      | String      |
| parseFloat | SyntaxError | Date        |
| TypeError  | decodeURI   | EvalError   |
| Function   | NaN         | isNaN       |

## **变量**

• 变量的作用是给某一个值或对象标注名称。

• 比如我们的程序中有一个值123，这个值我们是需要反复使用的，这个时候我们最好将123这个值赋值给一个变量，然后通过变量去使用123这个值。

• 变量的声明：

1.  使用var关键字声明一个变量。
2.  var a;

• 变量的赋值：

1.  使用=为变量赋值。
2. a=123;

• 声明和赋值同时进行：

1. var a = 123;

## **数据类型**

• 数据类型决定了一个数据的特征，比如：123和”123”，直观上看这两个数据都是123，但实际上前者是一个数字，而后者是一个字符串。

• 对于不同的数据类型我们在进行操作时会有很大的不同。

• JavaScript中一共有5种基本数据类型：

**– 字符串型（String）** 

**– 数值型（Number）** 

**– 布尔型（Boolean）** 

**– null型（Null）** 

**– undefined型（Undefined）** 

• 这5种之外的类型都称为Object，所以总的来看JavaScript中共有**六种数据类型**

### **typeof运算符** 

• 使用typeof操作符可以用来检查一个变量的数据类型。

• 使用方式：typeof 数据，例如 typeof 123。 

• 返回结果：

– typeof 数值 number

– typeof 字符串 string

– typeof 布尔型 boolean

– typeof undefined undefined

– typeof null object

### String

• String用于表示一个字符序列，即字符串。

• 字符串需要使用 ’或“ 括起来。

• 转义字符：

| 转义字符 | 含义 | 转义字符 | 含义 |
| -------- | ---- | -------- | ---- |
| \n | 换行  | \\\ |  斜杠 |
| \t |  制表|  \’ | 单引号|
| \b | 空格|  \” | 双引号|
|\r| 回车 |          | |

• 将其他数值转换为字符串有三种方式：toString()、String()、拼串

```javascript
/*
* 将其他的数据类型转换为String
* 	方式一：
* 		- 调用被转换数据类型的toString()方法
* 		- 该方法不会影响到原变量，它会将转换的结果返回
* 		- 但是注意：null和undefined这两个值没有toString()方法，
* 			如果调用他们的方法，会报错
* 
*  方式二：
* 		- 调用String()函数，并将被转换的数据作为参数传递给函数
* 		- 使用String()函数做强制类型转换时，
* 			对于Number和Boolean实际上就是调用的toString()方法
* 			但是对于null和undefined，就不会调用toString()方法
* 				它会将 null 直接转换为 "null"
* 				将 undefined 直接转换为 "undefined"
*  String字符串
* 	- 在JS中字符串需要使用引号引起来
* 	- 使用双引号或单引号都可以，但是不要混着用
* 	- 引号不能嵌套，双引号不能放双引号，单引号不能放单引号
*/
```

### Number

• Number 类型用来表示整数和浮点数，最常用的功能就是用来表示10进制的整数和浮点数。

• Number表示的数字大小是有限的，范围是：

1. ± 1.7976931348623157e+308
2. **如果超过了这个范围，则会返回± Infinity。** 

• NaN，即非数值（Not a Number）是一个特殊的数值，**JS中当对数值进行计算时没有结果返回，则返回NaN**

#### 数值的转换

• 有三个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。 

• **Number()可以用来转换任意类型的数据，而后两者只能用于转换字符串。**

**• parseInt()只会将字符串转换为整数，而parseFloat()可以转换为浮点数**

```javascript
/*
* 在js中，如果需要表示16进制的数字，则需要以0x开头
* 			如果需要表示8进制的数字，则需要以0开头
* 			如果要要表示2进制的数字，则需要以0b开头
* 			但是不是所有的浏览器都支持
*/
```

```javascript
/*
* parseInt()可以将一个字符串中的有效的整数内容去出来，
* 	然后转换为Number
*/
```

```javascript
/*将其他的数据类型转换为Number
* 	 转换方式一：
* 		使用Number()函数
* 			- 字符串 --> 数字
* 				1.如果是纯数字的字符串，则直接将其转换为数字
* 				2.如果字符串中有非数字的内容，则转换为NaN
* 				3.如果字符串是一个空串或者是一个全是空格的字符串，则转换为0
* 			- 布尔 --> 数字
* 				true 转成 1
* 				false 转成 0
* 
* 			- null --> 数字     0
*
* 			- undefined --> 数字 NaN
* 
*    转换方式二：
* 		- 这种方式专门用来对付字符串
* 		- parseInt() 把一个字符串转换为一个整数
* 		- parseFloat() 把一个字符串转换为一个浮点数
/*
*		 parseInt()可以将一个字符串中的有效的整数内容去出来，
* 	 然后转换为Number
*		 可以在parseInt()中传递一个第二个参数，来指定数字的进制
* 	 如果对非String使用parseInt()或parseFloat()
*    它会先将其转换为String然后在操作
*/
```

### Boolean(布尔型) 

• 布尔型也被称为逻辑值类型或者真假值类型。 

• 布尔型只能够取真（true）和假（false）两种数值。除此以外，其他的值都不被支持。 

• 其他的数据类型也可以通过Boolean()函数转换为布尔类型。

```javascript
/*
* 将其他的数据类型转换为Boolean
* 	- 使用Boolean()函数
* 		- 数字 ---> 布尔
* 			- 除了0和NaN，其余的都是true
* 
* 		- 字符串 ---> 布尔
* 			- 除了空串，其余的都是true
* 
* 		- null和undefined都会转换为false
* 
* 		- 对象也会转换为true
* 		
*/
```

• 转换规则：

| 数据类型  | 转换为true     | 转换为false    |
| --------- | -------------- | -------------- |
| Boolean   | true           | false          |
| String    | 任何非空字符串 | “”（空字符串） |
| Number    | 任何非0数字    | 0和NaN         |
| Object    | 任何对象       | null           |
| Undefined | n/a            | undefined      |

### Undefined

• Undefined 类型只有一个值，即特殊的 undefined 。 

• **在使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined**。例如：

– var message;

– message 的值就是 undefined。 

• 需要注意的是typeof对没有初始化和没有声明的变量都会返回undefined

### Null

• Null 类型是第二个只有一个值的数据类型，这个特殊的值是null 。 

• 从语义上看null表示的是一个空的对象。所以使用**typeof检查null会返回一个Object**。 

• **undefined值实际上是由null值衍生出来的，所以如果比较undefined和null是否相等，会返回true；**

## 运算符

• JS中为我们定义了一套对数据进行运算的运算符。

• 这其中包括：算数运算符、位运算符、关系运算符等。

```javascript
/*
* 运算符也叫操作符
* 	通过运算符可以对一个或多个值进行运算,并获取运算结果
* 	比如：typeof就是运算符，可以来获得一个值的类型
* 		它会将该值的类型以字符串的形式返回
* 		number string boolean undefined object
* 
* 	算数运算符
* 		当对非Number类型的值进行运算时，会将这些值转换为Number然后在运算
* 			任何值和NaN做运算都得NaN
*       


/*
			 * 任何值做- * /运算时都会自动转换为Number
			 * 	我们可以利用这一特点做隐式的类型转换
			 * 		可以通过为一个值 -0 *1 /1来将其转换为Number
			 * 		原理和Number()函数一样，使用起来更加简单
			 */
			 
			 
* 		+
* 			+可以对两个值进行加法运算，并将结果返回
* 			 如果对两个字符串进行加法运算，则会做拼串
* 				会将两个字符串拼接为一个字符串，并返回
* 			任何的值和字符串做加法运算，都会先转换为字符串，然后再和字符串做拼串的操作
* 		-
* 			- 可以对两个值进行减法运算，并将结果返回
* 
* 		*
* 			* 可以对两个值进行乘法运算
* 		/
* 			/ 可以对两个值进行除法运算
* 		%
* 			% 取模运算（取余数）
*/
```

### 算数运算符

• 算数运算符顾名思义就是进行算数操作的运算符。

• JS中为我们提供了多种算数运算符。

• 算数运算符：

| 运算符 | 说明 | 运算符 | 说明          |
| ------ | ---- | ------ | ------------- |
| +      | 加法 | ++     | （前置）自增  |
| -      | 减法 | ++     | （后置） 自增 |
| *      | 乘法 | --     | （前置）自减  |
| /      | 除法 | --     | （后置） 自减 |
| %      | 取模 | +      | 符号不变      |
|        |      | -      | 符号反转      |

### 自增和自减

• 自增 ++ 自减 --

–自增和自减分为前置运算和后置元素。

– 所谓的前置元素就是将元素符放到变量的前边，而后置将元素符放到变量的后边。

```javascript
/*
* 自增 ++
* 	 - 通过自增可以使变量在自身的基础上增加1
* 	 - 对于一个变量自增以后，原变量的值会立即自增1
* 	 - 自增分成两种：后++(a++) 和 前++(++a)	
* 		无论是a++ 还是 ++a，都会立即使原变量的值自增1
* 			不同的是a++ 和 ++a的值不同
* 		a++的值等于原变量的值（自增前的值）
* 		++a的值等于新值 （自增后的值）
* 
* 自减 --
* 	- 通过自减可以使变量在自身的基础上减1
* 	- 自减分成两种：后--(a--) 和 前--(--a)
* 		无论是a-- 还是 --a 都会立即使原变量的值自减1
* 			不同的是a-- 和 --a的值不同
* 				a-- 是变量的原值 （自减前的值）
* 				--a 是变量的新值 （自减以后的值）
* 			
* 	
*/
```

– 例子：

 	• 前置自增：++a
 	• 后置自减：a— 

– 运算符在前置时，表达式值等于变量原值。

– 运算符在后置时，表达式值等于变量变更以后的值

## 逻辑操作符

• 一般情况下使用逻辑运算符会返回一个布尔值。

• 逻辑运算符主要有三个：非、与、或。

• 在进行逻辑操作时如果操作数不是布尔类型则会将其转换布尔类型在进行计算。

• 非使用符号 ! 表示，与使用 && 表示，或使用 || 表示。

```javascript
/*
* JS中为我们提供了三种逻辑运算符
* ! 非
* 	- !可以用来对一个值进行非运算
* 	- 所谓非运算就是值对一个布尔值进行取反操作，
* 		true变false，false变true
* 	- 如果对一个值进行两次取反，它不会变化
* 	- 如果对非布尔值进行元素，则会将其转换为布尔值，然后再取反
* 		所以我们可以利用该特点，来将一个其他的数据类型转换为布尔值
* 		可以为一个任意数据类型取两次反，来将其转换为布尔值，
* 		原理和Boolean()函数一样
* 
* && 与
* 	- &&可以对符号两侧的值进行与运算并返回结果
* 	- 运算规则
* 		- 两个值中只要有一个值为false就返回false，
* 			只有两个值都为true时，才会返回true
* 		- JS中的“与”属于短路的与，
* 			如果第一个值为false，则不会看第二个值
* 
* || 或
* 	- ||可以对符号两侧的值进行或运算并返回结果
* 	- 运算规则：
* 		- 两个值中只要有一个true，就返回true
* 			如果两个值都为false，才返回false
*		- JS中的“或”属于短路的或
* 			如果第一个值为true，则不会检查第二个值
* 
* && || 非布尔值的情况
* 	- 对于非布尔值进行与或运算时，
* 		会先将其转换为布尔值，然后再运算，并且返回原值
* 	- 与运算：
* 		- 如果第一个值为true，则必然返回第二个值
* 		- 如果第一个值为false，则直接返回第一个值
* 
* 	- 或运算
* 		- 如果第一个值为true，则直接返回第一个值
* 		- 如果第一个值为false，则返回第二个值
* 
*/
```

|   运算符   |   说明    |  短路规则 |
| ---- | ---- | ---- |
| ! | 逻辑非| （NOT）|
| &&|  逻辑与（AND）|  若左值为假，则不运算右值|
|`|` `|` |   逻辑或（OR） | 若左值为真，则不运算右值|

### 非

• 非运算符使用 ! 表示。

• 非运算符可以应用于任意值，无论值是什么类型，这个运算符都会返回一个布尔值。

• 非运算符会对原值取反，比如原值是true使用非运算符会返回false，原值为false使用非运算符会返回true

### 与

• 与运算符使用 && 表示。

• 与运算符可以应用于任何数据类型，且不一定返回布尔值。

• 对于非布尔值运算，会先将非布尔值转换为布尔值。 

• 对布尔值做运算时，如果两个值都为true则返回true，否则返回false。 

• 非布尔值时：如果两个都为true，则返回第二个值，如果两个值中有false则返回靠前的false的值。

### 或

• 或运算符使用 || 表示。

• 或运算符可以应用于任何数据类型，且不一定返回布尔值。

• 对于非布尔值运算，会先将非布尔值转换为布尔值。 

• 对布尔值进行运算时，如果两个值都为false则返回false，否则返回true。 

• 非布尔值时：如果两个都为false ，则返回第二个值，否则返回靠前true的值

## 赋值运算符

• 简单的赋值操作符由等于号 （ = ） 表示，其作用就是把右侧的值赋给左侧的变量。

• 如果在等于号左边添加加减乘除等运算符，就可以完成复合赋值操作。

• +=、*=、-=、/=、%=

• 比如：a+=10和a=a+10是一样的。

## 关系运算符

• 小于（<） 、大于（>） 、小于等于（<=）和大于等于（>=）这几个关系运算符用于对两个值进行比较，比较的规则与我们在数学课上所学的一样。 

```javascript
/*
* 通过关系运算符可以比较两个值之间的大小关系，
* 	如果关系成立它会返回true，如果关系不成立则返回false
* 
* > 大于号
* 	- 判断符号左侧的值是否大于右侧的值
* 	- 如果关系成立，返回true，如果关系不成立则返回false
* 
* >= 大于等于
* 	- 判断符号左侧的值是否大于或等于右侧的值
* 
* < 小于号
* <= 小于等于
* 
* 非数值的情况
* 	- 对于非数值进行比较时，会将其转换为数字然后在比较
* 	- 如果符号两侧的值都是字符串时，不会将其转换为数字进行比较
* 		而会分别比较字符串中字符的Unicode编码
*   - 如果比较的两个字符串型的数字，可能会得到不可预期的结果
*		- 注意：在比较两个字符串型的数字时，一定一定一定要转型
*/
```

• 这几个运算符都返回一个布尔值。用来表示两个值之间的关系是否成立。

– 5 > 10 false

– 5 < 10 true

– 5 <= 10 true

– 5 >= 10 false

### 相等

• JS中使用==来判断两个值是否相等，如果相等则返回true。 

• 使用!=来表示两个值是否不相等，如果不等则返回true。 

• 注意：**null和undefined使用==判断时是相等的。**

```javascript
/*
* 相等运算符用来比较两个值是否相等，
* 	如果相等会返回true，否则返回false
* 
* 使用 == 来做相等运算
* 	- 当使用==来比较两个值时，如果值的类型不同，
* 		则会自动进行类型转换，将其转换为相同的类型
* 		然后在比较
* 不相等
* 	 不相等用来判断两个值是否不相等，如果不相等返回true，否则返回false
* 	- 使用 != 来做不相等运算
* 	- 不相等也会对变量进行自动的类型转换，如果转换后相等它也会返回false
* 
* 		
*  ===
* 		全等
* 		- 用来判断两个值是否全等，它和相等类似，不同的是它不会做自动的类型转换
* 			如果两个值的类型不同，直接返回false
* 	!==
* 		不全等
* 		- 用来判断两个值是否不全等，和不等类似，不同的是它不会做自动的类型转换
* 			如果两个值的类型不同，直接返回true
*/
/*
* 	可以通过isNaN()函数来判断一个值是否是NaN
* 	如果该值是NaN则返回true，否则返回false
*/
```



|   表达式   |     值 |  表达式 | 值  |
| ---- | ---- | ---- | ---- |
|   null == undefined   |     true  |    true == 1    |  true   |
|  “NaN” == NaN |  false |  true == 2 |  false |
|  5 == NaN |  false |   undefined == 0 |   false |
|  NaN == NaN |  false |  null == 0 |   false |
|  NaN != NaN |  true |  “5” == 5 |   true |
|false == 0| true  |                | |

### **全等**

• 除了==以外，JS中还提供了**===** 。 

• **===表示全等，他和==基本一致，不过==在判断两个值时会进行自动的类型转换，而===不会。**

• 也就是说**”55”==55**会返回true，而**”55”===55**会返回false； 

• 同样我们还有!==表示不全等，同样比较时不会自动转型**。** 

• 也就是说**”55”!=55**会返回false，而**”55”!==55**会返回true；

### 逗号

• 使用逗号可以在一条语句中执行多次操作。

• 比如：var num1=1, num2=2, num3=3; 

• 使用逗号运算符分隔的语句会从左到右顺序依次执行。

## 条件运算符

```javascript
/*
* 条件运算符也叫三元运算符
* 	语法：
* 		条件表达式?语句1:语句2;
* 	- 执行的流程：
* 		条件运算符在执行时，首先对条件表达式进行求值，
* 			如果该值为true，则执行语句1，并返回执行结果
* 			如果该值为false，则执行语句2，并返回执行结果
* 		如果条件的表达式的求值结果是一个非布尔值，
* 			会将其转换为布尔值然后在运算
*/
```

• 条件运算符也称为三元运算符。通常运算符写为?:。 

• 这个运算符需要三个操作数，第一个操作数在?之前，第二个操作数在?和:之间，第三个操作数在:之后。

• 例如：x > 0 ? x : -x // 求x的绝对值

• 上边的例子，首先会执行x>0，如果返回true则执行冒号左边的代码，并将结果返回，这里就是返回x本身，

如果返回false则执行冒号右边的代码，并将结果返回。

### 运算符的优先级

```javascript
•  .、[]、 new
•  ()
•  ++、 --
•  !、~、+(单目)、-(单目)、typeof、void、delete
•  %、*、/ 
•  +(双目)、-(双目) 
•  << 、 >>、 >>>
•  <、<=、>、>=
•  ==、!==、===
•  & 
•  ^ 
•  | 
•  &&
•  ||
•  ?:
•  =、+=、-=、*=、/=、%=、<<=、>>=、>>>=、&=、^=、|=
•  ,
```

```javascript
/*
* , 运算符
* 	使用,可以分割多个语句，一般可以在声明多个变量时使用,
*/
//使用,运算符同时声明多个变量
//var a , b , c;

//可以同时声明多个变量并赋值
//var a=1 , b=2 , c=3;
//alert(b);

/*
* 就和数学中一样，在JS中运算符也有优先级，
* 	比如：先乘除 后加减
* 在JS中有一个运算符优先级的表，
* 	在表中越靠上优先级越高，优先级越高越优先计算，
* 	如果优先级一样，则从左往右计算。
* 但是这个表我们并不需要记忆，如果遇到优先级不清楚
* 	可以使用()来改变优先级
*/

//var result = 1 + 2 * 3;

/*
* 如果||的优先级高，或者两个一样高，则应该返回3
* 如果与的优先级高，则应该返回1
* 		
*/
```



## 语句

• 前边我所说表达式和运算符等内容可以理解成是我们一门语言中的单词，短语。

• 而语句（statement）就是我们这个语言中一句一句完整的话了。

• 语句是一个程序的基本单位，JS的程序就是由一条一条语句构成的，每一条语句使用;结尾。

• JS中的语句默认是由上至下顺序执行的，但是我们也可以通过一些流程控制语句来控制语句的执行顺序。

## 代码块

• 代码块是在大括号 {} 中所写的语句，以此将多条语句的集合视为一条语句来使用。 

• 例如：

```javascript
{
  var a = 123;
  a++;
  alert(a);
}
```

• 我们一般使用代码块将需要一起执行的语句进行分组，需要注意的是，代码块结尾不需要加分号。	JS中的代码块，只具有分组的的作用，没有其他的用途代码块内容的内容，在外部是完全可见的


## 条件语句

• 条件语句是通过判断指定表达式的值来决定执行还是跳过某些语句。

• 最基本的条件语句：

1. **if...else**
2. **switch...case**

### if...else语句

• if...else语句是一种最基本的控制语句，它让JavaScript可以有条件的执行语句。

• 第一种形式: 

```javascript
if(expression)
	statement
```

• 第二种形式: 

```javascript
if(expression) 
	statement
else
	statement
```

• 除了if和else还可以使用 else if 来创建多个条件分支。

### if语句例子

• 例1

```javascript
if(age >= 18){
 alert("您已经成年！");
} 
```

• 例2

```javascript
if(age >= 18){
	alert("您已经成年！");
}else{
	alert("你还未成年！");
}
```

• 例3 

```javascript
if(age < 18){
	alert("你还未成年！");
}else if(age <= 30){
	alert("您已经是个青年了！")
}else{
	alert("你已经是个中年了！");
}
```

### **switch...case语句**

• switch...case是另一种流程控制语句。

• switch语句更适用于多条分支使用同一条语句的情况。

• 语法：

```javascript
switch(语句){
  case 表达式1:
  	语句...
  case 表达式2:
 		语句...
  default:
  	语句...
}
```

• 需要注意的是case语句只是标识的程序运行的起点，并不是终点，所以一旦符合case的条件程序会一直运行到结束。所以我们一般会在case中添加break作为语句的结束。

## 循环语句

• 和条件语句一样，循环语句也是基本的控制语句。

• 循环中的语句只要满足一定的条件将会一直执行。

### while

• while语句是一个最基本的循环语句。

• while语句也被称为while循环。

• 语法：

```javascript
while(条件表达式){
	语句...
}
```

• 和if一样while中的条件表达式将会被转换为布尔类型，只要该值为真，则代码块将会一直重复执行。

• 代码块每执行一次，条件表达式将会重新计算。

### do...while

• do...while和while非常类似，只不过它会在循环的尾部而不是顶部检查表达式的值。

• do...while循环会至少执行一次。

• 语法：

```javascript
do{
	语句...
}while(条件表达式);
```

• 相比于while，do...while的使用情况并不是很多。

### for

• for语句也是循环控制语句，我们也称它为for循环。

• 大部分循环都会有一个计数器用以控制循环执行的次数，计数器的三个关键操作是初始化、检测和更新。for语句

就将这三步操作明确为了语法的一部分。

• 语法：

```javascript
for(初始化表达式 ; 条件表达式 ; 更新表达式){
	语句...
}
```

### break和continue

• break 和 continue 语句用于在循环中精确地控制代码的执行。 

```javascript
/*
* break关键字可以用来退出switch或循环语句
* 	不能在if语句中使用break和continue
* 	break关键字，会立即终止离他最近的那个循环语句
*/
/*
* 可以为循环语句创建一个label，来标识当前的循环
* label:循环语句
* 使用break语句时，可以在break后跟着一个label，
* 	这样break将会结束指定的循环，而不是最近的
*/
/*
* continue关键字可以用来跳过当次循环
* 	同样continue也是默认只会对离他最近的循环循环起作用
*/
```

• 使用break语句会使程序立刻退出最近的循环，强制执行循环后边的语句。

• break和continue语句只在循环和switch语句中使用。

• 使用continue语句会使程序跳过当次循环，继续执行下一次循环，并不会结束整个循环。

• continue只能在循环中使用，不能出现在其他的结构中。

## label

• 使用 label 语句可以在代码中添加标签，以便将来使用。 

• 语法：

– label: statement

• 例子：

```javascript
start:
for (var i=0; i < count; i++) {**
	alert(i);
} 
```

• 这个例子中定义的 start 标签可以在将来由 break 或 continue 语句引用。加标签的语句一般都要与 for 语句等循环语句配合使用。

# Object对象

• Object类型，我们也称为一个对象。是JavaScript中的引用数据类型。

• 它是一种复合值，它将很多值聚合到一起，可以通过名字访问这些值。

• 对象也可以看做是属性的无序集合，每个属性都是一个名/值对。

• 对象除了可以创建自有属性，还可以通过从一个名为原型的对象那里继承属性。

• 除了字符串、数字、true、false、null和undefined之外，JS中的值都是对象。

```javascript
/*
			 * JS中数据类型
			 * 	- String 字符串
			 *  - Number 数值
			 * 	- Boolean 布尔值
			 * 	- Null 空值
			 * 	- Undefined 未定义
			 * 		- 以上这五种类型属于基本数据类型，以后我们看到的值
			 * 			只要不是上边的5种，全都是对象
			 * 	- Object 对象
			 * 
			 * 
			 * 基本数据类型都是单一的值"hello" 123 true,
			 * 	值和值之间没有任何的联系。
			 * 
			 * 在JS中来表示一个人的信息（name gender age）：
			 * 	var name = "孙悟空";
			 * 	var gender = "男";
			 * 	var age = 18;
			 * 如果使用基本数据类型的数据，我们所创建的变量都是独立，不能成为一个整体。
			 * 
			 * 对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。
			 * 
			 * 对象的分类：
			 * 	1.内建对象
			 * 		- 由ES标准中定义的对象，在任何的ES的实现中都可以使用
			 * 		- 比如：Math String Number Boolean Function Object....
			 * 
			 * 	2.宿主对象
			 * 		- 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象
			 * 		- 比如 BOM DOM
			 * 
			 * 	3.自定义对象
			 * 		- 由开发人员自己创建的对象
			 * 
			 */
			
			//创建对象
			/*
			 * 使用new关键字调用的函数，是构造函数constructor
			 * 	构造函数是专门用来创建对象的函数
			 * 使用typeof检查一个对象时，会返回object
			 */
```

## 创建对象

• 创建对象有两种方式：

– 第一种

```javascript
var person = new Object();
person.name = "孙悟空";
person.age = 18;
```

– 第二种

```javascript
var person = {
	name:"孙悟空",
	age:18
};
```

## 对象属性的访问

• 访问属性的两种方式：

–  .访问

• 对象.属性名

–  []访问

• 对象[‘属性名’]

```javascript
/*
* 如果要使用特殊的属性名，不能采用.的方式来操作
* 	需要使用另一种方式：
* 		语法：对象["属性名"] = 属性值
* 	读取时也需要采用这种方式
* 
* 使用[]这种形式去操作属性，更加的灵活，
* 	在[]中可以直接传递一个变量，这样变量值是多少就会读取那个属性
* 
*/

/*
* in 运算符
* 	- 通过该运算符可以检查一个对象中是否含有指定的属性
* 		如果有则返回true，没有则返回false
*  - 语法：
 * 		"属性名" in 对象
*/
//console.log(obj.test2);

//检查obj中是否含有test2属性
//console.log("test2" in obj);
//console.log("test" in obj);
/*
			 * 使用对象字面量，可以在创建对象时，直接指定对象中的属性
			 * 语法：{属性名:属性值,属性名:属性值....}
			 * 	对象字面量的属性名可以加引号也可以不加，建议不加,
			 * 	如果要使用一些特殊的名字，则必须加引号
			 * 
			 * 属性名和属性值是一组一组的名值对结构，
			 * 	名和值之间使用:连接，多个名值对之间使用,隔开
			 * 	如果一个属性之后没有其他的属性了，就不要写,
			 */
```

## 基本数据类型

• JS中的变量可能包含两种不同数据类型的值：基本数据类型和引用数据类型。

• JS中一共有5种基本数据类型：String、Number、Boolean、Undefined、Null。 

• 基本数据类型的值是无法修改的，是不可变的。

• 基本数据类型的比较是值的比较，也就是只要两个变量的值相等，我们就认为这两个变量相等。

## 引用数据类型

```javascript
/*
* 基本数据类型
* 	String Number Boolean Null Undefined
* 
* 引用数据类型
* 	Object
* 
* JS中的变量都是保存到栈内存中的，
* 		基本数据类型的值直接在栈内存中存储，
* 		值与值之间是独立存在，修改一个变量不会影响其他的变量
* 
* 		对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，
* 		而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用，
* 		当一个通过一个变量修改属性时，另一个也会受到影响
*/
```

• 引用类型的值是保存在内存中的对象。 

• 当一个变量是一个对象时，实际上变量中保存的并不是对象本身，而是对象的引用。

• 当从一个变量向另一个变量复制引用类型的值时，会将对象的引用复制到变量中，并不是创建一个新的对象。

• 这时，两个变量指向的是同一个对象。因此，改变其中一个变量会影响另一个。 

```javascript
/*对象的属性值可以是任何的数据类型，也可以是个函数
* 函数也可以称为对象的属性，
* 如果一个函数作为一个对象的属性保存，
* 	那么我们称这个函数时这个对象的方法
* 	调用这个函数就说调用对象的方法（method）
* 但是它只是名称上的区别没有其他的区别 
*/
```

## 栈和堆

**• JavaScript在运行时数据是保存到栈内存和堆内存当中的。**

• 简单来说**栈内存用来保存变量和基本类型。堆内存用来保存对象**。

• 我们在声明一个变量时实际上就是在栈内存中创建了一个空间用来保存变量。

• 如果是基本类型则在栈内存中直接保存，

• 如果是引用类型则会在堆内存中保存，变量中保存的实际上对象在堆内存中的地址。

## 栈和堆

**栈内存**

**var a = 123;**

**var b = true;**

**var c = "hello";**

**var d = {name:'sunwukong',age:18};**

![image-20220331222704706](/Users/jiusonghuang/Desktop/learn-new/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/JavaScript.assets/image-20220331222704706.png)

# 数组

• 数组也是对象的一种。

• 数组是一种用于表达有顺序关系的值的集合的语言结构。 

• 创建数组：

– var array = [1,44,33];

• 数组内的各个值被称作元素。每一个元素都可以通过索引（下标）来快速读取。索引是从零开始的整数。

# 函数

```javascript
/*
* 函数 function
* 	- 函数也是一个对象
* 	- 函数中可以封装一些功能（代码），在需要时可以执行这些功能（代码）
* 	- 函数中可以保存一些代码在需要的时候调用
* 	- 使用typeof检查一个函数对象时，会返回function
*/

//我们在实际开发中很少使用构造函数来创建一个函数对象
//创建一个函数对象
//可以将要封装的代码以字符串的形式传递给构造函数
//var fun = new Function("console.log('Hello 这是我的第一个函数');");

//封装到函数中的代码不会立即执行
//函数中的代码会在函数调用的时候执行
//调用函数 语法：函数对象()
//当调用函数时，函数中封装的代码会按照顺序执行
//fun();

/*
* 使用 函数声明 来创建一个函数
* 	语法：
* 		function 函数名([形参1,形参2...形参N]){
* 			语句...
* 		}
*/

/*
* 使用 函数表达式 来创建一个函数
* var 函数名  = function([形参1,形参2...形参N]){
* 	 语句....
*  }
*/
```

• 函数是由一连串的子程序（语句的集合）所组成的，可以被外部程序调用。向函数传递参数之后，函数可以返回一

定的值。 

• 通常情况下，JavaScript 代码是自上而下执行的，不过函数体内部的代码则不是这样。如果只是对函数进行了声明，其中的代码并不会执行。只有在调用函数时才会执行函数体内部的代码。

**• 这里要注意的是JavaScript中的函数也是一个对象。**

## 函数的声明（一）

• 首先明确一点函数也是一个对象，所以函数也是在堆内存中保存的。

• 函数声明比较特殊，需要使用function关键字声明。

```javascript
var sum = function(a,b)
{
  return a+b
};
```

• 上边的例子就是创建了一个函数对象，并将函数对象赋值给了sum这个变量。其中()中的内容表示执行函数时需要的参数，{}中的内容表示函数的主体。

## 函数的调用

• 调用函数时，传递给函数的参数称为实参（实际参数）。

• 如果想调用我们上边定义的sum函数，可以这样写：

```javascript
var result = sum(123,456);
```

**– 这样表示调用sum这个函数，并将123和456作为实参传递给函数，函数中会将两个参数求和并赋值给result。**

## 函数的声明（二）

• 可以通过函数声明语句来定义一个函数。函数声明语句以关键字function 开始，其后跟有函数名、参数列表和函数体。其语法如下所示：

```javascript
function 函数名 ( 参数 , 参数 , 参数...){

函数体

}
```

• 例如:

```javascript
function sum(a,b){
	return a+b;
}
```

– 上边我们定义了一个函数名为sum，两个参数a和b。函数声明时设置的参数称为形参（形式参数），这个函数对两个参数做了加法运算并将结果返回。

## 传递参数

• JS中的所有的参数传递都是按值传递的。也就是说把函数外部的值赋值给函数内部的参数，就和把值从一个变量赋值给另一个变量是一样的。

```javascript
/*
* 定义一个用来求两个数和的函数
* 	可以在函数的()中来指定一个或多个形参（形式参数）
* 	多个形参之间使用,隔开，声明形参就相当于在函数内部声明了对应的变量
* 	但是并不赋值
*/
function sum(a,b){
  console.log("a = "+a);
  console.log("b = "+b);
  console.log(a+b);
}

/*
* 在调用函数时，可以在()中指定实参（实际参数）
* 	实参将会赋值给函数中对应的形参
*/
/*sum(1,2);
sum(123,456);*/
/*
* 调用函数时解析器不会检查实参的类型,
* 	所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查
* 函数的实参可以是任意的数据类型
*/
//sum(123,"hello");
//sum(true , false);
/*
* 调用函数时，解析器也不会检查实参的数量
* 	多余实参不会被赋值
* 如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined
* 
*/
//sum(123,456,"hello",true,null);
/*
* 创建一个函数，可以在控制台中输出一个人的信息
* 	可以输出人的 name age gender address
* 
* 实参可以是任意的数据类型，也可以是一个对象
* 	当我们的参数过多时，可以将参数封装到一个对象中，然后通过对象传递
*/
/*
* mianji()
* 	- 调用函数
* 	- 相当于使用的函数的返回值 
* mianji
* 	- 函数对象
* 	- 相当于直接使用函数对象
*/
```

## 返回值

```javascript
/*
			 * 创建一个函数，用来计算三个数的和
			 * 
			 * 可以使用 return 来设置函数的返回值
			 * 	语法：
			 * 		return 值
			 * 
			 * 	return后的值将会会作为函数的执行结果返回，
			 * 		可以定义一个变量，来接收该结果
			 * 
			 *  在函数中return后的语句都不会执行
			 * 
			 * 	如果return语句后不跟任何值就相当于返回一个undefined，
			 * 	如果函数中不写return，则也会返回undefined
			 * 
			 * 	return后可以跟任意类型的值
			 * 
			 */
			function sum(a , b , c){
				//alert(a + b +c);
				
				var d = a + b + c;
				
				return d;
				
				//return undefined;
				
			}
			
			//调用函数
			//变量result的值就是函数的执行结果
			//函数返回什么result的值就是什么
			function fun3(){
				//在函数内部再声明一个函数
				function fun4(){
					alert("我是fun4");
				}
				
				//将fun4函数对象作为返回值返回
				return fun4;
			}
```

# 枚举对象中的属性

```javascript
//枚举对象中的属性
//使用for ... in 语句
/*
* 语法：
* 	for(var 变量 in 对象){
* 	
*  }
* 
* for...in语句 对象中有几个属性，循环体就会执行几次
* 	每次执行时，会将对象中的一个属性的名字赋值给变量
*/
for(var n in obj){
  console.log("属性名:"+n);
  console.log("属性值:"+obj[n]);
}
```

# 作用域（Scope)

```javascript
/*
			 * 作用域
			 * 	- 作用域指一个变量的作用的范围
			 * 	- 在JS中一共有两种作用域：
			 * 		1.全局作用域
			 * 			- 直接编写在script标签中的JS代码，都在全局作用域
			 * 			- 全局作用域在页面打开时创建，在页面关闭时销毁
			 * 			- 在全局作用域中有一个全局对象window，
			 * 				它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用
			 * 			- 在全局作用域中：
			 * 				创建的变量都会作为window对象的属性保存
			 * 				创建的函数都会作为window对象的方法保存
			 * 			- 全局作用域中的变量都是全局变量，
			 * 				在页面的任意的部分都可以访问的到
			 * 
			 * 		2.函数作用域
			 * 	- 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁
			 * 	- 每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的
			 * 	- 在函数作用域中可以访问到全局作用域的变量
			 * 		在全局作用域中无法访问到函数作用域的变量
			 * 	- 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用
			 * 		如果没有则向上一级作用域中寻找，直到找到全局作用域，
			 * 		如果全局作用域中依然没有找到，则会报错ReferenceError
			 * 	- 在函数中要访问全局变量可以使用window对象
			 */
			 /*
			 * 在函数作用域也有声明提前的特性，
			 * 	使用var关键字声明的变量，会在函数中所有的代码执行之前被声明
			 * 	函数声明也会在函数中所有的代码执行之前执行
			 * 在函数中，不适用var声明的变量都会成为全局变量
			 */
```



# 变量的声明提前

```javascript
/*
* 变量的声明提前
* 	- 使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值），
* 		但是如果声明变量时不适用var关键字，则变量不会被声明提前
* 
* 函数的声明提前
* 	- 使用函数声明形式创建的函数 function 函数(){}
* 		它会在所有的代码执行之前就被创建，所以我们可以在函数声明前来调用函数
* 	   使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用	
*/
```





## 执行环境

*  执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。 
*  每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。 
* 全局执行环境是最外围的一个执行环境。在 Web 浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为window 对象的属性和方法创建的。 
* 某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。
* 在内部环境可以读取外部环境的变量，反之则不行。
## 函数内部属性
* 在函数内部，有两个特殊的对象： 

– arguments

​	• 该对象实际上是一个数组，用于保存函数的参数。

​	• 同时该对象还有一个属性callee来表示当前函数。

– this 

​	• **this 引用的是一个对象。对于最外层代码与函数内部的情况，其引用目标是不同的。** 

​	**• 此外，即使在函数内部，根据函数调用方式的不同，引用对象也会有所不同。需要注意的是，this 引用会根据代码的上下文语境自动改变其引用对象。**

## this 引用的规则

• 在最外层代码中，this 引用的是全局对象。 

• 在函数内，this 根据函数调用方式的不同而有所不同：

| **函数的调用方式** | **this**引用的对象 |
| ------------------ | ------------------ |
| 构造函数           | 所生成的对象       |
| 调用对象的方法     | 当前对象           |
| apply或call调用    | 参数指定的对象     |
| 其他方式           | 全局对象（window） |

# 构造函数

• 构造函数是用于生成对象的函数，像之前调用的Object()就是一个构造函数。

• 创建一个构造函数：

```javascript
function MyClass(x,y) {

this.x = x;

this.y = y;

}
```

• 调用构造函数：

– 构造函数本身和普通的函数声明形式相同。 

– 构造函数通过 new 关键字来调用，new 关键字会新创建一个对象并返回。

– 通过 new关键字调用的构造函数内的 this 引用引用了（被新生成的）对象。

# new关键字

1. 使用new关键字执行一个构造函数时：

- 首先，会先创建一个空的对象。

- 然后，会执行相应的构造函数。构造函数中的this将会引用这个新对象。

-  最后，将对象作为执行结果返回。

2. 构造函数总是由new关键字调用。

3.  构造函数和普通函数的区别就在于调用方式的不同。

4. 任何函数都可以通过new来调用，所以函数都可以是构造函数。

5. 在开发中，通常会区分用于执行的函数和构造函数。

6. 构造函数的首字母要大写。

# 属性的访问

• 在对象中保存的数据或者说是变量，我们称为是一个对象的属性。

• 读取对象的属性有两种方式：

​	– 对象.属性名

​	– 对象['属性名']

• 修改属性值也很简单：

​	– 对象.属性名 = 属性值

• 删除属性

​	– delete 对象.属性名

• constructor

​	– 每个对象中都有一个constructor属性，它引用了当前对象的构造函数。

# 垃圾回收

• 不再使用的对象的内存将会自动回收，这种功能称作垃圾回收。 

• 所谓不再使用的对象，指的是没有被任何一个属性（变量）引用的对象。 

• 垃圾回收的目的是，使开发者不必为对象的生命周期管理花费太多精力。

```javascript
/*
* 垃圾回收（GC）
* 	- 就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾
* 		这些垃圾积攒过多以后，会导致程序运行的速度过慢，
* 		所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾
*  - 当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，
* 		此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，
* 		所以这种垃圾必须进行清理。
* 	- 在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，
* 		我们不需要也不能进行垃圾回收的操作
* 	- 我们需要做的只是要将不再使用的对象设置null即可
* 
*/
```



# 原型继承

• JS是一门面向对象的语言，而且它还是一个基于原型的面向对象的语言。

• 所谓的原型实际上指的是，在构造函数中存在着一个名为原型的(prototype)对象，这个对象中保存着一些属性，凡是通过该构造函数创建的对象都可以访问存在于原型中的属性。

• 最典型的原型中的属性就是toString()函数，实际上我们的对象中并没有定义这个函数，但是却可以调用，那是因为这个函数存在于Object对应的原型中。

# 设置原型

• 原型就是一个对象，和其他对象没有任何区别，可以通过构造函数来获取原型对象。

– 构造函数. prototype

• 和其他对象一样我们可以添加修改删除原型中的属性，也可以修改原型对象的引用。

• 需要注意的是prototype属性只存在于函数对象中，其他对象是没有prototype属性的。

• 每一个对象都有原型，包括原型对象也有原型。特殊的是Object的原型对象没有原型。

```javascript
/*
* 原型 prototype
* 
* 	我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype
* 		这个属性对应着一个对象，这个对象就是我们所谓的原型对象
* 	如果函数作为普通函数调用prototype没有任何作用
* 	当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，
* 		指向该构造函数的原型对象，我们可以通过__proto__来访问该属性
* 
* 	原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，
* 		我们可以将对象中共有的内容，统一设置到原型对象中。
* 
* 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，
* 	如果没有则会去原型对象中寻找，如果找到则直接使用
* 
* 以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，
* 	这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了
*/



//使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true
//console.log("name" in mc);

//可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性
//使用该方法只有当对象自身中含有属性时，才会返回true
//console.log(mc.hasOwnProperty("age"));

//console.log(mc.hasOwnProperty("hasOwnProperty"));

/*
         * 原型对象也是对象，所以它也有原型，
         * 	当我们使用一个对象的属性或方法时，会现在自身中寻找，
         * 		自身中如果有，则直接使用，
         * 		如果没有则去原型对象中寻找，如果原型对象中有，则使用，
         * 		如果没有则去原型的原型中寻找,直到找到Object对象的原型，
         * 		Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined
         */
```



# 获取原型对象的方法

• 除了可以通过构造函数获取原型对象以外，还可以通过具体的对象来获取原型对象。

– Object.getPrototypeOf(对象) 

– 对象.__proto__

– 对象. constructor.prototype

• 需要注意的是，我们可以获取到Object的原型对象，也可以对它的属性进行操作，但是我们不能修改Object原型对象的引用。

```javascript
//使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true
			//console.log("name" in mc);
			
			//可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性
			//使用该方法只有当对象自身中含有属性时，才会返回true
			//console.log(mc.hasOwnProperty("age"));
			
			//console.log(mc.hasOwnProperty("hasOwnProperty"));
			
			/*
			 * 原型对象也是对象，所以它也有原型，
			 * 	当我们使用一个对象的属性或方法时，会现在自身中寻找，
			 * 		自身中如果有，则直接使用，
			 * 		如果没有则去原型对象中寻找，如果原型对象中有，则使用，
			 * 		如果没有则去原型的原型中寻找,直到找到Object对象的原型，
			 * 		Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined
			 */
```



# 原型链

*  基于我们上边所说的，每个对象都有原型对象，原型对象也有原型对象。
*  由此，我们的对象，和对象的原型，以及原型的原型，就构成了一个原型链。
* 比如这么一个对象：

​		– var mc = new MyClass(123,456);

​		– 这个对象本身，原型MyClass.proprototype原型对象的原型对象是Object，Object对象还有其原型。这组对象就构成了一个原型链。

​		– 这个链的次序是：mc对象、mc对象原型、原型的原型（Object）、Object的原型

* 当从一个对象中获取属性时，会首先从当前对象中查找，如果没有则顺着向上查找原型对象，直到找到Object对象的原型位置，找到则返回，找不到则返回undefined。

# instanceof

*  之前学习基本数据类型时我们学习了typeof用来检查一个变量的类型。
* 但是typeof对于对象来说却不是那么好用，因为任何对象使用typeof都会返回Object。而我们想要获取的是对象的具体类型。
* 这时就需要使用instanceof运算符了，它主要用来检查一个对象的具体类型。
* 语法：

​		– var result = 变量 instanceof 类型

# 引用类型

* 上边我们说到JS中除了5种基本数据类型以外其余的全都是对象，也就是引用数据类型。
* 但是虽然全都是对象，但是对象的种类却是非常繁多的。比如我们说过的Array（数组），Function

（函数）这些都是不同的类型对象。

* 实际上在JavaScript中还提供了多种不同类型的对象。

# Object

* 目前为止，我们看到的最多的类型就是Object，它也是我们在JS中使用的最多的对象。
* 虽然Object对象中并没有为我们提供太多的功能，但是我们会经常会用途来存储和传输数据。
* 创建Object对象有两种方式：

​		– var obj = new Object();

​		– var obj = {}

* 上边的两种方式都可以返回一个Object对象。
* 但是第一种我们使用了一个new关键字和一个Object()函数。
* 这个函数就是专门用来创建一个Object对象并返回的，像这种函数我们称为构造函数。

# Array

* Array用于表示一个有序的数组。
* JS的数组中可以保存任意类型的数据。
* 创建一个数组的方式有两种：

​	– 使用构造器：

```javascript
  var arr = new Array(数组的长度);
  var arr = new Array(123,’hello’,true);
```

​	– 使用[]

*  var arr = [];
* var arr = [123,’hello’,false];
* 读取数组中的值使用数组[索引]的方式，注意索引是从0开始的。

# Date

* Date类型用来表示一个时间。
* Date采取的是时间戳的形式表示时间，所谓的时间戳指的是从1970年1月1日0时0秒0分开始经过的毫秒数来计算时间。

* 直接使用new Date()就可以创建一个Date对象。
* 创造对象时不传参数默认创建当前时间。可以传递一个毫秒数用来创建具体的时间。
* 也可以传递一个日期的字符串，来创建一个时间。

​		– 格式为：月份/日/年 时:分:秒 

​		– 例如：06/13/2004 12:12:12

# Function

• Function类型代表一个函数，每一个函数都是一个Function类型的对象。而且都与其他引用类型一样具有属性和方法。

• 由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。

• 函数的声明有两种方式：

– function sum(){}

– var sum = function(){};

• 由于存在函数声明提升的过程，第一种方式在函数声明之前就可以调用函数，而第二种不行。

# 函数也可以作为参数

• 函数也是一个对象，所以函数和其他对象一样也可以作为一个参数传递给另外一个函数。

• 但是要注意的是使用函数作为参数时，变量后边千万不要加()，不加()表示将函数本身作为参数，加上以后表示将函数执行的结果作为参数。

# 函数对象的方法

• 每个函数都有两个方法call()和apply()。 

• call()和apply()都可以指定一个函数的运行环境对象，换句话说就是设置函数执行时的this值。

• 使用方式：

– 函数对象.call(this对象,参数数组) 

– 函数对象.apply(this对象,参数1,参数2,参数N)

# 闭包（closure） 

• 闭包是JS一个非常重要的特性，这意味着当前作用域总是能够访问外部作用域中的变量。因为函数是JS中唯一拥有自身作用域的结构，因此闭包的创建依赖于函数。 

• 也可以将闭包的特征理解为，其相关的局部变量在函数调用结束之后将会继续存在。

# 基本包装类型

• 基本数据类型是不能去调用方法的，所以JS中还提供了3个特殊的引用类型：

– Boolean

– Number

– String

• 这三个类型分别包装了Boolean、Number、String并扩展了许多实用的方法。

• 他们的使用方式和普通的对象一样。

• 要注意的是使用typeof检查这些包装类型时返回的都是object。

## Boolean

• Boolean 类型是与布尔值对应的引用类型。 

• 可以采用这种方式创建：

– var booleanObject = new Boolean(true);

• 我们最好永远不要使用Boolean包装类。

## Number

• Number是数值对应的引用数据类型。创建Number对象只需要在调用构造函数时传递一个数值：

– var num = new Numbaer(20);

• 使用数值时我们建议使用基本数值，而不建议使用包装类。

## String

• String 类型是字符串的对象包装类型，可以像下面这样使用 String 构造函数来创建。

– var str = new String("hello world");

• 可以使用length属性来获取字符串的长度。

## Math

• JS 还为保存数学公式和信息提供了一个公共位置，即 Math 对象。 

• 与我们在 JavaScript 直接编写的计算功能相比， Math 对象提供的计算功能执行起来要快得多。 Math 对象中还提供了辅助完成这些计算的属性和方法。

### Math对象的属性







| 属性         | 说明                             |
| ------------ | -------------------------------- |
| Math.E       | 自然对数的底数，即常量 e 的值    |
| Math.LN10    | 10的自然对数                     |
| Math.LN2     | 2的自然对数                      |
| Math.LOG2E   | 以2为底 e 的对数                 |
| Math.LOG10E  | 以10为底 e 的对数                |
| Math.PI      | π的值                            |
| Math.SQRT1_2 | 1/2的平方根（即2的平方根的倒数） |
| Math.SQRT2   | 2的平方根                        |

### Math的方法

• 最大最小值

​	– Math.max()获取最大值

​	– Math.min()获取最小值

• 舍入：

​	– 向上舍 Math.ceil()

​	– 向下舍 Math.floor()

​	– 四舍五入 Math.round()

• 随机数： Math.random()

​	– 选取某个范围内的随机值：

• 值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)
